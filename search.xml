<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/%E7%A7%91%E6%8A%80/0.html"/>
      <url>/%E7%A7%91%E6%8A%80/0.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title: Test</span><br><span class="line">name: 97年的顽石</span><br><span class="line">avatar: https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/husky.png</span><br><span class="line">home: &apos;https://tanghao.fun/&apos;</span><br><span class="line">authorDesc: 一条咸鱼罢了</span><br><span class="line">categories: 科技</span><br><span class="line">tags:</span><br><span class="line">  - typora</span><br><span class="line">description: Typora快捷键</span><br><span class="line">photos: https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/husky.png</span><br><span class="line">abbrlink: </span><br><span class="line">date: 2019-09-12 14:48:24</span><br><span class="line">toc: true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sample</title>
      <link href="/tech/f6a773f5.html"/>
      <url>/tech/f6a773f5.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keywords:       #简单总结几个标签，方便搜索引擎收录</span><br><span class="line">description:    #一句话介绍，方便搜索引擎收录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 当务之急 : 学完java核心内容(魔乐科技)、再系统学springcloud和python语法</span><br><span class="line">之前这种零碎的学，明显太浪费时间，还不怎么有效果</span><br><span class="line">1.1 线程剩下的</span><br><span class="line">1.2 红黑树原理简析</span><br><span class="line">1.3 开发支持类库</span><br><span class="line">1.4 其他 简介</span><br><span class="line">2.1 开始Springcloud学习， 既然大佬也开始学习了</span><br><span class="line"></span><br><span class="line">不必要:</span><br><span class="line">1 twitter图标什么的一下注释掉</span><br><span class="line">3 SEO</span><br><span class="line">4 闲来无事网页右侧滚动条?</span><br><span class="line">5 站内地址  https://tanghao.fun/post/abbrlink</span><br><span class="line"></span><br><span class="line">只有自己写的博客, 的图片, 才上传到github, 那么, 未来三五年都够用</span><br></pre></td></tr></table></figure><script>    if("8264"==prompt("请输入文档密码"))    {        alert("密码正确");    }    else    {        alert("密码错误返回主页");        location="/";    }</script><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">02</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">03</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">04</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">05</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">06</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">07</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">08</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> main </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/tech/784dd132.html"/>
      <url>/tech/784dd132.html</url>
      
        <content type="html"><![CDATA[<p>1 先兔后龟</p><p>2 一般一个领域一个领域的刷比较好，先从简单、数组 开始刷。</p><p><a href="https://www.zhihu.com/question/30737325/answer/177097618">路线规划</a>（刷 leetcode 需要哪些基础？toraoh hdu）</p><p><img src="https://pic3.zhimg.com/80/v2-87ec17ec6e2270c8ab7852d6ece3cab2_hd.png" alt="img"></p><p><a href="https://www.zhihu.com/question/39594307/answer/82117096">方法论</a>（国内应届生是不是把Leetcode刷的滚瓜烂熟就能进google了？匿名用户搬运一篇陈皓 <a href="https://www.zhihu.com/people/ed1bff9f8d1dd80f45c88aa150795078">陈皓</a> 写的关于leetcode的文章，觉得写的很中肯。）</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫基础 Req+res</title>
      <link href="/tech/ae11d132.html"/>
      <url>/tech/ae11d132.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-http">一. http:</h3><p>1 当用户在地址输入入了网址发送网络请求的过程是什么<br>2 http的请求方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get请求  </span><br><span class="line">优点: 比较便捷</span><br><span class="line">缺点: 不安全 → 明文</span><br><span class="line">参数的长度有限制</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">post请求</span><br><span class="line">⑴比较安全</span><br><span class="line">(2)数据整体没有限制</span><br><span class="line">⑶上传文件</span><br><span class="line">put(不完全的)</span><br><span class="line">delete(删除一些馆息)</span><br><span class="line">发送网络请求(需要带一定的数据给服务器,不带数据也可以) </span><br><span class="line">请求头里面requestheader </span><br><span class="line">返回数据:response</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">head(请求头)</span><br><span class="line">(1)Accept:文本的格式</span><br><span class="line">(2)Accept-Encoding:编码格式</span><br><span class="line">(3)Connection:长链接短链接</span><br><span class="line">(4&#125;Cookie:证明身份用的</span><br><span class="line">(5)Host:域名</span><br><span class="line">(6)Referer:标志从哪个页面跳转过来的</span><br><span class="line">⑺User-Agent:浏览器和用户的信息</span><br></pre></td></tr></table></figure><h3 id="二-爬虫入门">二. 爬虫入门:</h3><p>使用代码模拟用户批量的发送网络请求, 批量的获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 爬虫的价值;</span><br><span class="line">(1)买卖数据(萵镝的领域价格特别贵)</span><br><span class="line">(2)数据分析:出分析报告</span><br><span class="line">(3)流量</span><br><span class="line">(4)指数阿里指数.百度指数</span><br><span class="line">2 合法性:灰色产业</span><br><span class="line">政府没有法律现定爬虫是违法的,也没有法律现定爬虫是合法的 公司概念:公司让你爬数据库(窃取商业机密)贾任在公司</span><br><span class="line">3 爬虫可以爬取所有东西?(不是)爬虫只能爬取用户能访问到的数据 爱奇艺的视頻(vip/非vip)</span><br><span class="line">(1)普通用户,只能看非vip.  爬取非vip的的视频</span><br><span class="line">(2)vip爬取vip的视頻</span><br><span class="line">(3)普通用户想要爬取vip视频(黑客)</span><br></pre></td></tr></table></figure><h3 id="三-爬虫的分类">三. 爬虫的分类:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 通用爬虫</span><br><span class="line">(1) 使用捜索引擎:百度、谷歌、360、雅虎、搜狗</span><br><span class="line">优势:开放性、速度快</span><br><span class="line">劣势:目标不明确</span><br><span class="line">返回内容:基本上％90是用户不需要的</span><br><span class="line">不満楚用户的需求在娜里</span><br><span class="line">2. 聚焦爬虫(学习)</span><br><span class="line">1.目标明确</span><br><span class="line">2.对用户的需求非常准</span><br><span class="line">3.返回的内容固定</span><br><span class="line">增量式: 翻页(从第一页请求到最后一页)</span><br><span class="line">Deep深度爬虫:  静态数据:html css</span><br><span class="line">动态数据:  js代码.加密的js</span><br><span class="line">robots:是否允许其他爬虫(通用爬虫)爬取某些内容</span><br><span class="line">聚焦爬虫不遵守robots</span><br><span class="line">爬虫和反扒做斗争: 资源对等(人、技术)的情况下, 胜利的永远是爬虫</span><br></pre></td></tr></table></figure><h3 id="四-爬虫的工作原理">四. 爬虫的工作原理;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.确定你抓取的目标url是哪一个(找)</span><br><span class="line">2.使用python代码发送请求获取数据(java Go)</span><br><span class="line">3.解析获取到的数据(精确数据)</span><br><span class="line">找到新的目标(url)回到第一步(自动化(重点))</span><br><span class="line">4.数据持久化</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Cli安装</title>
      <link href="/tech/5961223a.html"/>
      <url>/tech/5961223a.html</url>
      
        <content type="html"><![CDATA[<p>1 安装nodejs(自带npm) 官网下载<br>2 npm 安装 cnpm  (打开管理员模式 的 cmd/powershell)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 或使用如下语句解决 npm 速度慢的问题</span><br><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g </span><br><span class="line"><span class="meta">#</span> 查看是否安装成功</span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>2 cnpm 安装 vue-cli</p><blockquote><p><strong>尽量不要用cnpm, 但是npm装不上就用它</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br><span class="line"><span class="meta">#</span> 查看是否安装成功</span><br><span class="line">vue -V   </span><br><span class="line">vue list</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win-Mysql 查看并修改编码</title>
      <link href="/tech/4e5011d8.html"/>
      <url>/tech/4e5011d8.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>(linux + docker + mysql的话,可以无视以下)</p><p>(linux + docker + mysql的话,可以无视以下)</p><p>(linux + docker + mysql的话,可以无视以下)</p></blockquote><h3 id="一-win-mysql-查看并修改编码">一. win-mysql 查看并修改编码</h3><p><code>SHOW VARIABLES LIKE 'char%'</code>  查看编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">character_set_client      |  utf-8</span><br><span class="line">character_set_connection  |  utf-8    -&gt; mysql把我们客户端传递的数据都当成是utf8! 一是给它传递utf8, 二是如果我们传递的是gbk, 那么需要修改这个变量为gbk</span><br><span class="line">character_set_database    |  utf-8mb4 </span><br><span class="line">character_set_results     |  utf-8    -&gt; mysql发送给库换段的数据都是utf8的. 一是客户端用utf8编码, 二是如果客户端使用gbk来编码, 那么需要修改这个变量为gbk</span><br><span class="line">character_set_server      |  utf-8mb4</span><br><span class="line">character_set_system      |  utf-8</span><br></pre></td></tr></table></figure><blockquote><p>MySQL在5.5.3之后增加了这个utf8mb4的编码，<br>mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。<br>好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。<br>当然，为了节省空间，一般情况下使用utf8也就够了。</p></blockquote><h4 id="1-character-set-client-utf-8-无论客户端发送的是什么编码的数据-mysql都当成是utf8的数据">1 character_set_client=utf-8 ,无论客户端发送的是什么编码的数据, mysql都当成是utf8的数据</h4><blockquote><ul><li>若服务器发送的是GBK</li><li>服务器会当成utf8对待</li><li>总结: 必然乱码</li></ul></blockquote><p>处理问题的手段有两种:</p><blockquote><ul><li>1 让客户端发送utf8的数据(行不通)(win7改不了,win10估计也改不了)</li><li>2 把character_set_client修改为gbk  --&gt;  只在当前窗口内有效, 也就是说,关闭床口(小黑屏)后, 再打开, 又回到了utf8了.</li></ul></blockquote><h4 id="2-character-set-results-utf8-把数据用什么编码发送给客户端">2 character_set_results=utf8 , 把数据用什么编码发送给客户端!</h4><blockquote><ul><li>若服务发送给客户端的是utf8的数据</li><li>客户端会把它当成gbk, 因为我们的小黑屏, 只能显示gbk</li><li>总结: 必然乱码</li></ul></blockquote><p>处理问题的手段有两种:</p><blockquote><ul><li>让服务器发送gbk的数据: character_set_results=gbk</li><li>让小黑屏使用utf8来解读 (行不通)</li></ul></blockquote><h4 id="3-my-ini">3 my.ini</h4><p>在总配置文件中进行配置, 可以一劳永逸<br>mysql/mysql server 5.5/my.ini/</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">    port=3306</span><br><span class="line">[mysql]</span><br><span class="line">default-character_set=gbk <span class="comment">/*它可以一劳永逸! 它可以修改三个变量: client、result、connection*/</span></span><br></pre></td></tr></table></figure><p>然后cmd, 重启mysql, 让配置信息生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><h4 id="p-s-sqllog-会自动设置-utf-8-因为-sqllog-里面打出来的就是utf-8">P.S. SQLlog 会自动设置 utf-8, 因为 SQLlog 里面打出来的就是utf-8</h4><h3 id="end-来源-阿里云大学-java-黑马程序员-https-edu-aliyun-com-lesson-1707-13774">End. 来源: 阿里云大学/java/黑马程序员(<a href="https://edu.aliyun.com/lesson_1707_13774">https://edu.aliyun.com/lesson_1707_13774</a>)</h3>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型详解</title>
      <link href="/tech/469ee31c.html"/>
      <url>/tech/469ee31c.html</url>
      
        <content type="html"><![CDATA[<h1>java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</h1><p>作者：VieLei<br>来源：CSDN</p><p>2016年12月30日 11:44:29 <a href="https://me.csdn.net/s10461">VieLei</a> 阅读数：247414</p><blockquote><p>对java的泛型特性的了解仅限于表面的浅浅一层，直到在学习设计模式时发现有不了解的用法，才想起详细的记录一下。</p><p>本文参考<a href="http://www.cnblogs.com/sunwei2012/archive/2010/10/08/1845938.html">java 泛型详解</a>、<a href="http://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html">Java中的泛型方法</a>、 <a href="http://blog.csdn.net/caihuangshi/article/details/51278793">java泛型详解</a></p></blockquote><h1>1. 概述</h1><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p><p>什么是泛型？为什么要使用泛型？</p><blockquote><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p><p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><h1>2. 一个栗子</h1><p>一个被举了无数次的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String1</span><br></pre></td></tr></table></figure><p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错123</span></span><br></pre></td></tr></table></figure><h1>3. 特性</h1><p>泛型只在编译阶段有效。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>D/泛型测试: 类型相同</code>。</p><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h1>4. 泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p><h2 id="4-3-泛型类">4.3 泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个最普通的泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericString.getKey());<span class="number">12345678</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is <span class="number">123456</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is key_vlaue12</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p>看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());<span class="number">123456789</span></span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is false1234</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><ol><li>泛型的类型参数只能是类类型，不能是简单类型。</li></ol></li><li><ol><li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&gt;      &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ul></blockquote><h2 id="4-4-泛型接口">4.4 泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，未传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-泛型通配符">4.5 泛型通配符</h2><p>我们知道<code>Ingeter</code>是<code>Number</code>的一个子类，同时在特性章节中我们也验证过<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上是相同的一种基本类型。那么问题来了，在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，能否使用<code>Generic&lt;Ingeter&gt;</code>的实例传入呢？在逻辑上类似于<code>Generic&lt;Number&gt;</code>和<code>Generic&lt;Ingeter&gt;</code>是否可以看成具有父子关系的泛型类型呢？</p><p>为了弄清楚这个问题，我们使用<code>Generic&lt;T&gt;</code>这个泛型类继续看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;<span class="number">123</span></span><br><span class="line">Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> Generic&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </span></span><br><span class="line"><span class="comment">// cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br><span class="line"><span class="comment">// showKeyValue(gInteger);12345678</span></span><br></pre></td></tr></table></figure><p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为``Generic<Number>`的子类。由此可以看出:<strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong>。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理<code>Generic&lt;Integer&gt;</code>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示<strong>同时</strong>是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用？代替具体的类型实参，注意了，<strong>此处’？’是类型实参，而不是类型形参</strong> 。重要说三遍！<strong>此处’？’是类型实参，而不是类型形参</strong> ！ <strong>此处’？’是类型实参，而不是类型形参</strong> ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是 <strong>?</strong>  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><h2 id="4-6-泛型方法">4.6 泛型方法</h2><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p><blockquote><p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p></blockquote><p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></figure><h3 id="4-6-1-泛型方法的基本用法">4.6.1 泛型方法的基本用法</h3><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-2-类中的泛型方法">4.6.2 类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-3-泛型方法与可变参数">4.6.3 泛型方法与可变参数</h3><p>再看一个泛型方法和可变参数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4-6-4-静态方法与泛型">4.6.4 静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p><p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-5-泛型方法总结">4.6.5 泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p><blockquote><p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p></blockquote><h2 id="4-6-泛型上下边界">4.6 泛型上下边界</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><ul><li><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p><blockquote></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;<span class="number">123</span></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);</span><br><span class="line">Generic&lt;Integer&gt; generic2 = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">2222</span>);</span><br><span class="line">Generic&lt;Float&gt; generic3 = <span class="keyword">new</span> Generic&lt;Float&gt;(<span class="number">2.4f</span>);</span><br><span class="line">Generic&lt;Double&gt; generic4 = <span class="keyword">new</span> Generic&lt;Double&gt;(<span class="number">2.56</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span></span><br><span class="line"><span class="comment">//showKeyValue1(generic1);</span></span><br><span class="line"></span><br><span class="line">showKeyValue1(generic2);</span><br><span class="line">showKeyValue1(generic3);</span><br><span class="line">showKeyValue1(generic4);<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>如果我们把泛型类的定义也改一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这一行代码也会报错，因为String不是Number的子类</span></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);<span class="number">12</span></span><br></pre></td></tr></table></figure><p>再来一个泛型方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的两个例子可以看出：<strong>泛型的上下边界添加，必须与泛型的声明在一起</strong> 。</p><h2 id="4-7-关于泛型数组要提一下">4.7 关于泛型数组要提一下</h2><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是**”不能创建一个确切的泛型类型的数组”**的。</p><p>也就是说下面的这个例子是不可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];<span class="number">1</span></span><br></pre></td></tr></table></figure><p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">的一篇文档</a>的一个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.1234567</span></span><br></pre></td></tr></table></figure><blockquote><p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p><p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p></blockquote><p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK 1234567</span></span><br></pre></td></tr></table></figure><h1>5. 最后</h1><p>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。</p><hr><p>作者：VieLei<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/s10461/article/details/53941091">https://blog.csdn.net/s10461/article/details/53941091</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea便捷注释-liveTemplate</title>
      <link href="/tech/4948cd9f.html"/>
      <url>/tech/4948cd9f.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="最简化配置介绍">最简化配置介绍</h2><p>方法注释：打开file-&gt;setting-&gt;Editor-&gt;LiveTemplate  →  +号  →  Template Group  →  testTemplate  →  OK<br>→  选中testTemplate  →  +号  →  LiveTemplate  →  Abbreviation: *  ,  Desciption: add class comment  →  (如果要想要在方法内使用,必要条件: 1 Abbreviation: * 、2 Option→Expand with→Enter 、3 Template text中的【开头】【严格】按照如下格式(即以<code>*</code>第一行置顶开头) , 4 然后手打 <code>/**</code> 再按 <code>Enter</code>键)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * Description: $END$ </span><br><span class="line"> *</span><br><span class="line">$param$</span><br><span class="line">$return$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>至于为什么, 不知道, 不加live template的话, 直接输入<code>/**</code> 再回车 能且仅能获得 param<br>如有疏漏或者理解偏差, 敬请斧正</p><p>→  Edit variables   →  所有(variables)变量都要填一个表达式(Expretion) 【常用的如下】【本文最下方,有官方解释(在模板变量中使用的预定义函数)】</p><p>params参数的Expretion内容</p><blockquote><p>groovyScript(“if(”${_1}&quot;.length() == 2) {return ‘’;} else {def result=’’; def params=&quot;${_1}&quot;.replaceAll(’[\\[|\\]|\\s]’, ‘’).split(’,’).toList();for(i = 0; i &lt; params.size(); i++) {if(i&lt;(params.size()-1)){result+=’ * @param ’ + params[i] + ’ : ’ + ‘\n’}else{result+=’ * @param ’ + params[i] + ’ : '}}; return result;}&quot;, methodParameters());</p></blockquote><p>return参数的Expretion内容</p><blockquote><p>groovyScript(“def returnType = “${_1}”; def result = ’ * @return : ’ + returnType; return result;”, methodReturnType());</p></blockquote><p>Expretion:<br>user()<br>date()<br>time()<br>className()</p><blockquote><p><code>$END$</code> 表示光标最后的停留位置</p></blockquote><h2 id="关于intellij-idea中的live-templates实践">关于Intellij IDEA中的Live Templates实践</h2><h3 id="一-四-转自-https-my-oschina-net-angerbaby-blog-867090">一~四 转自:<a href="https://my.oschina.net/angerbaby/blog/867090">https://my.oschina.net/angerbaby/blog/867090</a></h3><p>[IntelliJ IDEA]</p><p>[面试：你懂什么是分布式系统吗？Redis分布式锁都不会 ]</p><h3 id="一-前言">一. 前言</h3><p>关于idea，相信已经是炙手可热的一款IDE了。越来越多的Java开发人员更倾向于选择idea。今天笔者聊一下关于idea中的Live Templates功能，Live Templates允许用户自定义功能丰富的代码模板，通过快捷键的方式可以迅速生成一段代码模板，然后只需要微调一下即可。比如我们常用的foreach代码块、if代码块等等，当然Live Templates的强大远不止于此，其内置的功能函数以及支持Groovy脚本语言的特性，允许你做一些“更疯狂”的事情，只要你想去做。</p><p>在本文中，笔者结合自己的实践经历，简单介绍一些关于Live Templates的应用场景，希望起到一种入门引导的作用。</p><h3 id="二-live-templates实现方法注释">二. Live Templates实现方法注释</h3><p>习惯使用Eclipse的用户，相信会依赖其自动生成类和方法注释的功能，其中包含了必要的javadoc注解，比如@param、@return、@author等。在Eclipse中用户还可以定制自动生成注释的行为。</p><p>那么如何在idea中自动生成类和方法注释（注释中需要对应的javadoc注解）呢？</p><h4 id="idea中的方法注释">idea中的方法注释</h4><p>idea中并不是不支持生成方法注释，在方法定义上面输入&quot;/**&quot;+回车，idea会根据当前方法中的参数和返回值，生成方法注释，其中会有@param和@return。</p><p>但是如果想修改一下自动生成方法注释中的内容，目前笔者没有找到任何办法。比如想在自动生成的方法注释中添加@author内容、添加日期信息，&quot;/**&quot;+回车的方式是不可行的。</p><p>按照自定义idea中方法注释的思路去网上搜索，会发现更多的建议是应用Live Templates来自定义满足自身需要的方法注释。</p><h4 id="idea中的类注释">idea中的类注释</h4><p>这里穿插一段关于idea类注释的说明。其实在idea中每新建一个java类，类文件头部会自动生成一段类注释。</p><p>idea允许用户自定义类注释的内容，但是相信很多人受自定义方法注释的影响，第一反应就是去Live Templates中查找idea使用的默认类注释模板。</p><p>其实笔者想在这里强调的是，自定义idea中的类注释模板，不在Live Templates中，不要冤枉它。正确的位置在下图所示的地方。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-1.png" alt="1"></p><h4 id="自定义方法注释">自定义方法注释</h4><p>上面提到了如果想自定义idea中的方法注释，需要用到Live Templates。先贴出一张截图，里面包含了笔者已经创建好的模板，用于生成笔者需要的方法注释。<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-2.png" alt="2"></p><ul><li>新建一个group，命名为“self”，表明这个组里面的模板是自定义的，可能仅适用于自己的工作场景。</li><li>在组里新建一个模板，快捷键定义为“mc”，确认方式选择“Enter”，即在应用模板的地方，输出“mc”+回车，即可生成模板内容。</li><li>观察图中的模板内容，$param$表示一个自定义的变量，用于枚举方法中的参数，即@param的内容。但是这里有个问题，就是如何循环生成方法的多个参数并且换行显示呢？虽然Live Templates中提供了一个功能函数-methodParameters()，但这个函数可以理解为只是“一串”参数，怎么拆分显示呢？这里用到了Groovy脚本语言，将$param$这个变量对应的表达式写为执行Groovy脚本，即拆分methodParameters()返回的“一串”参数，并在每个参数前面添加@param并换行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\n\\b&apos; : &apos;&apos;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-3.png" alt="3"></p><ul><li>$date$也是一个自定义变量，对应的表达式使用内置的date()函数，表示输出当前的日期。</li><li>$END$是内置的一个变量，表示模板内容生成后，光标停留的位置。生成方法注释后，可能需要填写方法的描述内容，自定义光标停留的位置可以方便后续操作。</li><li>生成的自定义模板内容后，光标默认会依次停留在自定义变量的位置，需要用户手动回车确定，直至无自定义变量为止。这个默认行为有时可能是不需要的，所以编辑自定义变量时，选中“skip if defined”即可。</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-4.png" alt="4"></p><p>OK，模板定义完了，来试一下效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int add(int p1, int p2) &#123;</span><br><span class="line">  // mc + 回车 生成方法注释</span><br><span class="line">  /**</span><br><span class="line">   *</span><br><span class="line">   * @param p1</span><br><span class="line">   * @param p2</span><br><span class="line">   * @return</span><br><span class="line">   *</span><br><span class="line">   * @author chenx</span><br><span class="line">   * @date 2017/03/25</span><br><span class="line">   */  </span><br><span class="line">  return p1 + p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没有看错！这种自定义的方法注释，需要在方法内使用快捷键才能枚举出方法参数！因为内置的methodParameters()只有在方法内的作用域才起作用！好吧，笔者也觉着这点十分不爽，还是没能达到理想的效果。不过这也算是笔者目前发现的最省事的方法注释生成方式了。</p><p>其实可以发现使用Live Templates实现方法注释生成，最大阻碍是循环枚举方法参数。如果你的注释习惯允许你可以不枚举方法参数，那么恭喜你，你可以在方法外部直接使用“mc” + 回车即可。</p><p>笔者期望idea可以提供修改&quot;/**&quot;+回车自动生成方法注释的办法。或者有知道的朋友，请不吝赐教。</p><h3 id="三-自定义常用的live-templates">三. 自定义常用的Live Templates</h3><p>上面描述了如何使用Live Templates实现生成方法注释，但最终效果笔者自认为有些牵强，不算完美。 接下来展示一些常用的代码模板定义。</p><h4 id="依赖注入私有属性">依赖注入私有属性</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-5.png" alt="5"></p><h4 id="logger实例">Logger实例</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-6.png" alt="6"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-7.png" alt="7"></p><h4 id="依赖注入属性资源">依赖注入属性资源</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-8.png" alt="8"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-9.png" alt="9"></p><p>这里可以发现，内容中定义的两个变量，没有指定表达式，表示需要用户手动输入对应的内容。模板内容生成后，光标会依次停留在变量的位置等待用户输入内容。</p><h3 id="四-总结">四. 总结</h3><p>本文介绍了Live Templates功能的简单应用，关于更复杂，更强悍的功能实现，需要不断地学习了解Live Templates的特性。养成良好的工作习惯，将自己熟悉常用的代码片段进行提炼，生成模板，相信对你的工作一定会起到事半功倍的效果。</p><p>关于idea中如何自定义生成方法注释，如果有更好的实现或建议，请多多指教~</p><h3 id="五-在模板变量中使用的预定义函数-注释-表达式-expression">五. 在模板变量中使用的预定义函数(注释 表达式 Expression)</h3><h4 id="文件模板变量">文件模板变量<a href="https://www.jetbrains.com/help/idea/file-template-variables.html#file_template_variables.xml">＃</a></h4><p>一个 <a href="https://www.jetbrains.com/help/idea/using-file-and-code-templates.html">文件模板</a>可以包含变量，这是他们的值替代应用模板时。变量是一个以美元符号（<code>$</code>）后跟变量名称开头的字符串。变量名称可以选择用大括号括起来。例如：<code>$MyVariable</code>并且 <code>${MyVariable}</code>是同一变量的不同符号。</p><h4 id="预定义的模板变量">预定义的模板变量<a href="https://www.jetbrains.com/help/idea/file-template-variables.html#predefined_template_variables">＃</a></h4><p>可以在<em>文件模板中</em>使用以下预定义变量：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>${DATE}</code></td><td style="text-align:left">当前系统日期</td></tr><tr><td style="text-align:left"><code>${DAY}</code></td><td style="text-align:left">当月的当天</td></tr><tr><td style="text-align:left"><code>${DS}</code></td><td style="text-align:left">美元符号（<code>$</code>）。此变量用于转义美元字符，因此不会将其视为模板变量的前缀。</td></tr><tr><td style="text-align:left"><code>${END}</code></td><td style="text-align:left">完成编辑变量后的插入位置</td></tr><tr><td style="text-align:left"><code>${FILE_NAME}</code></td><td style="text-align:left">新PHP文件的名称（如果启用了<a href="https://plugins.jetbrains.com/plugin/6610-php">PHP插件</a>）</td></tr><tr><td style="text-align:left"><code>${HOUR}</code></td><td style="text-align:left">当前时间</td></tr><tr><td style="text-align:left"><code>${MINUTE}</code></td><td style="text-align:left">当前分钟</td></tr><tr><td style="text-align:left"><code>${MONTH}</code></td><td style="text-align:left">这个月</td></tr><tr><td style="text-align:left"><code>${MONTH_NAME_FULL}</code></td><td style="text-align:left">当月的全名（1月，2月等）</td></tr><tr><td style="text-align:left"><code>${MONTH_NAME_SHORT}</code></td><td style="text-align:left">当前月份名称的前三个字母（Jan，Feb等）</td></tr><tr><td style="text-align:left"><code>${NAME}</code></td><td style="text-align:left">新实体的名称（文件，类，接口等）</td></tr><tr><td style="text-align:left"><code>${PACKAGE_NAME}</code></td><td style="text-align:left">创建新类或接口文件的目标包的名称</td></tr><tr><td style="text-align:left"><code>${PRODUCT_NAME}</code></td><td style="text-align:left">IDE的名称（例如，IntelliJ IDEA）</td></tr><tr><td style="text-align:left"><code>${PROJECT_NAME}</code></td><td style="text-align:left">当前项目的名称</td></tr><tr><td style="text-align:left"><code>${TIME}</code></td><td style="text-align:left">当前系统时间</td></tr><tr><td style="text-align:left"><code>${USER}</code></td><td style="text-align:left">当前用户的登录名</td></tr><tr><td style="text-align:left"><code>${YEAR}</code></td><td style="text-align:left">今年</td></tr></tbody></table><p>IntelliJ IDEA为<a href="https://www.jetbrains.com/help/idea/settings-file-and-code-templates.html#tabsIncludes">PHP包含模板</a>提供了一组附加变量，用于定义<a href="https://www.jetbrains.com/help/idea/parse-directive.html">可重用的代码片段</a>，例如文件头和<a href="https://www.jetbrains.com/help/idea/phpdoc-comments.html">PHPDoc注释</a>。</p><p><em>PHP包含模板中</em>可以使用以下附加预定义变量：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>${CARET}</code></td><td style="text-align:left">完成编辑变量后的插入位置。仅在文件创建期间生成并插入PHPDoc注释时应用。当通过Code |创建PHPDoc注释时 生成| PHPDoc块，可以选择多种功能或方法。可以为多个类，函数，方法或字段创建此案例中的文档注释，因此将<code>${CARET}</code>忽略该变量。</td></tr><tr><td style="text-align:left"><code>${CLASS_NAME}</code></td><td style="text-align:left">定义了生成PHPDoc注释的字段或方法的类的名称</td></tr><tr><td style="text-align:left"><code>${NAME}</code></td><td style="text-align:left">将为其生成PHPDoc注释的类，字段或函数（方法）的名称</td></tr><tr><td style="text-align:left"><code>${NAMESPACE}</code></td><td style="text-align:left">类或字段命名空间的完全限定名称（不带前导斜杠）</td></tr><tr><td style="text-align:left"><code>${PARAM_DOC}</code></td><td style="text-align:left">参数的文档注释。评估一组<code>@param type name</code>行。如果生成注释的函数不包含任何参数，则求值为空字符串。</td></tr><tr><td style="text-align:left"><code>${STATIC}</code></td><td style="text-align:left"><code>static</code>如果生成PHPDoc注释的函数（方法）或字段是静态的，则 替换为关键字。否则计算为空字符串。</td></tr><tr><td style="text-align:left"><code>${THROWS_DOC}</code></td><td style="text-align:left">文档注释异常。评估一组<code>@throws type</code>行。如果生成注释的函数不抛出任何异常，则求值为空字符串。</td></tr><tr><td style="text-align:left"><code>${TYPE_HINT}</code></td><td style="text-align:left">返回函数（方法）的值以生成PHPDoc注释。如果通过函数（方法）的静态分析无法检测返回类型，则求值为<code>void</code>。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea+maven私服-配置Nexus</title>
      <link href="/tech/4a61bfde.html"/>
      <url>/tech/4a61bfde.html</url>
      
        <content type="html"><![CDATA[<p>mirror和repository的区别 概念在文章 → Maven：mirror和repository 区别 - bcombetter - 博客园(已剪藏)</p><hr><p>[TOC]</p><h1><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-maven-%E7%A7%81%E6%9C%8D">#</a> 在项目中使用 Maven 私服**(Nexus)**</h1><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><h2 id="配置认证信息-镜像-maven-conf-setting-xml"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF">#</a> 配置认证信息+镜像(Maven/conf/setting.xml)</h2><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><p>效果就是Maven的所有请求必须经过镜像站点(Nexus);当Nexus出现问题后，那么Maven将强制不可用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>mirror-redirect2nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 此处配置所有的构建均从私有仓库中下载，*代表所有，也可以写成central --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mirrorOf&gt;nexus&lt;/mirrorOf&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus osc<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="snapshots-与-releases-的区别"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#snapshots-%E4%B8%8E-releases-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a> Snapshots 与 Releases 的区别</h3><ul><li>nexus-releases: 用于发布 Release 版本</li><li>nexus-snapshots: 用于发布 Snapshot 版本（快照版）</li></ul><p>Release 版本与 Snapshot 定义如下：</p><p>Release: 1.0.0/1.0.0-RELEASE</p><p>Snapshot: 1.0.0-SNAPSHOT</p><ul><li>在项目 pom.xml 中设置的版本号添加 SNAPSHOT 标识的都会发布为 SNAPSHOT 版本，没有 SNAPSHOT 标识的都会发布为 RELEASE 版本。</li><li>SNAPSHOT 版本会自动加一个时间作为标识，如：1.0.0-SNAPSHOT 发布后为变成 1.0.0-SNAPSHOT-20180522.123456-1.jar</li></ul><h2 id="配置自动化部署-idea-pom-xml部分"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2">#</a> 配置自动化部署(<strong>IDEA pom.xml部分</strong>)</h2><p>在(IDEA)pom.xml 中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>ID 名称必须要与 settings.xml 中 Servers 配置的 ID 名称保持一致。</li><li>项目版本号中有 SNAPSHOT 标识的，会发布到 Nexus Snapshots Repository, 否则发布到 Nexus Release Repository，并根据 ID 去匹配授权账号。</li></ul><h2 id="部署到仓库"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BB%93%E5%BA%93">#</a> 部署到仓库</h2><p>mvn deploy</p><h2 id="上传第三方-jar-包"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E4%B8%8A%E4%BC%A0%E7%AC%AC%E4%B8%89%E6%96%B9-jar-%E5%8C%85">#</a> 上传第三方 JAR 包</h2><p>Nexus 3.0 不支持页面上传，可使用 maven 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 如第三方JAR包：aliyun-sdk-oss-2.2.3.jar</span><br><span class="line"></span><br><span class="line">mvn deploy:deploy-file</span><br><span class="line"></span><br><span class="line">  -DgroupId=com.aliyun.oss</span><br><span class="line"></span><br><span class="line">  -DartifactId=aliyun-sdk-oss</span><br><span class="line"></span><br><span class="line">  -Dversion=2.2.3</span><br><span class="line"></span><br><span class="line">  -Dpackaging=jar</span><br><span class="line"></span><br><span class="line">  -Dfile=D:\aliyun-sdk-oss-2.2.3.jar</span><br><span class="line"></span><br><span class="line">  -Durl=http://127.0.0.1:8081/repository/maven-3rd/</span><br><span class="line"></span><br><span class="line">  -DrepositoryId=nexus-releases</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>建议在上传第三方 JAR 包时，创建单独的第三方 JAR 包管理仓库，便于管理有维护。（maven-3rd）</li><li>-DrepositoryId=nexus-releases 对应的是 settings.xml 中 Servers 配置的 ID 名称。（授权）</li></ul><h2 id="配置代理仓库-idea-pom-xml部分"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%BB%93%E5%BA%93">#</a> 配置代理仓库**(<strong><strong>IDEA pom.xml部分</strong></strong>)**</h2><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Plugin Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%BB%93%E5%BA%93">#</a> <strong>Nexus添加阿里云仓库(</strong><a href="http://192.168.213.135:8081/">http://192.168.213.135:8081</a>  <strong>登陆并设置</strong>**)：**</p><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><pre><code>    把一下都配上,并设置maven-public 调整到 maven-release/public/centrol 之前.(范例在代码最下方)</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">setting.xml</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>ibiblio<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mirrors.ibiblio.org/pub/mirrors/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss-public-repository-group<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Public Repository Group<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.org/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 中央仓库在中国的镜像 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven.net.cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>oneof the central mirrors in china<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pom.xml</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>范例:  如下图，点击  Repositories → Create repository → maven2 proxy</p><p>取名: aliyun-repository</p><p>URL：<code>http://maven.aliyun.com/nexus/content/groups/public/</code>，其他默认值即可。</p><p>2 配置public-repository：</p><p>将aliyun的repository排到最上面</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea-技巧</title>
      <link href="/tech/205cf4f6.html"/>
      <url>/tech/205cf4f6.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-idea常用快捷键">1. IDEA常用快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F在当前文件进行文本查找 （必备）</span><br><span class="line">Ctrl + R在当前文件进行文本替换 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Y删除光标所在行 或 删除选中的行 （必备）</span><br><span class="line">Ctrl + D复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + P    方法参数提示显示 （必备）</span><br><span class="line">Ctrl + Space基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl + E  显示最近打开的文件记录列表 （必备）</span><br><span class="line">Ctrl + N  根据输入的 类名 查找类文件 （必备）</span><br><span class="line">Alt  + Enter  自动导入没导入的包</span><br></pre></td></tr></table></figure><h4 id="2-修改默认新项目maven配置">2. 修改默认新项目Maven配置</h4><p>file → Other Setting → Setting for New Projects… → Build… → Maven</p><h4 id="n-小技巧-杂乱">n. 小技巧-杂乱</h4><p>1 改文件名</p><p>右键 → refacter</p><p>2 修改(基础代码补全)快捷键</p><p>file → setting → keyboard → Main menu → Code → Completion → basic 修改为Ctrl,(逗号)</p><p>还需, 搜狗输入法 → 右键 → 输入法管理 → 去掉勾选√设置搜狗输入法为默认中文输入法【为了保险: 修改搜狗输入法快捷键为Ctrl+F12】</p><p>3 注意.yml文件只可以照着修改不可把备份的yml直接黏贴过去</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea-技巧+常用快捷键</title>
      <link href="/tech/205cf4f6.html"/>
      <url>/tech/205cf4f6.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-idea常用快捷键">1. IDEA常用快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">注释：</span><br><span class="line">Ctrl + /   使用及取消 单行注释</span><br><span class="line">Ctrl + Shift + /  使用及取消 多行注释</span><br><span class="line"></span><br><span class="line">编程快捷键：</span><br><span class="line">Ctrl + Shift + Enter 跳出括号并且补全分号</span><br><span class="line"></span><br><span class="line">Ctrl + Enter 跳到新的一行</span><br><span class="line"></span><br><span class="line">导包：</span><br><span class="line">Alt  + Enter      自动导包(鼠标停在其中一个的句尾，再0.5s按一次)</span><br><span class="line">Ctrl + ，(逗号)    手动导包</span><br><span class="line"></span><br><span class="line">杂项：</span><br><span class="line">Alt  + Enter     万能快捷键： 自动导包、equals的翻转、异常捕获、、、</span><br><span class="line"></span><br><span class="line">Ctrl + F在当前文件进行文本查找 （必备）</span><br><span class="line">Ctrl + R在当前文件进行文本替换 （必备）</span><br><span class="line">Ctrl + Shift + F全局进行文本查找 （必备）</span><br><span class="line">Ctrl + Shift + R全局进行文本查找 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Y删除光标所在行 或 删除选中的行 （必备）</span><br><span class="line">Ctrl + D复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + E  显示最近打开的文件记录列表 （必备）</span><br><span class="line">Ctrl + N  根据输入的 类名 查找类文件 （必备）</span><br><span class="line">Ctrl + Space基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</span><br><span class="line">Ctrl + P    方法参数提示显示 （必备）</span><br></pre></td></tr></table></figure><h4 id="2-修改默认新项目maven配置">2. 修改默认新项目Maven配置</h4><p>file → Other Setting → Setting for New Projects… → Build… → Maven</p><h4 id="n-小技巧-杂乱">n. 小技巧-杂乱</h4><p>1 改文件名</p><p>右键 → refacter</p><p>2 修改(基础代码补全)快捷键</p><p>file → setting → keyboard → Main menu → Code → Completion → basic 修改为Ctrl,(逗号)</p><p>还需, 搜狗输入法 → 右键 → 输入法管理 → 去掉勾选√设置搜狗输入法为默认中文输入法【为了保险: 修改搜狗输入法快捷键为Ctrl+F12】</p><p>3 注意.yml文件只可以照着修改不可把备份的yml直接黏贴过去</p><p>4 复制错误提示</p><p>鼠标悬停在错误代码上，待出现错误提示后，按住Alt键，鼠标左键3连击选中/鼠标框选，Ctrl+C复制，然后baidu/Google</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(Java高级编程)类集-Java10</title>
      <link href="/tech/b9eded0.html"/>
      <url>/tech/b9eded0.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-类集框架简介">一、类集框架简介</h3><h4 id="1-类集框架简介">1. 类集框架简介</h4><p>​从JDK1.2开始，Java引入了类集开发框架，所谓的类集指的就是一套动态对象数组的实现方案，在实际的开发之中，没有任何一项的开发可以离开十足，但是传统的数组实现起来非常的繁琐。而且长度是其致命伤。正是因为长度的问题，所以传统的数组是不可能大范围使用的，但是我们的开发又不可能离开数组，所以最初就只能依靠一些数据结构来实现动态的数组处理，而其中最为重要的两个结构: 链表、树，但是面对这些数据结构的实现又不得不面对如下的一些困哪:</p><ul><li>数据结构的代码实现困难，对于一般的开发者是无法进行使用的;</li><li>对于链表或二叉树当进行更新处理的时候的维护是非常麻烦的;</li><li>对于链表或二叉树还需要尽可能保证其操作的性能。</li></ul><p>正是因为这样的原因，所以从JDK1.2开始Java引入了类集，主要就是对常见的数据结构进行完整的实现包装，并且提供有一系列的接口与实现子类来帮助用户减少数据结构所带来的的开发困难，</p><blockquote><p>这个就是类集的产生意义所在。以后数据结构不要自己来写了，但是你千万要记住一个过程: 对于现阶段开发里面，类集有它一些固定的使用方法，但是我们在进行子类选择的时候，我们一定要知道它的各个子类的实现算法是怎么回事，这样才能确保我们的程序高效。</p><blockquote><p>举个例子来讲，如果在正常的设计选择过程当中，我发现我存的数据是固定长度或者说绝对不会超过某些长度，应该是用数据来操作是最简单的吧，因为什么? 因为数组是一个线性结构，时间复杂度为1。</p><p>也就是说，正常情况来讲，类集里面它也要区分子类的不同而有所不同。</p></blockquote></blockquote><p>​但是最初的类集实现由于Java本身的技术所限，所以对于数据的控制并不严格，全部采用了Object类型进行数据接收，而在JDK1.5之后由于泛型技术的推广，所以类集本身也得到了良好的改进，可以直接利用泛型来保存相同类型的数据，并且随着数据量的不断增加，从JDK1.8开始类集中的实现算法也得到了良好的性能提升。</p><blockquote><p>但是你们在学习之中应该清楚的知道类集之中所采用的性能提高的方式是什么，这个必须自己能够说出来</p></blockquote><p>在整个类集框架里面提供有如下的几个核心接口: Collection、List、Set、Map、Iterator、Enumeration、Queue、ListIterator。</p><h4 id="2-collection接口简介">2. Collection接口简介</h4><p>java.util.Collection是单值集合操作的最大的父接口，在该接口之中定义有所有的单值数据的处理操作。这个接口之中定义有如下的核心操作方法:</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center"><font color=red> 01</font></td><td style="text-align:center"><font color=red>public boolean add(E e)</font></td><td style="text-align:center"><font color=red> 普通</font></td><td style="text-align:left"><font color=red>向集合保存数据</font></td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public boolean addAll(Collection&lt;? extends E&gt; e)</td><td style="text-align:center">普通</td><td style="text-align:left">追加一组数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public void clear()</td><td style="text-align:center">普通</td><td style="text-align:left">清空集合，让根节点为空，同时执行GC处理</td></tr><tr><td style="text-align:center">04</td><td style="text-align:center">public boolean contains(Object o)</td><td style="text-align:center">普通</td><td style="text-align:left">查询数据是否存在，需要equals()方法支持</td></tr><tr><td style="text-align:center">05</td><td style="text-align:center">public boolean remove(Object o)</td><td style="text-align:center">普通</td><td style="text-align:left">数据删除，需要equals()方法支持</td></tr><tr><td style="text-align:center">06</td><td style="text-align:center">public int size()</td><td style="text-align:center">普通</td><td style="text-align:left">获取数据长度</td></tr><tr><td style="text-align:center">07</td><td style="text-align:center">public Object[] toArray()</td><td style="text-align:center">普通</td><td style="text-align:left">将集合变为对象数组返回</td></tr><tr><td style="text-align:center"><font color=red>08</font></td><td style="text-align:center"><font color=red>public Iterator&lt;E&gt; iterator()</font></td><td style="text-align:center"><font color=red>普通</font></td><td style="text-align:left"><font color=red>将集合变为Iterator接口</font></td></tr></tbody></table><p>​在进行集合操作的时候有两个方法最为常用:【增加】add()、【输出】iterator()，在JDK1.5版本以前，Collection只是一个独立的接口，但是从JDK1.5之后提供有了Iterable父接口，并且在JDK1.8的之后针对于Iterable接口也得到了一些扩充。</p><p>​另外在JDK1.2~JDK1.4的时代如果要进行集合的使用往往会直接操作Collection的接口，但是从JDK1.5时代开始更多的情况下选择的都是Collection的两个子接口: 允许重复的List子接口、不允许重复的Set子接口;</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-1-8220.png" alt="1"></p><blockquote><p>现阶段的开发不要再去用Collection了，这个主要是 微软的Sun的 战争引起的。</p></blockquote><h3 id="二-list集合">二、List集合</h3><h4 id="1-list接口简介">1. List接口简介</h4><p>List是Collection的子接口，其最大的特点是允许保存有重复元素数据，该接口的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是需要清楚的是List子接口对于Collection接口进行了方法扩充。</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center"><font color=red>01</font></td><td style="text-align:center"><font color=red>public E get(int index)</font></td><td style="text-align:center"><font color=red>普通</font></td><td style="text-align:left"><font color=red>获取指定索引上的数据</font></td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public E set(int index,E element)</td><td style="text-align:center">普通</td><td style="text-align:left">修改指定索引数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public ListIterator<E> listIterator()</td><td style="text-align:center">普通</td><td style="text-align:left">返回ListIterator接口对象</td></tr></tbody></table><p>​但是List本身依然属于一个接口，那么对于接口要想使用则一定要使用子类来完成定义，在List子接口中有三个常用子类: ArrayList、LinkedList、Vector。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-2-8220.png" alt="2"></p><p>​从JDK1.9开始，List子接口里面追加有一些static方法，以方便用户的处理。</p><p><strong>范例:</strong> 观察List中的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = List.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"你好"</span>,<span class="string">"NGP"</span>,<span class="string">"饿了么?"</span>);</span><br><span class="line">Object result [] = all.toArray();</span><br><span class="line"><span class="keyword">for</span>(Object temp : result) &#123;</span><br><span class="line">System.out.print(temp + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这些操作方法并不是List传统用法，是在新版本之后添加的新功能。</p><blockquote><p>在开发当中，因为JDK9或JDK10没有广泛开来，所以大家最好用原始的方式开发</p></blockquote><h4 id="2-arraylist子类">2. ArrayList子类</h4><p>​ArrayList是 List子接口使用最多的一个子类，但是这个子类在使用的时候也是有前提要求的，所以本次来对这个类的相关定义以及源代码组成进行分析，在 Java 里面ArrayList类的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​ArrayList子类的继承结构</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-3-8220.png" alt="3"></p><p><strong>范例:</strong> 使用ArrayList实例化List父接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过本程序可以发现List存储的特征:</p><ul><li>保存的顺序就是其存储顺序;</li><li>List集合里面允许存在有重复数据。</li></ul><p>在以上的程序里面虽然实现了集合的输出，但是这种输出的操作是直接利用了每一个类提供的toString()方法实现的，为了方便的进行处理，在JDK1.8之后Iterable父接口之中定义有一个forEach()方法，方法定义如下:</p><ul><li>输出支持: default void forEach(Consumer&lt;? super T&gt; action)</li></ul><p><strong>范例:</strong> 利用forEach()方法输出(不是标准输出)</p><blockquote><p>只是在使用java的时候方便一些，正常开发是不可能用它来完成的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.forEach((str)-&gt;&#123;</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​需要注意的是，此种输出并不是在正常开发情况下要考虑的操作形式。</p><p><strong>范例:</strong> 观察List集合的其他操作方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">System.out.println(<span class="string">"集合是否为空?"</span> + all.isEmpty() + <span class="string">"、集合元素个数: "</span> + all.size());</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>);  <span class="comment">//重复数据</span></span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.remove(<span class="string">"Hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"集合是否为空?"</span> + all.isEmpty() + <span class="string">"、集合元素个数: "</span> + all.size());</span><br><span class="line">all.forEach((str)-&gt;&#123;</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果以方法的功能为例，那么ArrayList里面操作支持与之前编写的链表形式是非常相似的，但是它并不是使用链表来实现的，通过类名称实际上就已经可以清楚的发现了，ArrayList应该封装的是一个数组。</p><table><thead><tr><th>ArrayList构造:<br/>public ArrayList()</th><th>public ArrayList() {<br/>  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br/>}<br/>--------------------------------<br/>public</th></tr></thead><tbody><tr><td></td><td>private static final Object[] EMPTY_ELEMENTDATA = {};</td></tr><tr><td>ArrayList构造:<br/>public ArrayList(int initialCapacity)</td><td>public ArrayList(int initialCapacity) {<br/>  if (initialCapacity &gt; 0) {<br/>    this.elementData = new Object[initialCapacity];<br/>  } else if (initialCapacity == 0) {<br/>    this.elementData = EMPTY_ELEMENTDATA;<br/>  } else {<br/>    throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);<br/>  }<br/>}</td></tr><tr><td></td><td>transient Object[] elementData;// non-private to simplify nested class access</td></tr></tbody></table><p>​通过有参构造方法可以发现，在ArrayList里面所包含的数据实际上就是一个对象数组。如果现在在进行数据追加的时候发现ArrayList集合里面保存的对象数组的长度不够的时候，会进行新的数组开辟，同时将原始的旧数组内容拷贝到新数组之中，而后数组的开辟操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>) ? newCapacity: hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果在实例化ArrayList类对象的时候并没有传递初始化的长度，则默认情况下会使用一个空数组，但是如果在进行数据增加的时候发现数组容量不够了。则会判断当前的增长的容量与默认的容量的大小，使用较大的一个数据进行新的数组开辟，所以可以得出一个结论:</p><table><thead><tr><th>JDK1.9之后:</th><th>ArrayList默认的构造只会使用默认的空数组，使用的时候才会开辟数组，默认的开辟长度为10;</th></tr></thead><tbody><tr><td>JDK1.9之前</td><td>ArrayList默认的构造实际上就会默认开辟大小为10的数组。</td></tr></tbody></table><p>​当ArrayList之中保存的容量不足的时候会采用成倍的方式进行增长，原始长度为10，那么下次的增长就是20，依此类推。</p><p>​在使用ArrayList子类的时候一定要估算出你的数据量会有多少，如果超过了10个，那么使用有参构造方法进行创建，以避免垃圾数组的空间产生。</p><h4 id="3-arraylist保存自定义类对象">3. ArrayList保存自定义类对象</h4><p>通过之前的分析已经清楚了ArrayList子类的实现原理以及List核心操作，但是在测试的时候使用的是系统提供的String类，这是一个设计非常完善的类，而对于类集而言也可以实现自定义类对象的保存。</p><p><strong>范例:</strong> 实现自定义类对象的保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == obj) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person per = (Person) obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.equals(per.name) &amp;&amp; <span class="keyword">this</span>.age == per.age;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//setter、getter、构造略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;Person&gt; all = <span class="keyword">new</span> ArrayList&lt;Person&gt; ();</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">30</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">16</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>));</span><br><span class="line">System.out.println(all.contains(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>)));</span><br><span class="line">all.remove(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>));</span><br><span class="line">all.forEach(System.out::println); <span class="comment">//方法引用代替了消费型的接口，不是标准做法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在使用List保存自定义类对象的时候如果需要使用到contains()、remove()方法进行查询与删除处理的时候，一定要保证类之中已经成功覆写了equals()方法。</p><h4 id="4-linkedlist子类">4. LinkedList子类</h4><p>​在List接口里面还有另外一个比较常用的子类: LinkedList,这个类通过名称就已经可以发现其特点了: 基于链表的实现，那么我们首先来观察一下LinkedList子类的定义:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-4-8220.png" alt="4"></p><p>范例: 使用LinkedList实现集合操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> LinkedList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>); <span class="comment">//重复数据</span></span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果说现在只是观察程序的功能你会发现和ArrayList使用是完全一样的，但是其内部的实现机制是完全不同的，首先观察LinkedList构造方法里面并没有提供有像ArrayList那样的初始化大小的方法，而只是提供有无参构造处理:  “public LinkedList()” 随后观察add()方法的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在之前编写自定义链表的时候，是判断了传入数据是否为null，如果为null则不进行保存，但是在LinkedList里面并没有做这样的处理，而是所有的数据都可以保存，而后此方法调用了linkLast()方法 (在最后一个节点进行追加)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在LinedList类里面保存的数据都是利用Node节点进行的封装处理，同时为了提高程序执行性能，每一次都会保存上一个追加的节点(最后一个节点)，这样就可以在增加数据的时候避免递归处理，在增加数据的时候要进行数据保存个数的追加。</p></blockquote><p>​通过一系列的分析之后可以发现，LinkedList封装的就是一个链表实现。</p><p><strong>面试题:</strong> 请问ArrayList与LinkedList有何区别?</p><ul><li>ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作。</li><li>在使用List集合中的get()方法根据索引取数据时，ArrayList的时间复杂度为&quot;O(1)&quot;，而LinkedList时间复杂度为&quot;O(n)&quot;(n为集合的长度)</li><li>ArrayList在使用的时候，默认的初始化对象数组的大小长度为10，如果空间不足则会采用2倍的形式进行容量的扩充，如果保存大数据量的时候有可能会造成垃圾的产生以及性能的下降，但是这个时候可以使用LinkedList子类保存。</li></ul><h4 id="5-vector子类">5. Vector子类</h4><p>​Vector是一个原始古老的程序类，这个类是在JDK1.0的时候就提供的，而后到了JDK1.2的时候由于许多的开发者已经习惯于使用Vector，并且许多的系统类也是基于Vector实现的，考虑到其使用的广泛性，所以类集框架将其保存了下来，并且让其多实现了一个List接口，观察Vector定义结构:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​继承结构与ArrayList是相同的，所以来讲这个类继承结构如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-5-8220.png" alt="5"></p><p><strong>范例:</strong> Vector类的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> Vector&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>); <span class="comment">//重复数据</span></span><br><span class="line">all.add(<span class="string">"World"</span>); </span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面可以进一步的观察Vector类实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Vector类如果使用的是无参构造方法，则一定会默认开辟一个10个长度的数组，而后其余的实现操作与ArrayList是相同的，通过源代码的分析可以发现Vector类之中的操作方法采用的都是synchronized同步处理，而ArrayList并没有进行同步处理，所以Vector类之中的方法在多线程访问的时候属于线程安全的，但是性能不如ArrayList高。</p></blockquote><h3 id="三-set集合">三、Set集合</h3><h4 id="1-set接口简介">1. Set接口简介</h4><p>​Set集合最大的特点就是不允许保存重复元素，其也是Collection子接口。</p><p>​在JDK1.9以前Set集合与Collection集合的定义并无差别，Set继续使用了Collection接口中提供的方法进行操作，但是从JDK1.9之后，Set集合也像List集合一样扩充了一些static方法，Set集合的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​需要注意的是Set集合并不像List集合那样扩充了许多的新方法，所以无法使用List集合中提供的get()犯法，也就是说，它无法实现指定索引数据的获取，Set接口的继承关系如下。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-6-8220.png" alt="6"></p><p>​从JDK1.9之后，Set集合也提供像List集合之中类似的of()的静态方法。下面就使用此方法进行Set集合特点的验证。</p><p><strong>范例:</strong> 验证Set集合特征</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;String&gt; all = Set.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>,<span class="string">"Hello"</span>,<span class="string">"World"</span>);</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果: <code>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: duplicate element: Hello</code></p><p>​当使用of()这个新方法的时候如果发现集合之中存在有重复元素则会直接抛出异常。这与传统的Set集合不保存重复元素的特点相一致，只不过自己抛出了异常而已。</p><p>​Set集合的常规使用形式一定是依靠子类进行实例化的，所以Set接口之中有两个常用子类: HashSet、TreeSet。</p><h4 id="2-hashset子类">2. HashSet子类</h4><p>​HashSet是Set接口里面使用最多的一个子类，其最大的特点就是保存的数据是无序的，而HashSet子类的继承关系如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​这种继承的形式和之前的ArrayList是非常相似的，那么现在来观察一下类的继承结构。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-7-8220.png" alt="7"></p><p><strong>范例:</strong> 观察HashSet子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;() ;</span><br><span class="line">all.add(<span class="string">"DDDD"</span>);</span><br><span class="line">all.add(<span class="string">"DDDD"</span>); <span class="comment">//重复元素</span></span><br><span class="line">all.add(<span class="string">"CCC"</span>);</span><br><span class="line">all.add(<span class="string">"BB"</span>);</span><br><span class="line">all.add(<span class="string">"A"</span>);</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过执行结果就可以发现HashSet子类的操作特点: 不允许保存重复元素(Set接口定义的)，另外一点HashSet之中保存的数据是无序的。</p><h4 id="3-treeset子类">3. TreeSet子类</h4><p>​Set接口的另外一个子类就是TreeSet，与HashSet最大的区别在于TreeSet集合里面所保存的数据是有序的，首先来观察一下TressSet类的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​在这个子类里面依然继承了AbstractSet父抽象类，同时又实现了一个NavigableSet父接口。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-8-8220.png" alt="8"></p><p><strong>范例:</strong> 使用TreeSet子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> TreeSet&lt;String&gt;() ;</span><br><span class="line">all.add(<span class="string">"DDDD"</span>);</span><br><span class="line">all.add(<span class="string">"DDDD"</span>); <span class="comment">//重复元素</span></span><br><span class="line">all.add(<span class="string">"CCC"</span>);</span><br><span class="line">all.add(<span class="string">"BB"</span>);</span><br><span class="line">all.add(<span class="string">"A"</span>);</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当利用TreeSet保存的数据的时候所有的数据都将按照数据的升序进行自动排序处理。</p><h4 id="4-treeset子类排序操作">4. TreeSet子类排序操作</h4><p>​经过分析之后TreeSet子类之中爆粗你的数据是允许排序的，但是这个类必须实现Comparable接口，因为只有实现了此接口才能够确认出对象的大小关系。</p><blockquote><p>提示: TreeSet本质上是利用TreeMap子类实现的集合数据的存储，而TreeMap(树) 就需要根据Comparable来确定大小关系。</p></blockquote><p>​那么下面就使用一个自定义的类来实现排序的处理操作。</p><p><strong>范例:</strong> 实现自定义类排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;<span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line"><span class="comment">//return this.age - per.age ;//因为只判断年龄，所以李四没存进去</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; per.age) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; per.age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(per.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;Person&gt; all = <span class="keyword">new</span> TreeSet&lt;Person&gt;() ;</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">19</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));<span class="comment">//年龄相同，但是姓名不同</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">78</span>));</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在使用自定义类对象进行比较处理的时候一定要将该类之中的所有属性都依次进行大小关系的匹配，否则如果某一个或某几个属性相同的时候，它也会认为是重复数据，所以TreeSet是利用了Comparable接口来确认重复数据的。</p><p>​由于TreeSet在操作过程之中需要将类中的所有属性进行比对，这样的实现难度太高了，那么在实际的开发之中应该首选HashSet子类进行存储。</p><h4 id="5-分析重复元素消除">5. 分析重复元素消除</h4><p>​TreeSet子类是利用了Comparable接口来实现了重复元素的判断，但是Set集合的整体特征就是不允许保存重复元素。但是HashSet判断重复元素的方式并不是利用Comparable接口完成的，它利用的是Object类中提供的方法实现的:</p><ul><li><strong>对象编码:</strong> public int hashCode()</li><li><strong>对象比较:</strong> public boolean equals(Object obj)</li></ul><p>在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果改编码不存在则表示数据不存在，证明没有重复，如果该编码存在了，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。如果使用的是Eclipse开发工具，则可以帮助开发者自动创建hashCode()与equals()方法。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-9-8220.png" alt="9"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-10-8220.png" alt="9"></p><p><strong>范例:</strong> 实现重复元素处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;<span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">result = prime * result + age;</span><br><span class="line">result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Person other = (Person) obj;</span><br><span class="line"><span class="keyword">if</span> (age != other.age)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;Person&gt; all = <span class="keyword">new</span> HashSet&lt;Person&gt;() ;</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">19</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));<span class="comment">//年龄相同，但是姓名不同</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">78</span>));</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在Java程序之中真正的重复元素的判断处理利用的就是hashCode()与equals()两个方法共同作用完成的，而只有在排序要求的情况下(TreeSet)才会利用Comparable接口来实现。</p><h3 id="四-集合输出">四、集合输出</h3><p>​集合输出实际上从JDK1.8开始就在Iterable接口之中提供有一个forEach()方法，但是这种方法的迭代输出并不是传统意义上的集合输出形式，并且也很难在实际的开发之中出现，对于集合操作而言，一共有四种输出形式: Iterator迭代输出(95%)、ListIterator双向迭代输出(0.1%)、Enumeration枚举输出(4.9%)、foreach输出(与Iterator相当)。</p><h4 id="1-iterator迭代输出">1. Iterator迭代输出</h4><p>​通过Collection接口的继承关系可以发现，从JDK1.5开始其多继承了一个Iterable父接口，并且在这个接口里面定义有一个Iterator()操作方法，通过此方法可以获取Iterator接口对象(在JDK1.5之前，这一方法直接定义在Collection接口之中)。</p><ul><li>获取Iterator接口对象: public Iterator<T> iterator()</li></ul><p>在Iterator接口里面定义有如下的方法:</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">boolean hasNext()</td><td style="text-align:center">普通</td><td style="text-align:left">判断是否有数据</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public E next()</td><td style="text-align:center">普通</td><td style="text-align:left">取出当前数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public default void remove()</td><td style="text-align:center">普通</td><td style="text-align:left">删除</td></tr></tbody></table><p>​在之前使用的java.util.Scanner类就是Iterator接口的子类，所以此时类的继承关系如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-11-8220.png" alt="11"></p><p><strong>范例:</strong> 使用Iterator输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; all = Set.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = all.iterator() ; <span class="comment">//实例化Iterator接口对象</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String str = iter.next() ;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​但是对于Iterator接口中的remove()方法的使用需要特别注意一下(如果不是必须不要使用)。实际上在Collection接口里面定义有数据的删除操作方法，但是在进行迭代输出的过程里面如果你使用了Collection中的remove方法会导致迭代失败。</p><p><strong>范例:</strong> 采用Collection集合中的remove()方法删除</p><blockquote><p>?为什么我自己写代码的时候，只是有的会显示错误信息捏 =。=? 例如: 下面的代码改为删除World的话 =。=</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = all.iterator() ; <span class="comment">//实例化Iterator接口对象</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String str = iter.next() ;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"World"</span>.equals(str)) &#123;</span><br><span class="line">all.remove(<span class="string">"World"</span>);<span class="comment">//删除当前的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"*** "</span> + all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">程序运行结果: Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><p>​此时无法进行数据的删除处理操作，那么此时就只能够利用Iterator接口中的remove()方法删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = all.iterator() ; <span class="comment">//实例化Iterator接口对象</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String str = iter.next() ;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"Hello"</span>.equals(str)) &#123;</span><br><span class="line">iter.remove();<span class="comment">//删除当前的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"*** "</span> + all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​此时程序执行之后没有出现任何的错误，并且可以成功的删除原始集合中的数据。</p><p><strong>面试题:</strong> 请解释Collection.remove() 与 Iterator.remove() 的区别?</p><ul><li>在进行迭代输出的时候如果使用了Collection.remove()则会造成并发更新的异常，导致程序删除出错，而此时只能利用Iterator.remove()方法实现正常的删除处理。</li></ul><h4 id="2-listiterator双向迭代输出">2. ListIterator双向迭代输出</h4><p>​使用Iterator进行的迭代输出操作有一个特点: 只允许由前向后实现输出，而如果说你现在需要进行双向迭代处理，那么就必须依靠Iterator的子接口: ListIterator接口来实现了。需要注意的是如果要想获取ListIterator接口对象Collection并没有定义相关的处理方法，但是List子接口有，也就是说这个输出接口是专门为List集合准备的。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-12-8220.png" alt="12">在ListIterator接口里面定义有如下的操作方法:</p><ul><li><p>判断是否有前一个元素: public boolean hasPrevious()</p></li><li><p>获取当前元素: public E previous()</p></li></ul><p><strong>范例:</strong> 实现双向迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = all.listIterator();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"由前向后输出: "</span> );</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">System.out.print(iter.next() + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"右后向前输出: "</span>);</span><br><span class="line"><span class="keyword">while</span>(iter.hasPrevious()) &#123;</span><br><span class="line">System.out.print(iter.previous() + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果要想实现右后向前的遍历，那么首先要实现的是由前向后实现遍历处理。</p><blockquote><p>例如: 把上面代码的由前向后输出部分注释掉，右后向前则没有输出了。</p></blockquote><h4 id="3-enumeration枚举输出">3. Enumeration枚举输出</h4><p>​Enumeration是在JDK1.0的时候就使用的输出接口，这个输出接口主要是为了Vector类提供输出服务的，一直到后续的JDK的发展，Enumeration依然只为Vector一个类服务，如果要想获取Enumeration接口对象，就必须依靠Vector类提供的方法:</p><ul><li>获取Enumeration: public Enumeration<E> elements()</li></ul><p>在Enumeration接口之中定义有两个操作方法:</p><ul><li>判断是否有下一个元素: public boolean hasMoreElements()</li><li>获取当前元素: public E nextElement()</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-13-8220.png" alt="13"></p><p><strong>范例:</strong> 使用Enumeration实现输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Vector&lt;String&gt; all = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">Enumeration&lt;String&gt; enu = all.elements() ;</span><br><span class="line"><span class="keyword">while</span> (enu.hasMoreElements()) &#123;</span><br><span class="line">String str = enu.nextElement();</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​由于该接口出现的时间比较长了，所以在一些比较早的开发过程之中，也有部分的方法只支持Enumeration的输出操作，但是随着类方法的不断完善，大部分的操作都直接利用Iterator实现了。</p><h4 id="4-foreach输出">4. foreach输出</h4><p>​除了使用迭代接口实现输出之外，从JDK1.5开始加强型for循环也可以实现集合的输出了。这种输出的形式与数组的输出操作形式类似。</p><p><strong>范例:</strong> 使用foreach输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line"><span class="keyword">for</span> (String str : all) &#123;</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这种输出最初出现的时候很多人并不建议使用，因为标准的集合操作还是应该以Iterator为主，但是毕竟JDK1.5都已经推出十多年了，很多的语法也开始被大部分人所习惯。</p><h3 id="五-map集合">五、Map集合</h3><p>​在之前已经学习了Collection接口以及其对应的子接口，可以发现在Collection接口之中所保存的数据全部都只是单个对象，在数结构里面除了可以进行单个对象的保存之外，实际上也可以进行二元偶对象的保存(key=value)的形式来存储，而存储二元偶对象的核心意义在于，需要通过key获取对应的value。</p><p><strong><font color=red>在开发里面：Collection集合保存数据的目的是为了输出，Map集合保存数据的目的是为了进行key的查找。</font></strong></p><h4 id="1-map接口简介">1. Map接口简介</h4><p>​Map接口是进行二元偶对象保存的最大父接口，该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​该接口为一个独立的父接口，并且在进行接口对象实例化的时候需要设置Key与Value的类型，也就是说在整体操作的时候需要保存两个内容，在Map接口里面定义有许多的操作方法，但是需要记住以下的核心操作方法：</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">public V put(K key,V value)</td><td style="text-align:center">普通</td><td style="text-align:left">向集合之中保存数据</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public V get(Object key)</td><td style="text-align:center">普通</td><td style="text-align:left">根据key查询数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td style="text-align:center">普通</td><td style="text-align:left">将Map集合转为Set集合</td></tr><tr><td style="text-align:center">04</td><td style="text-align:center">public boolean containsKey(Object key)</td><td style="text-align:center">普通</td><td style="text-align:left">查询指定的key是否存在</td></tr><tr><td style="text-align:center">05</td><td style="text-align:center">public Set<K> keySet()</td><td style="text-align:center">普通</td><td style="text-align:left">将Map集合中的key转为Set集合</td></tr><tr><td style="text-align:center">06</td><td style="text-align:center">public V remove(Object key)</td><td style="text-align:center">普通</td><td style="text-align:left">根据key删除掉指定的数据</td></tr></tbody></table><p>​从JDK1.9之后Map接口里面也扩充了一些静态方法供用户使用。</p><p><strong>范例：</strong> 观察Map集合的特点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = Map.of(<span class="string">"one"</span>,<span class="number">1</span>,<span class="string">"two"</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在Map集合之中数据的保存就是按照 “key=value” 的形式存储的，并且使用of()方法操作的时候，里面的数据是不允许重复的，如果重复则会出现 “IllegalArgumentException” 异常，如果设置的内容为null，则会出现&quot;NullPointerException&quot;异常。</p><p>​对于现在见到的of()方法严格意义上来讲并不是Map集合的标准用法，因为正常的开发之中需要通过Map接口的子类来进行接口对象的实例化，而常用的子类：HashMap、Hashtable、TreeMap、LinkedHashMap。</p><h4 id="2-hashmap子类">2. HashMap子类</h4><p>​HashMap是Map接口之中最为常见的一个子类，该类的主要特点是 <font color=red>无序存储</font>，通过java文档首先来观察一下HashMap子类的定义形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​该类的定义继承形式符合之前的集合定形式，依然提供有抽象类，并且依然需要重复实现Map接口。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-14-8220.png" alt="14"></p><p><strong>范例：</strong> 观察Map集合的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">101</span>);<span class="comment">//key重复</span></span><br><span class="line">map.put(<span class="keyword">null</span>, <span class="number">111</span>);<span class="comment">//key为null</span></span><br><span class="line">map.put(<span class="string">"zero"</span>, <span class="keyword">null</span>);  <span class="comment">//value为null</span></span><br><span class="line">System.out.println(map.get(<span class="string">"one"</span>));<span class="comment">//key存在</span></span><br><span class="line">System.out.println(map.get(<span class="keyword">null</span>));<span class="comment">//key存在</span></span><br><span class="line">System.out.println(map.get(<span class="string">"ten"</span>)); <span class="comment">//key不存在</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以上的操作形式为Map集合使用的最标准的处理形式，通过代码可以发现，通过HashMap实例化的Map接口可以针对key或value保存null的数据，同时也可以发现及时保存数据的key重复，那么也不会出现错误，而是出现内容的替换。</p><p>​但是对于Map接口中提供的put()方法本身是提供有返回值的，那么这个返回值指的是在重复key的情况下返回key的value</p><p><strong>范例：</strong> 观察put()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">System.out.println(map.put(<span class="string">"one"</span>,<span class="number">1</span>)); <span class="comment">//key不重复,返回null</span></span><br><span class="line">System.out.println(map.put(<span class="string">"one"</span>,<span class="number">101</span>)); <span class="comment">//key重复,返回旧数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在设置了相同的key的内容的时候put()方法会返回原始的数据内容.</p><p>​清楚了HashMap的基本功能之后, 下面就需要来研究一下HashMap之中给出的源代码. HashMap之中肯定要需要存储大量的数据, 那么对于数据的存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当使用无参构造的时候会出现有一个loadFactor属性, 并且该属性默认的内容为 “0.75” (<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在使用put()方法进行数据保存的时候会调用一个putVal()方法,同时会将key进行hash处理(生成一个hash码), 而对于putValue方法里面会发现依然会提供有一个Node节点类进行数据的保存, 而在使用putValue()方法操作的过程之中会调用有一个resize()的方法可以进行容量的扩充.</p></blockquote><p><strong>面试题:</strong> 在进行HashMap的put()操作的时候,如何实现容量扩充的?</p><ul><li>在HashMap类里面提供有一个 “DEFAULT_INITIAL_CAPACITY” 常量,作为初始化的容量配置,而后这个常量的默认大小为16个元素, 也就是说默认可以保存的最大内容是16;</li><li>当保存的内容的容量超过了一个阈值 (DEFAULT_LOAD_FACTOR = 0.75f), 相当于 “容量*阈值=12” 保存12个元素的时候就会进行容量的扩充;</li><li>在进行扩充的时候HashMap采用的是成倍的扩充模式, 即: 每一次都扩充2倍的容量</li></ul><p><strong>面试题:</strong> 请解释HashMap的工作原理(JDK1.8之后开始的)</p><ul><li>在HashMap之中进行数据存储的依然是利用了Node类完成的, 那么这种情况下就证明可以使用的数据结构只有两种: 链表(时间复杂度&quot;O(n)&quot;)、二叉树(时间复杂度&quot;O(logn)&quot;);</li><li>从JDK1.8开始, HashMap的实现出现了改变, 因为其要适应于大数据时代的海量数据问题,所以对于其存储发生了变化, 并且在HashMap类的内部提供有一个重要的常量: “static final int UNTREEIFY_THRESHOLD = 6;”, 在使用HashMap进行数据保存的时候,如果保存的数据个数没有超过阈值8(UNTREEIFY_THRESHOLD), 那么会按照链表的形式进行存储, 而如果超过了这个阈值, 则会将链表转为<strong>红黑树</strong>以实现树的平衡, 并且利用左旋与右旋保证数据的查询性能.</li></ul><h4 id="3-linkedhashmap子类">3. LinkedHashMap子类</h4><p>​HashMap虽然是Map集合最为常用的一个子类, 但是其本身所保存的数据都是无序的(有序与否对Map没有影响), 如果现在希望Map集合之中保存的顺序为其增加顺序, 则就可以更换子类为LinkedHashMap(基于链表实现的), 观察LinkedHashMap类的定义形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​既然是链表保存, 所以一般在使用LinkedHashMap类的时候往往数据量都不要特别大, 因为会造成时间复杂度攀升. 通过继承结构可以发现LinkedHashMap是HashMap子类,继承关系如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-15-8220.png" alt="15"></p><p><strong>范例:</strong> 使用LinkedHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">101</span>);<span class="comment">//key重复</span></span><br><span class="line">map.put(<span class="keyword">null</span>, <span class="number">111</span>);<span class="comment">//key为null</span></span><br><span class="line">map.put(<span class="string">"zero"</span>, <span class="keyword">null</span>);  <span class="comment">//value为null</span></span><br><span class="line">System.out.println(map);<span class="comment">//key存在</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过此事的程序执行可以发现当使用LinkedHashMap进行存储之后所有数据的保存顺序为我们的添加顺序.</p><h4 id="4-hashtable子类">4. Hashtable子类</h4><p>​Hashtable类是从JDK1.0的时候提供的, 与Vector、Enumeration属于最早的一批动态数组的实现类,后来为了将其继续保存下来所以让其多现实现了一个Map接口, Hashtable类的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-16-8220.png" alt="16"></p><p><strong>范例:</strong> 观察Hashtable子类的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">101</span>);<span class="comment">//key重复</span></span><br><span class="line">System.out.println(map);<span class="comment">//key存在</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过观察可以发现在Hashtable里面进行数据存储的时候设置的key或value都不允许为null, 否则会出现NullPointerException异常.</p><p><strong>面试题:</strong> 请解释HashMap与Hashtable的区别?</p><ul><li>HashMap中的方法都属于异步操作,(非线程安全), HashMap允许保存有null数据</li><li>Hashtable中的方法都属于同步方法(线程安全), Hashtable不允许保存null, 否则会出现NullPointerException.</li></ul><h4 id="5-map-entry接口">5. Map.Entry接口</h4><p>​虽然已经清楚了整个的Map集合的基本操作形式, 但是依然需要有一个核心的问题要解决, Map集合里面是如何进行数据存储的? 对于List而言(LinkedList子类) 依靠的是链表的形式实现的数据存储, 那么在进行数据存储的时候一定要将数据保存在一个Node节点之中, 虽然在HashMap里面也可以见到Node类型定义, 通过源代码定义可以发现, HashMap类中的Node内部类本身实现了Map.Entry接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>​所以可以得出结论: 所有的key和value的诗句都被封装在Map.Entry接口之中, 而此接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并且在这个内部接口里面提供有两个重要的操作方法:</p><ul><li>获取key:   public K getKey()</li><li>获取value: public V getValue()</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-17-8220.png" alt="17"></p><p>​在JDK1.9以前的开发版本之中, 使用者基本上都不会去考虑创建Map.Entry的对象, 实际上在正常的开发过程之中使用者也不需要关心Map.Entry对象的创建, 可是从 JDK1.9之后, Map接口里面追加有一个新的方法</p><ul><li>创建Map.Entry对象: public static &lt;K,V&gt; Map.Entry&lt;K,V&gt; entry(K k, V v)</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-18-8220.png" alt="18"></p><p><strong>范例:</strong> 创建Map.Entry对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map.Entry&lt;String, Integer&gt; entry = Map.entry(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"获取key: "</span> + entry.getKey());</span><br><span class="line">System.out.println(<span class="string">"获取value: "</span> + entry.getValue());</span><br><span class="line">System.out.println(entry.getClass().getName()); <span class="comment">//观察使用的子类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过分析可以发现在整个Map集合里面, Map.Entry的主要作用就是作为一个Key和Value的包装类型使用, 而大部分情况下在进行数据存储的时候都会将key和value包装为一个Map.Entry对象进行使用.</p><h4 id="6-利用iterator输出map集合">6. 利用Iterator输出Map集合</h4><p>​对于集合的输出而言, 最标准的做法就是利用Iterator接口来完成, 但是需要明确一点的是在Map集合里面并没有一个方法可以直接返回Iterator接口对象, 所以这种情况下就必须分析不直接提供Iterator接口实例化的方法的原因, 下面对Collection与Map集合的存储结构进行一个比较处理.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-19-8220.png" alt="19"></p><p>​发现在Map集合里面保存的实际上是一组Map.Entry接口对象(里面包装的是Key与Value), 所以整个来讲Map依然实现的是单值的保存, 这样在Map集合里面提供有一个方法 “public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()”, 将全部的Map集合转为Set集合.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-20-8220.png" alt="20"></p><p>经过分析可以发现如果要想使用Iterator实现Map集合的输出则必须按照如下步骤处理:</p><ul><li>利用Map接口中提供的entrySet()方法将Map集合转为Set集合</li><li>利用Set接口中的iterator()方法将Set集合转为Iterator接口实例;</li><li>利用Iterator进行迭代输出获取每一组的Map.Entry对象, 随后通过getKey()与getValue()获取数据</li></ul><p><strong>范例:</strong> 利用Iterator输出Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>) ;</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>) ;</span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet() ;<span class="comment">//将Map集合变为Set集合</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = set.iterator() ;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;String, Integer&gt; me = iter.next() ;</span><br><span class="line">System.out.println(me.getKey() + <span class="string">" = "</span> + me.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然Map集合本身支持有迭代输出的支持, 但是如果从实际的开发来讲, Map集合最主要的用法在于实现数据的Key查找操作, 另外需要提醒的是, 如果现在不使用Iterator而使用foreach语法输出则也需要将Map集合转为Set集合.</p><p><strong>范例:</strong> 使用foreach输出Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>) ;</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>) ;</span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet() ;<span class="comment">//将Map集合变为Set集合</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : set) &#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于map迭代输出的情况相对较少, 所以对于此类的语法应该深入理解一下, 并且一定要灵活掌握.</p><blockquote><p>因为在实际开发之中, 这些集合互相倒来倒去的情况是非常常见的</p></blockquote><h4 id="7-自定义map的key类型">7. 自定义Map的key类型</h4><p>​在使用Map集合的时候可以发现对于Key和Value的类型实际上都可以由使用者任意决定, 那么也就意味着现在依然可以使用自定义的类来进行key类型的设置. 对于自定义Key类型所在的类中一定要覆写hashCode()与equals()方法, 否则无法查找到.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进行数据保存的时候发现会自动使用传入的key的数据生成一个hash码, 也就是说存储的时候是这个Hash数值.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在根据key获取数据的时候依然要将传入的key通过hash()方法爱获取其对应的hash码, 那么也就证明, 查询的过程之中首先要利用我们的hashCode()来进行数据查询, 当使用getNode()方法查询的时候还需要使用到euqals()方法.</p></blockquote><p><strong>范例:</strong> 使用自定义类作为Key类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name ;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">result = prime * result + age;</span><br><span class="line">result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Person other = (Person) obj;</span><br><span class="line"><span class="keyword">if</span> (age != other.age)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"周瑜"</span>,<span class="number">28</span>), <span class="string">"字公瑾"</span>);<span class="comment">//使用自定义类作为Key</span></span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">"周瑜"</span>,<span class="number">28</span>)));<span class="comment">//通过key找到Value</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然允许你使用是定义的类作为key的类型, 但是也需要注意一点, 在实际的开发之中对于Map集合的Key常用的类型就是三种: String、Long、Integer, 尽量使用系统类.</p><p><strong>面试题:</strong> 如果在进行HashMap进行数据操作的时候出现了Hash冲突(Hash码相同), HashMap是如何解决的?</p><p>​当出现了Hash冲突之后为了保证程序的正常执行, 会在冲突的位置上将所有Hash冲突的内容转为链表保存.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-21-8220.png" alt="21"></p><h3 id="六-集合工具类">六、集合工具类</h3><h4 id="1-stack栈">1. Stack栈</h4><p>​栈是一种先进后出的数据结构. 例如: 在文本编辑器上都有撤销功能, 那么每次使用的时候你会发现, 最后一次的编辑操作永远是最先撤销, 那么这个功能就是利用栈来实现的, 栈的及基本操作形式如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-22-8220.png" alt="22"></p><p>​在Java程序里面使用Stack来描述栈的操作, 这个类定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现Stack是Vector子类, 但是它使用的并不是Vector类之中所提供的方法, 而是采用如下的两个方法:</p><ul><li>入栈: public E push(E item)</li><li>出栈: public E pop()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Stack&lt;String&gt; all = <span class="keyword">new</span> Stack&lt;String&gt; ();</span><br><span class="line">all.push(<span class="string">"A"</span>) ;</span><br><span class="line">all.push(<span class="string">"B"</span>) ;</span><br><span class="line">all.push(<span class="string">"C"</span>) ;</span><br><span class="line">System.out.println(all.pop());</span><br><span class="line">System.out.println(all.pop());</span><br><span class="line">System.out.println(all.pop());</span><br><span class="line">System.out.println(all.pop());<span class="comment">//无数据、EmptyStackException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过此时的数据可以发现, 所有的数据保存之后将按照倒序的形式进行弹出, 如果栈已经空了, 则会抛出空栈异常.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-23-8220.png" alt="23"></p><h4 id="2-queue队列">2. Queue队列</h4><p>​Queue描述的是一个队列, 而队列的主要特点是实现先进先出的操作形式. 其基本的操作形式如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-24-8220.png" alt="24"></p><p>​如果将队列引用在多线程的 “生产者与消费者” 的模型处理上, 那么对于生产者过快生产过快的情况下,就没有必要等待消费者获取数据了, 可以将所有的内容直接保存在队列之中, 队列的实现可以使用LinkedList子类来完.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-25-8220.png" alt="25"></p><p>队列的使用主要依靠Queue接口之中提供的方法来处理. 提供有如下方法:</p><ul><li>向队列之中追加数据: public boolean offer(E e), 可以直接使用add()方法</li><li>通过队列获取数据: public E poll(), 弹出后删除数据</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-26-8220.png" alt="26"></p><p><strong>范例:</strong> 实现队列操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt; () ;</span><br><span class="line">queue.offer(<span class="string">"X"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"A"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"Z"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、X</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、A</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、Z</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​除了LinkedList子类之外, 还有一个优先级的概念, 可以使用PriorityQueue实现优先级队列(比较功能),</p><p><strong>范例:</strong> 使用优先级队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;String&gt; () ;</span><br><span class="line">queue.offer(<span class="string">"X"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"A"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"Z"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、X</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、A</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、Z</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​对于队列的选用原则也是需要根据实际的项目环境来决定的.</p><h4 id="3-properties属性操作">3. Properties属性操作</h4><p>​在之前讲解国际化程序的时候讲解过资源文件(*.properties), 那么这类文件的存储结构是按照 “key=value” 的, 而这种结构的保存形式与Map集合很相似, 但是唯一的区别在于其所保存的内容只能够是字符串, 所以为了可以方便的描述属性的定义, java.util包里面提供有Properties类型, 此类是Hashtable的子类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​可以发现在继承Hashtable的时候为Hashtable中定义的泛型为Object, Properties是不需要操作泛型的, 因为它可以操作类型只能是String类型. 在Properties之中如果要想实现属性的操作可以采用如下的方法来实现:</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">public Object setProperty(String key, String value)</td><td style="text-align:center">普通</td><td style="text-align:left">设置属性</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public String getProperty(String key)</td><td style="text-align:center">普通</td><td style="text-align:left">取得属性, key不存在返回null</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public String getProperty(String key, String defaultValue)</td><td style="text-align:center">普通</td><td style="text-align:left">取得属性, key不存在返回默认值</td></tr><tr><td style="text-align:center">04</td><td style="text-align:center">public void store(OutputStream out, String comments) throws IOException</td><td style="text-align:center">普通</td><td style="text-align:left">输出属性内容</td></tr><tr><td style="text-align:center">05</td><td style="text-align:center">public void load(InputStream inStream) throws IOException</td><td style="text-align:center">普通</td><td style="text-align:left">通过输入流读取属性内容</td></tr></tbody></table><p>范例: 观察属性的设置与取得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line"><span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"ngp"</span>));</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"sina"</span>,<span class="string">"Nofound"</span>));</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"sina"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过代码可以发现Properties里面可以像Map结婚那样进行内容的设置与获取, 但是唯一的差别是它只能够操作String类型, 另外需要注意的是, 之所以会提供有Properties类还有一个最重要的功能是它可以通过输出流输出属性, 也可以使用输入流读取属性内容.</p><p>范例: 将属性内容保存在文件之中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line"><span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"BeiJing"</span>,<span class="string">"北京"</span>);</span><br><span class="line">prop.store(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"info.properties"</span>)), <span class="string">"中文的注释看不见-english"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过程序的执行可以发现, 的确可以实现资源文件的输入处理, 但是如果输出的是中文则自动帮助用户进行转码处理.</p><p><strong>范例:</strong> 读取资源文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line"><span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"BeiJing"</span>,<span class="string">"北京"</span>);</span><br><span class="line">prop.load(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"info.properties"</span>)));</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"ngp"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​使用Properties类型的最大特点是可以进行资源内容的输入与输出的处理操作, 但是在实际的开发之中Properties往往用于读取配置资源的信息, 这一点主要是在标准设计之中做程序初始化准备的时候使用.</p><h4 id="4-collections工具类">4. Collections工具类</h4><p>​Collection是java提供的一组集合数据的操作工具类, 也就是说利用它可以实现各个集合的操作.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-27-8220.png" alt="27"></p><p><strong>范例:</strong> 使用Collection操作List集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong> 数据的反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">Collections.reverse(all);</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong>  使用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">Collections.sort(all);<span class="comment">// 先进行排序处理</span></span><br><span class="line">System.out.println(all);</span><br><span class="line">System.out.println(Collections.binarySearch(all,<span class="string">"NGP"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分情况下对于集合的使用可能没有这么多复杂要求, 更多的情况下就是利用集合保存数据, 要么进行输出要么进行查询.</p><p>面试题: 请解释Collection与Collections的区别?</p><ul><li>Collection是集合接口, 允许保存单值对象;</li><li>Collection是集合操作的工具类.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10桌面文件删除不掉的解决方案</title>
      <link href="/tech/e340017d.html"/>
      <url>/tech/e340017d.html</url>
      
        <content type="html"><![CDATA[<h3 id="win10桌面文件删除不掉的解决方案">Win10桌面文件删除不掉的解决方案</h3><p>在桌面新建一个txt文件，其中的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEL /F /A /Q \\?\%1</span><br><span class="line"></span><br><span class="line">RD /S /Q \\?\%1</span><br></pre></td></tr></table></figure><p>将txt文件改名为xxx.bat</p><p>将要删除的文件拖动到该bat文件中则删除成功</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot-学习中的错误解决</title>
      <link href="/tech/fb16a47d.html"/>
      <url>/tech/fb16a47d.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-error-could-not-open-c-programfiles-java-jre1-8-0-201-lib-amd64-jvm-cfg">1.Error: could not open `C:\ProgramFiles\Java\jre1.8.0_201\lib\amd64\jvm.cfg’</h4><p>将％JAVA_HOME％\ bin放在PATH的开头。</p><h4 id="2-error-8-2-java-找不到符号-符号-类-springbootapplication">2.Error:(8, 2) java: 找不到符号 符号: 类 SpringBootApplication</h4><p>导入一下 红字 SpringBootApplication 即可</p><p>or file → Invalidate Caches/Restart</p><h4 id="3">3.</h4>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-常用命令-镜像</title>
      <link href="/tech/8034adc7.html"/>
      <url>/tech/8034adc7.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h4 id="1-常用maven命令">1.常用maven命令</h4><p>①注意: 执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录。</p><p>与构建过程相关: 编译、测试、打包、…</p><p>②常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn clean              //清理</span><br><span class="line">mvn compile            //编译主程序</span><br><span class="line">mvn test-compole       //编译测试程序</span><br><span class="line">mvn test               //执行测试</span><br><span class="line">mvn package            //打包</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn install     //自己开发的Maven工程，用install安装进仓库</span><br><span class="line">mvn site        //生成站点</span><br></pre></td></tr></table></figure><h4 id="2-关于联网问题">2.关于联网问题</h4><p>①Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。</p><p>②当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。</p><p>③本地仓库的默认位置: [系统中当前用户的家目录]\.m2\repository</p><p><code>C:\Users\[系统中当前用户的家目录]\.m2\repository</code></p><p>④Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。(可设置aliyun镜像加速)</p><p>在 maven-3.X…/conf/setting.xml中的<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>中，添加以下代码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>ibiblio<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mirrors.ibiblio.org/pub/mirrors/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss-public-repository-group<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Public Repository Group<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.org/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 中央仓库在中国的镜像 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven.net.cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>oneof the central mirrors in china<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>⑤如果此时无法连接外网，则构建失败</p><p>⑥修改迷人本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件</p><blockquote><p>[1]找到Maven解压目录\conf\setting.xml</p><p>[2]在setting.xml文件中找到<code>LocalRepository标签</code></p><p>[3]将<code>&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code>从注释中取出</p><p>[4]将标签体内容修改为已经准备好的Maven仓库目录</p><p><code>&lt;localRepository&gt;D:\DevInstall\RepMaven&lt;/localRepository&gt;</code></p></blockquote><h4 id="3-pom">3.POM</h4><p>①含义: Project Object Model 项目对象模型</p><blockquote><p>DOM Document Object Model 文档对象模型</p></blockquote><p>②pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都是在这个文件中进行配置。</p><blockquote><p>重要程度相当于web.xml对于动态Web工程</p></blockquote><h4 id="4-坐标">4.坐标</h4><p>①数学中的坐标:</p><blockquote><p>[1]在平面上，使用X、Y两个向量可以唯一的定位平面中的任何一个点</p><p>[2]在空间中，使用X、Y、Z三个向量可以唯一的定位空间中的任何一个点’</p></blockquote><p>②Maven的坐标(GAV):</p><blockquote><p>使用下面三个向量在仓库中唯一定位一个Maven工程</p><p>[1]groupid: 公司或组织域名倒序+项目名</p><p><code>&lt;groupId&gt;com.ngp.maven&lt;/groupId&gt;</code></p><p>[2]artifactid: 模块名</p><p><code>&lt;artifactId&gt;Hello&lt;/artifactId&gt;</code></p><p>[3]version: 版本</p><p><code>&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</code></p></blockquote><p>③Maven工程的坐标与仓库中路径的对应关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar</span><br></pre></td></tr></table></figure><h4 id="5-仓库">5.仓库</h4><p>①仓库的分类</p><blockquote><p>[1]本地仓库: 当前电脑行部署的仓库目录，为当前电脑上所有的Maven工程服务</p><p>[2]远程仓库:</p><blockquote><p>(1)私服: 搭建在局域网环境中，为局域网范围内的所有Maven工程服务</p><p>(2)中央仓库: 假设在Internet上，为全世界所有Maven工程服务</p><p>(3)中央仓库镜像: 为了分担中央仓库的流量，提升用户访问速度</p></blockquote></blockquote><p>②仓库中的保存的内容: Maven工程</p><blockquote><p>[1]Maven自身所需要的插件</p><p>[2]第三方框架或工具的jar包</p><p>[3]我们自己开发的Maven工程</p></blockquote><h4 id="6-依赖-初步">6.依赖[初步]</h4><p>①Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。</p><blockquote><p>对于我们自己开发的Maven工程，使用install命令安装后就可以进入仓库。</p></blockquote><p>②依赖的范围</p><blockquote><p>[1]compile范围依赖</p><ul><li>对主程序是否有效:   有效</li><li>对测试程序是否有效: 有效</li><li>是否参与打包:       参与</li><li>是否参与部署:       参与</li><li>典型例子:    spring-core</li></ul><p>[2]test范围依赖</p><ul><li>对主程序是否有效:   无效</li><li>对测试程序是否有效: 有效</li><li>是否参与打包:       不参与</li><li>是否参与部署:       不参与</li><li>典型例子: junit</li></ul><p>[3]provided范围依赖(通常在web里面)</p><ul><li>对主程序是否有效:   有效</li><li>对测试程序是否有效: 有效</li><li>是否参与打包:       不参与</li><li>是否参与部署:       不参与</li><li>典型例子: servelet-api.jar</li></ul></blockquote><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-1-321.png" alt="1"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-2-321.png" alt="2"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-3-321.png" alt="3"></p><p>— 26节 ----</p><h4 id="7-依赖-高级">7.依赖[高级]</h4><p>①依赖的传递性</p><blockquote><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-4-321.png" alt="4"></p><p>[1]好处: 可以传递的依赖不必在每个模块工程中都重复声明，在 “最下面” 的工程中依赖一次即可。</p><p>[2]注意: 非compiled范围的依赖不能传递。(在这指的就是test、provided)所以在各个工程模块中，如果有需要就得重复声明依赖。</p></blockquote><p>②依赖的排除</p><blockquote><p>[1]需要设置依赖排除的场合</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-5-321.png" alt="5"></p><p>[2]依赖排除的设置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>③依赖的原则</p><blockquote><p>[1]作用: 解决模块工程质检的jar包冲突问题</p><p>[2]情景设定1: 验证路径最短者优先原则</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-6-321.png" alt="6"></p><p>[3]情景设定2: 验证路径相同时先声明者优先</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-7-321.png" alt="7"></p><p>先声明指的是dependency标签的声明顺序</p></blockquote><p>④统一管理依赖版本</p><blockquote><p>[1]情景举例</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-8-321.png" alt="8"></p><p>这里对Spring各个jar包的依赖版本都是4.0.0</p><p>如果需要同一升级为4.1.1，怎么办? 手动逐一修改不可靠。</p><p>[2]建议配置方式</p><blockquote><p>i. 使用properties标签内使用自定义标签统一声明版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt; &gt; <span class="tag">&lt;<span class="name">ngp.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">ngp.spring.version</span>&gt;</span></span><br><span class="line">&gt; &gt; <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>ii.在需要同一版本的位置，使用${自定义标签名}引用声明的版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;ngp.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>[3]其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号。(还可以配置UTF-8等)凡事需要统一声明后在引用的场合都可以使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">ngp.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">ngp.spring.version</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h4 id="8-继承">8.继承</h4><p>①现状</p><blockquote><p>Hello依赖的junit: 4.0</p><p>HelloFriend依赖的junit: 4.0</p><p>MakeFriends依赖的junit: 4.9</p><p>由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致</p></blockquote><p>②需求: 同一管理各个模块工程中对junit依赖的版本</p><p>③解决思路: 将junit依赖统一提取到 “父” 工程中，在子工程中声明junit依赖时不指定版本，以父工程中同一设定的为准。同时也便于修改。</p><p>④操作步骤</p><blockquote><p>[1]创建一个Maven工程作为父工程。注意: 打包的方式pom</p><p>[2]在子工程中声明对父工程的引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">&lt;!-- 子工程中声明对父工程的引用 --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ngp.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">verison</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">verison</span>&gt;</span></span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="comment">&lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路劲 --&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>[3]将子工程的坐标中与父工程左边中重复的内容删除</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-9-321.png" alt="9"></p><p>[4]在父工程中统一junit的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>[5]在子工程中删除junit依赖的版本号部分</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-10-321.png" alt="10"></p></blockquote><p>⑤注意: 配置继承后，执行安装命令时要先安装父工程。</p><h4 id="9-聚合">9.聚合</h4><p>①作用: 一键安装各个模块工程</p><p>②配置方式: 在一个 “总的聚合工程” 中配置各个参与聚合的模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置聚合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定各个子工程的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../HelloFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../MakeFriends<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③使用方式: 在聚合工程的pom.xml上点右键 → run as → maven install</p><p>从26节起，运行index.jsp的时候就运行不下去了、、没有 choose a … apache6.0的选项。。。之后的都是纯笔记，没有实操</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse-for-Springmvc</title>
      <link href="/tech/83478471.html"/>
      <url>/tech/83478471.html</url>
      
        <content type="html"><![CDATA[<p>一. 安装Java EE开发插件(即web插件，能添加Dynamic Web Project那种)</p><p>Help → Install New Software → Work With : <code>2018-12 - http://download.eclipse.org/releases/2018-12</code></p><blockquote><p>p.s. 因为我的Eclipse IDE的版本是2018-12</p></blockquote><p>展开 “Web, XML, Java EE and OSGi Enterprise Development” 选项，并且将下面三个选项打上勾：</p><ul><li><p>Eclipse Java EE Developer Tools</p></li><li><p>Eclipse Java Web Developer Tools</p></li><li><p>Eclipse Web Developer Tools</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\木有 =。= Eclipse XML Editors and Tools</span><br></pre></td></tr></table></figure><p>依次点击“Next ”知道你看到 “ Review licences”的窗口。在这个窗口选择 “I accept the terms of the licence agreement” 并且点击“Finish”。</p><p>二. 安装 apache tomcat6.0</p><p>1 window → preferences → Server → Runtime Environments → add → 里面没有apache</p><p>Help → Eclipse MarketPlace → 搜索JST Server → 安装</p><p>2 此部分转自: <a href="https://blog.csdn.net/jessysong/article/details/69364337">eclipse中配置Tomcat并启动服务器发布项目</a></p><blockquote><p>2.1 tomcat配置：</p><p>服务器 tomcat 6.0</p><p>下载apache-tomcat-6.0.43.tar.gz</p><p>直接解压即可使用，不用安装，解压到目录D:\</p><p>环境变量的配置与JDK一样，在环境变量中添加tomcat路径就好：</p><p>CATALINA_BASE=D:\apache-tomcat-6.0.43<br>CATALINA_HOME=D:\apache-tomcat-6.0.43</p><p>接下来在eclipse中配置tomcat:</p><p>添加新的Server运行时配置。点击Eclipse菜单，【Window】/【Preferences】，展开【Server】/【Runtime Environments】，</p><p>这样，tomcat就配置好了。</p><p>2.2 项目发布与tomcat启动</p><p>在开发和调试阶段Tomcat大多是在eclipse中以插件的形式运行的。eclipse中配置Tomcat过程如下;</p><p>step1:window → preferences → Server → Runtime Environments → add → apache 选择对应的版本</p><p>step2:点击Next，此时若电脑上已经安装了Tomcat，则选择安装路径即可；没有安装，则点击安装按钮</p><p>安装完毕后可以通过Window&gt;show view&gt;servers来显示服务器窗口，在这里就可以(在控制台右侧)看到刚才配置好的Tomcat服务器。</p><p>右键&gt;Start，在Console中可以看到Tomcat的启动信息，启动完毕，打开浏览器访问当前的项目，进入项目页面，配置完成。</p><p>tips：在eclipse中，Tomcat服务器可以同时发布多个项目：</p><p>选中服务器，右键 → Add and Remove 在弹出的对话框中，将需要同时启动的项目移至右面，点击确定就可以同时发布多个项目。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud 笔记</title>
      <link href="/tech/e91c9195.html"/>
      <url>/tech/e91c9195.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-基本知识点">一. 基本知识点:</h3><h5 id="1-微服务简介">1. 微服务简介</h5><p>微服务提倡将单一应用程序划分为一组微服务，每个服务运行在其自己独立的 <strong>进程</strong> 中。</p><h5 id="2-springcloud-与-dubbo">2. springcloud 与 dubbo</h5><p>springcloud 是基于RESTful</p><p>dubbo 是基于RPC</p><h5 id="3-微服务-与-微服务框架-与-springcloud-不是同一个东西">3. 微服务 与 微服务框架 与 springcloud 不是同一个东西</h5><blockquote><p>微服务:</p><p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看做Eclipse里面的一个个微服务工程/或者Module</p></blockquote><blockquote><p>微服务架构:</p><p><strong>微服务架构</strong>是一种架构模式，它提倡将单一应用程序划分为一组小的服务，服务之间互相协调、相互配合，为用户提供最终价值。每个服务运行在其<strong>独立的进程中</strong>，服务与服务间采用轻量级的通信机制相互协作(通常是基于HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，<strong>应当尽量避免统一的、集中式的服务管理机制</strong>，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p></blockquote><h5 id="4-springcloud和springboot是什么关系">4. SpringCloud和SpringBoot是什么关系</h5><p>SpringBoot专注于快速方便的开发当个个体微服务。</p><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p><p>SpringBoot可以离开SpringCloud独立使用开发项目，<strong>但是SpringCloud离不开SpringBoot</strong>，属于依赖的关系。</p><p><strong>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</strong></p><h5 id="5-书籍-以及-官方教程-在-视频13-3-50处">5. 书籍 以及 官方教程 在 视频13 3:50处</h5><h5 id="6">6.</h5><h5 id="n">n.</h5>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Everything 不显示UAC(用户账户控制)</title>
      <link href="/tech/bbf32a8e.html"/>
      <url>/tech/bbf32a8e.html</url>
      
        <content type="html"><![CDATA[<p>控制面板(Ctrl+Q输入control)  →   管理工具  →   任务计划程序  →   创建任务  →</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名称: Everything</span><br><span class="line">√ 使用最高权限</span><br></pre></td></tr></table></figure><p>操作  →   新建  →   浏览  →   找到本地Everything.exe  →   确定</p><p>条件  →   去掉 × 电源-只有在计算机使用交流电时才启动此任务</p><p>桌面  →   右键  →   新建  →   快捷方式  →</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /run /tn Everything    // ← Everything位置填你新建的任务名称</span><br></pre></td></tr></table></figure><p>…</p><p>ok</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> everything </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Google-SEO优化</title>
      <link href="/tech/99e58dd9.html"/>
      <url>/tech/99e58dd9.html</url>
      
        <content type="html"><![CDATA[<p>人搭建的博客在搜索引擎被收录的可能很小，SEO可以提高被搜到的几率</p><h3 id="一-生成-sitemap-文件">一. 生成 sitemap 文件</h3><p>需要先安装两个 hexo 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>打开配置文件<code>_config.yml</code>添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p>再重启 hexo，在本地访问 <a href="localhost:4000/sitemap.xml">localhost:4000/sitemap.xml</a>和 <a href="localhost:4000/baidusitemap.xml">localhost:4000/baidusitemap.xml</a> 就能正确的展示出两个sitemap 文件了。</p><h3 id="二-推送到-谷歌-和-百度">二. 推送到 谷歌 和 百度</h3><h4 id="1-百度-添加个人网站">1. 百度 → <a href="https://ziyuan.baidu.com/site/siteadd?siteurl=">添加个人网站</a></h4><p>添加文件方式不可行，hexo会处理html文件</p><p>所以选择，在 head.ejs 里添加 html 标签</p><p>1.1 <a href="https://ziyuan.baidu.com/linksubmit/index">手动提交baidusitemap.xml</a>(里面也有自动提交的代码)</p><p>1.2 可以用&quot;抓取诊断&quot;，手动-百度抓取</p><p>1.3 Robots → 检测并更新</p><p>诶 =。= 是比google方便诶</p><h4 id="2-谷歌-添加个人网站">2. 谷歌 → <a href="https://search.google.com/search-console/welcome">添加个人网站</a></h4><p>类似百度 ，也是在 head.ejs 里添加 html 标签</p><blockquote><p>验证通过就好，过两天左右 百度和谷歌就能收录你的站点</p><p>测试方式: (分别在 google 和 baidu 搜索)</p><p>site: tanghao.fun</p></blockquote><h5 id="2-1-手动提交sitemap-甚至是单个网站">2.1 手动提交sitemap，甚至是单个网站</h5><h5 id="googlesearchconsole-站点地图-输入sitemap-xml-提交"><a href="https://search.google.com/search-console">GoogleSearchConsole</a> → 站点地图 → 输入sitemap.xml → 提交</h5><h5 id="2-2-robots配置">2.2 robots配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /home/</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /about/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: http://yourname.github.io/sitemap.xml</span><br><span class="line">Sitemap: http://yourname.github.io/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>Allow表示允许被访问的，Disallow是不允许的意思。注意后面两个Sitemap就是网站地图了。而网站地图前面说了是给爬虫用的。这里配置在robots中。</p><h5 id="2-3-测试">2.3 测试</h5><p>旧版 GoogleSearchConsole 测试 robots.txt  是否配置好</p><p>新版 GoogleSearchConsole 测试 sitemap.xml 是否配置好</p><h3 id="三-定期清除死链接">三. 定期清除死链接</h3><p><a href="https://www.google.com/webmasters/tools/removals">https://www.google.com/webmasters/tools/removals</a></p><h3 id="参考">参考</h3><p><a href="http://www.dajipai.cc/archives/ec8af0f7.html">http://www.dajipai.cc/archives/ec8af0f7.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>$jsimple(Hexo) 经验</title>
      <link href="/tech/7cf41acb.html"/>
      <url>/tech/7cf41acb.html</url>
      
        <content type="html"><![CDATA[<p>常用 正则 替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ^#  →  ##</span><br><span class="line">2 D:\hexo\source\images\   →  https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/   //网络图片都是反斜杠&quot;/&quot;</span><br></pre></td></tr></table></figure><h3 id="error">error</h3><ol><li><p>‘hexo’ 不是内部或外部命令，也不是可运行的程序</p><p>把 <code>%hexo%\node_modules\.bin</code> 添加到环境变量path即(%hexo%替换为绝对路径)</p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsimple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java(高级编程)国际化程序实现-Java10</title>
      <link href="/tech/344c6ab0.html"/>
      <url>/tech/344c6ab0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-国际化程序简介">一. 国际化程序简介</h3><p>现在假设有一款全世界都认可的企业管理平台，那么这个企业的老板决定将这个产品推广到全世界各个大型上市公司，于是这些公司可以来自于: 中国、美国、德国，那么在这样的情况下，首先要考虑的问题是什么呢?</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-07-1-3625.png" alt="1"></p><p>通过分析之后可以发现，如果要想实现国际化程序开发，那么要解决的问题就在于以下两点:</p><ul><li>如何可以定义保存的文字的文件信息;</li><li>如何可以根据不同的区域语言的编码读取指定的资源信息。</li></ul><h3 id="二-locale类">二. Locale类</h3><p>通过分析可以发现，如果要想实现国际化，那么首先需要解决的就是不同国家用户的区域和语言编码问题，而在java.util包里面提供有一个专门描述区域和语言编码的类: Locale，而后主要可以使用Locale类中的两个构造方法进行实例化:</p><ul><li>public Locale(String language)</li><li>public Locale(String language,String country)</li></ul><p>此时需要的是国家和语言的代码，而中文的代码: zh_CN、美国英语的代码: en_US，对于这些区域和语言的编码最简单的获得方式就是通过IE浏览器。</p><p>工具 → Internet选项 → 语言</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-07-2-3625.png" alt="2"></p><p>范例: 实例化Locale类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Locale loc = <span class="keyword">new</span> Locale(<span class="string">"zh"</span>,<span class="string">"CN"</span>); <span class="comment">//中文环境</span></span><br><span class="line">System.out.println(loc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说现在要想自动获得当前的运行环境，那么现在就可以利用Locale类本身默认的方式进行实例化:</p><ul><li>读取本地默认环境: public static Locale getDefault(Locale.Category category)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Locale loc = Locale.getDefault(); <span class="comment">//获取默认环境</span></span><br><span class="line">System.out.println(loc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的开发过程之中，很多人可能并不关心国家和语言的编码，所以为了简化开发，Locale也将世界上一些比较著名的国家的编码设置为了常亮。详情见文档中Locale类的常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Locale loc = Locale.CHINA ;</span><br><span class="line">System.out.println(loc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用常量的优势在于可以避免一些区域编码信息的繁琐。</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Py 顺序下载Csdn网站图片</title>
      <link href="/tech/ef4318c7.html"/>
      <url>/tech/ef4318c7.html</url>
      
        <content type="html"><![CDATA[<script>    if("8264"==prompt("请输入文档密码"))    {        alert("密码正确");    }    else    {        alert("密码错误返回主页");        location="/";    }</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载完之后还需要删除不需要的图片，再用bat脚本(在最下方)批量重命名(按文件修改时间排序)，再TinyPNG无损压缩</span></span><br><span class="line">prefix=<span class="string">'2019-'</span>                    <span class="comment">#请设置一个前缀 #prefix(前缀) </span></span><br><span class="line">rootPicPath=<span class="string">"D:\\DDDDDDDDDDDownload"</span>   <span class="comment">#请设置图片保存的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个需要安装 requests ,bs4</span></span><br><span class="line"><span class="comment">#在cmd中输入</span></span><br><span class="line"><span class="comment">#python -m pip install requests</span></span><br><span class="line"><span class="comment">#python -m pip install bs4</span></span><br><span class="line"><span class="comment">#requests 可以改header,避免被识别为爬虫</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#同上</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#python自带</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="comment">#为了使用time.sleep()</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#禁用cookie防止被ban</span></span><br><span class="line">COOKIES_ENABLED=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(page_url,rootPicPath)</span>:</span> <span class="comment">#prefix 前缀</span></span><br><span class="line">    header = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36'</span>&#125;</span><br><span class="line">    html = requests.get(page_url,headers = header)</span><br><span class="line">    soup = BeautifulSoup(html.text,<span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="comment">#find_all 按 img标签 寻找</span></span><br><span class="line">    all_img = soup.find_all(<span class="string">'img'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#防止过快爬虫，导致被ban</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    n=<span class="number">1</span> <span class="comment">#图片起始序号</span></span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> all_img:</span><br><span class="line">        <span class="comment">#获取网络图片链接，设置图片名</span></span><br><span class="line">        picUrl = img.get(<span class="string">'src'</span>)</span><br><span class="line">        picName= str(prefix) + <span class="string">"-"</span> + str(n) + <span class="string">".jpg"</span></span><br><span class="line">        n+=<span class="number">1</span>            </span><br><span class="line">        <span class="comment">#生成本地图片名</span></span><br><span class="line">        picPath = rootPicPath + <span class="string">"\\"</span> + picName</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            urllib.request.urlretrieve(picUrl,picPath)</span><br><span class="line">            print(picName+<span class="string">"————下载完成"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            print(picName+<span class="string">"————————下载失败"</span>)</span><br><span class="line">            print()</span><br><span class="line">            print(<span class="string">'error: '</span>,err)</span><br><span class="line">            print()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#防止过快爬虫，导致被ban</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="comment"># 引入模块</span></span><br><span class="line">    <span class="comment">#os用于创建文件夹</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="comment"># 去除首位空格</span></span><br><span class="line">    path = path.strip()</span><br><span class="line">    <span class="comment"># 去除尾部 \ 符号</span></span><br><span class="line">    path = path.rstrip(<span class="string">"\\"</span>)</span><br><span class="line">    isExists = os.path.exists(path)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 判断结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主函数        </span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    url_list = [</span><br><span class="line"><span class="string">"https://blog.csdn.net/qq_35208390/article/details/86496498"</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">#创建文件夹</span></span><br><span class="line">    mkdir(rootPicPath)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> url_list:</span><br><span class="line">        download(link,rootPicPath)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># @echo off</span></span><br><span class="line"><span class="comment"># set a=000</span></span><br><span class="line"><span class="comment"># setlocal EnableDelayedExpansion</span></span><br><span class="line"><span class="comment"># #(2016*.*) 用前缀匹配</span></span><br><span class="line"><span class="comment"># #(*.jpg) 用后缀匹配 win不区分大小写</span></span><br><span class="line"><span class="comment"># #这个bat按【文件的修改时间】来【排序】【命名顺序】=。= 也就是对瞬间下载的没有效果</span></span><br><span class="line"><span class="comment"># # %random% 生成 0~65535 的随机数，但是一批修改的文件附加的随机数相同</span></span><br><span class="line"><span class="comment"># for %%n in (2019*.*) do (</span></span><br><span class="line"><span class="comment"># set /A a+=1</span></span><br><span class="line"><span class="comment"># ren "%%n" "2019-03-19-!a!-%random%.png"</span></span><br><span class="line"><span class="comment"># )</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bat 常用批处理脚本</title>
      <link href="/tech/299a95ba.html"/>
      <url>/tech/299a95ba.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-批量重命名-前缀匹配-后缀匹配-bat">一. 批量重命名[前缀匹配&amp;后缀匹配].bat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set a=000</span><br><span class="line">setlocal EnableDelayedExpansion</span><br><span class="line"><span class="meta">#</span>(2016*.*) 用前缀匹配</span><br><span class="line"><span class="meta">#</span>(*.jpg) 用后缀匹配 win不区分大小写</span><br><span class="line"><span class="meta">#</span>这个bat按【文件的修改时间】来【排序】【命名顺序】=。= 也就是对瞬间下载的没有效果</span><br><span class="line"><span class="meta">#</span> %random% 生成 0~65535 的随机数，但是一批修改的文件附加的随机数相同</span><br><span class="line">for %%n in (2019*.*) do (</span><br><span class="line">set /A a+=1</span><br><span class="line">ren "%%n" "2019-03-19-!a!-%random%.png"</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射机制</title>
      <link href="/tech/92291dc1.html"/>
      <url>/tech/92291dc1.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-反射机制简介">一. 反射机制简介</h3><blockquote><p>在Java语言里面之所以会有如此众多的开源技术的支撑，很大一部分是来自于Java最大的特征 —— 反射机制。</p><p>如果你现在不能够灵活去使用反射机制进行项目的开发和设计，那么可以说你并未接触到Java的精髓所在。</p><p>所有的技术实现的目标只有一点: 重用性。</p><p>对于反射技术首先考虑的是 “反” 与 “正” 的操作，所谓的 “正” 操作指的是当我们要使用一个类的时候，要先导入程序所在的包，而后根据类，进行对象的实例化，并且依靠对象调用类中的方法。但是如果说 “反” ，根据实例化对象反推出其类型。</p></blockquote><p>如果要想实现反的处理操作，那么首先要采用的就是 Object类 中所提供的的一个新的方法:</p><ul><li>获取Class对象信息: public final Class&lt;?&gt;getClass();</li></ul><p>范例: 观察Class对象的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Date; <span class="comment">//1. 导入对象所在的包，类，知道对象的出处了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAPIDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date() ;  <span class="comment">// 2. 通过类产生实例化对象</span></span><br><span class="line">        System.out.println(date.getClass()); <span class="comment">//3. 根据对象调用类中的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getClass()可以帮助使用者找到对象的根源。</p><h3 id="二-反射机制-class类对象的三种实例化模式">二. 反射机制（Class类对象的三种实例化模式）</h3><p><code>java.lang.Class</code>是一个类，这个类是反射操作的源头，即：所有的反射都要从此类开始，而最关键的是这个类有三种实例化方式：</p><ul><li><p>第一种:　调用Object类中的getClass()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;<span class="comment">//先有类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>第二种:　使用＂类.class＂取得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;<span class="comment">//先有类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;?&gt; cls = Date.class;</span><br><span class="line">System.out.println(cls);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前是在产生了类的实例化对象之后取得的Class类对象，但是此时并没有实例化对象的产生。</p></li><li><p>第三种： 调用Class类提供的一个方法</p><ul><li><p>-| 实例化Class对象: public static Class&lt;?&gt; forName(String name, boolean initialize,ClassLoader loader) throws ClassNotFoundException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">"java.util.Date"</span>);</span><br><span class="line">System.out.println(cls);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​此时可以不使用import语句导入一个明确的类，而类名称是采用字符串的形式进行描述的。</p><p>​初期： Class.forName用得最多</p><h3 id="三-反射机制-反射实例化对象">三. 反射机制（反射实例化对象）</h3><p>​当拿到一个类的时候，肯定要直接用关键字new进行对象的实例化操作，这属于习惯性的做法，但是如果有了Class类对象，那么就可以做到，利用反射来实现对象实例化操作：</p><ul><li>实例化对象方法：public T newInstance() throws InstantiationException, IllegalAccessException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"****Book类的无参构造方法****"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"这是一本书"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//Book b = new Book();</span></span><br><span class="line"><span class="comment">//System.out.println(b);</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">"cn.ngp.demo.Book"</span>);</span><br><span class="line">Object obj = cls.newInstance();<span class="comment">//相当于调用了无参构造实例化</span></span><br><span class="line">Book book = (Book)obj;</span><br><span class="line">System.out.println(book);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了反射之后，以后进行对象实例化的操作不在只是单独的依靠关键字new完成了，反射页也同样可以完成，但是这并不表示new就被完全取代了。</p><p>在任何的开发之中，new是造成耦合的最大元凶，一切的耦合都起源于new。</p><p><strong>范例：</strong> 观察工厂设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.test;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span>  <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"*** 吃苹果 ***"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"apple"</span>.equals(className)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Fruit f = Factory.getInstance(<span class="string">"apple"</span>);</span><br><span class="line">f.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果此时增加了Fruit借口子类，那么就表示程序要修改工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.test;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span>  <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"*** 吃苹果 ***"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span>  <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"*** 吃橘子 ***"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"apple"</span>.equals(className)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"orange"</span>.equals(className)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Orange();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Fruit f1 = Factory.getInstance(<span class="string">"apple"</span>);</span><br><span class="line">Fruit f2 = Factory.getInstance(<span class="string">"orange"</span>);</span><br><span class="line">f1.eat();</span><br><span class="line">f2.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每增加一个类就要去修改工厂类，那么如果随时都可能增加子类呢？工厂类要一直被修改。</p><p>因为现在工厂类中的对象都是通过关键字new直接实例化的，而new就成了所有问题的关键点，要想解决这一问题，我们就能够依靠反射完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.test;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span>  <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"*** 吃苹果 ***"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span>  <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"*** 吃橘子 ***"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">Fruit f = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">f = (Fruit) Class.forName(className).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Fruit f1 = Factory.getInstance(<span class="string">"cn.ngp.test.Apple"</span>);</span><br><span class="line">f1.eat();</span><br><span class="line">Fruit f2 = Factory.getInstance(<span class="string">"cn.ngp.test.Orange"</span>);</span><br><span class="line">f2.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的程序就真正完成了解耦和的目的，而且可扩展性非常的强。</p><h3 id="四-反射机制-调用构造方法">四. 反射机制（调用构造方法）</h3><p>​在之前</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射机制 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notepad++-插件-技巧</title>
      <link href="/tech/d8f350c3.html"/>
      <url>/tech/d8f350c3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-常用快捷键">一. 常用快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[Ctrl]+ G 跳到指定行</span><br><span class="line"></span><br><span class="line">[Ctrl]+ D 复制一行</span><br><span class="line">[Ctrl]+ L 剪切一行</span><br><span class="line"></span><br><span class="line">上移当前行 [Ctrl]+[ShiFt]+Up </span><br><span class="line">下移当前行 [Ctrl]+[ShiFt]+Down</span><br><span class="line"></span><br><span class="line">缩进 [Tab] </span><br><span class="line">删除缩进 [ShiFt]+[Tab] </span><br><span class="line"></span><br><span class="line">[Alt] + 0 折叠所有层次</span><br><span class="line">[Alt] +[ShiFt] + 0 展开所有层次</span><br><span class="line">[Alt] + F 折叠当前层次</span><br><span class="line">[Alt] +[ShiFt] + F 展开当前层次</span><br><span class="line"></span><br><span class="line">[Ctrl]+[ShiFt]+Q区块注释</span><br><span class="line">[Ctrl]+K行注释(取消 [Ctrl] + [ShiFt] + K)</span><br><span class="line"></span><br><span class="line">查找下一个 F3 </span><br><span class="line">查找上一个 Shift+F3 </span><br><span class="line">行定位 Ctrl+G </span><br><span class="line"></span><br><span class="line">[Ctrl]+ [ 跳到上一空行的下一行</span><br><span class="line">[Ctrl]+ ] 跳到下一空行的下一行</span><br></pre></td></tr></table></figure><h3 id="二-插件推荐">二. 插件推荐</h3><p>插件安装方式 ：最新版notepad++自带的插件管理</p><p>or 手动安装插件</p><p>把dll文件放到C:\Program Files (x86)\Notepad++\plugins</p><p>再notepad++ → 设置 → 导入 → 插件 → 选择该dll</p><h4 id="1-nppexec">1. NppExec →</h4><h5 id="1-1-notepad-如何编译-运行java">1.1. <a href="https://www.cnblogs.com/geek1116/p/5944228.html">Notepad++如何编译、运行Java</a></h5><blockquote><p>点Execute，在下面的文本域中输入下面命令参数（和cmd相似的代码）：<br><code>NPP_SAVE</code><br><code>javac &quot;$(FILE_NAME)&quot;</code><br><code>java &quot;$(NAME_PART)&quot;</code><br>点击save，给这个<code>编译命令</code>命名（例如: <code>Java_compiler&amp;run</code>），最后点OK。  在语言中选择好Java，再在文本域中编辑好自己的代码，按F6快捷键，点击OK，控制台出现代码运行的结果。</p></blockquote><p>p.s. 如果是包编译的话(<code>package cn.ngp.demo;</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npp_save</span><br><span class="line">cd   $(CURRENT_DIRECTORY)</span><br><span class="line">javac -d . &quot;$(FILE_NAME)&quot; -encoding utf-8</span><br><span class="line">java cn.ngp.demo.&quot;$(NAME_PART)&quot;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/radio/p/3189323.html">高级选项保存操作</a><br>一. 插件 → NppExec → advanced options<br>二. 在左下方Associated script选择上我们之前命名的<code>Java_compiler&amp;run</code>,然后在Item name取个名字（例如:<code>编译&amp;运行Java文件</code>），点Add/Modify，然后点OK<br>三. 配置快捷键    setting(设置) → shortcut mapper(管理快捷键) → plugin commands(插件命令) ，翻到最下面一行，找到<code>编译&amp;运行Java文件</code>，双击修改。(如果没有，重启一下Notepad++)<br>把<code>编译&amp;运行Java文件</code>对应快捷键设置为<code>Alt+R</code>，设置完成。</p></blockquote><h4 id="2-f5-自带插件">2. F5 (自带插件)→</h4><p><a href="https://blog.csdn.net/u013793399/article/details/51291017">如何用 Notepad++ 运行 Python 脚本(版本3.X)</a></p><p>notepad++ cmd 运行 python:</p><blockquote><ol><li>Notepad++ → &quot;运行&quot;菜单 → &quot;运行&quot;按钮<br><strong>或者</strong> Notepad++ → 按快捷键F5</li><li>在弹出的窗口内输入以下命令：<br>cmd /k python “$(FULL_CURRENT_PATH)” &amp; ECHO. &amp; PAUSE &amp; EXIT</li><li>按ok或者回车运行即可<br>p.s. 此时即可调用cmd运行python程序</li></ol></blockquote><h4 id="3-notepad-特殊技巧">3. notepad++ 特殊技巧</h4><p>各软件的命令行参数是各作者自己的设计，</p><p>不必照搬或试探，</p><p>你只需查阅各软件本身的帮助文档。</p><p>若是Notepad++：</p><p>打开[?]菜单 &gt;&gt; Command Line Arguments</p><p>或者 &gt;&gt; 帮助。</p><p>▲递归 用：-r</p><p>另外，</p><p>▲命令行普遍可以带路径，不必非得先转到某个路径。</p><p>▲cmd窗口支持拖放。拖入程序/文件，即转成路径文字。</p><p>▲命令行不必非得在cmd窗口中使用。[运行]、快捷方式、程序调用……</p><p>cmd输入 →</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">notepad++ * -r              //打开当前文件夹所有子文件, *表示当前目录下所有子文件</span><br><span class="line">notepad++ tag\source\   -r  //打开某source子文件夹下所有文件，-r表示递归，即打开文件的子文件</span><br><span class="line">notepad++ tag\source\ * -r  //则会打开 tag父文件夹 的 【所有子文件夹以及文件夹】</span><br></pre></td></tr></table></figure><h4 id="4-compare-文件比较插件">4. compare <strong>文件比较插件</strong></h4><p>4.1 打开要 <code>比较的文件</code> 的 <code>其中一个文件</code> 后，标记为 文件1 (两种方式) ：<br>① [Ctrl] + [Alt] + 1<br>② 打开文件后，按 “菜单栏“ 的 → <img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-30-compare1.png" alt="1"></p><p>4.2 打开要 <code>比较的文件</code> 的 <code>另一个文件</code> 后，开始比较 (两种方式)<br>① [Ctrl] + [Alt] + C<br>② 打开文件后，按 “菜单栏“ 的 → <img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-30-compare2.png" alt="1"></p><p>4.3 关闭比较(两种方式)</p><pre><code>① 关闭其中一个文件② 打开文件后，按 “菜单栏“ 的 → ![1](D:/blog/source/images/2019-03-30-compare3.png)</code></pre><h4 id="5-navigate-to-在打开的文件之中查找文件名">5. Navigate To 在打开的文件之中查找文件名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ctrl]+ , (跳转到没错就是逗号)</span><br></pre></td></tr></table></figure><h4 id="6-textfx-仅32位">6. TextFX(仅32位)</h4><p>Notepad<ins>插件TextFX  Characters是一款默认安装的插件，由于功能强大，被编程爱好者认为是最好的Notepad</ins>插件，</p><p>几个常用命令功能：</p><p>7.1 删除程序空行<br>选择相应的文本<br>点击TextFX —&gt; TextFX Edit —&gt; Delete Blank Lines<br>点击TextFX —&gt; TextFX Edit —&gt; Delete Surplus Blank Lines</p><p>7.2 为代码增加行号<br>选择要增加行号的文本(选择时会提示“No text selected”)<br>点击TextFX —&gt; TextFX Tools —&gt; Insert Line Numbers</p><p>7.3 删除程序行号或者首字<br>选择相应的文本<br>点击TextFX —&gt; TextFX Tools —&gt; Delete Line Numbers or First word</p><p>7.4 整理xml文本格式。<br>这个功能不错，可以很快将一行文本整理成规范的xml文件。(这个功能用来处理blogger的xml文档很不错，我自己的文档经过无数次的编辑已经乱得不成样子，经过这样一整理，可读性大大提高。)<br>选中所有文本<br>点击TextFX—&gt;HTML Tidy—&gt;Tidy: Reindent XML<br>同样在处理HTML文件，也有类似功能。</p><p>7.5 改变字符大小写<br>选择相应的文本<br>点击TextFX —&gt; TextFX Characters, 可以选择如下几种形式：<br>UPPER CASE 全部大写<br>lower case 全部小写<br>Proper Case 首字大写<br>Sentense case 句子模式<br>iNVERT cASE 首字小写，其他大写</p><p>7.6 去掉文本中的HTML元素<br>选择HTML元素<br>点击TextFX —&gt; TextFX Convert —&gt; Strip HTML tags table tabs</p><p>7.7 转换为HTML实体<br>即把“&lt;”转换成“&lt;”、把“&gt;”转换成 “&gt;”。（可以用来轻松为blogger的文章插入代码。）<br>选择相应的文本<br>点击TextFX —&gt; TextFX Convert —&gt; Encode HTML (&amp;&lt;&gt;&quot;)</p><h4 id="8-auto-save-每1分钟and切换别的程序时自动保存所有文档更改">8. Auto Save(每1分钟and切换别的程序时自动保存所有文档更改)</h4><h5 id="tips-ejs文件代码高亮">tips. <code>.ejs</code>文件代码高亮</h5><p>设置 → 语言格式设置 → 左边选择JavaScript(有两个) → 添加自定义扩展名 ejs  → 重新打开 notepad++ 几次 → ejs文件就会按照js高亮了</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> notepad++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse技巧</title>
      <link href="/tech/16d93d8b.html"/>
      <url>/tech/16d93d8b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>建议: 有时候 Eclipse生成的jar文件可能无法使用，所以最稳妥的做法是用jar命令(cmd)打包。</p></blockquote><h3 id="一-常用快捷键">一. 常用快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Alt  + / : 进行代码的提示（sysout、main）</span><br><span class="line">Ctrl + 1 : 为错误的代码给出纠正方案</span><br><span class="line">Ctrl + Shift + O : 组织导入，导入其他包的类</span><br><span class="line"></span><br><span class="line">Ctrl + / 单行/多行注释 → 使用&amp;取消</span><br><span class="line">Ctrl + H 强力搜索（告诉你哪个文件里有System）</span><br><span class="line"></span><br><span class="line">Alt + ↑/↓           快速移动行</span><br><span class="line">Ctrl + Alt + ↓      复制当前行的内容</span><br><span class="line">Ctrl + D            删除当前行代码</span><br><span class="line">Ctrl + Shift + L    全部快捷键列表</span><br><span class="line">Ctrl+Shift+F格式化当前代码</span><br><span class="line"></span><br><span class="line">Window → show views → ...  //恢复 部分view(控制台，文件管理器等)</span><br></pre></td></tr></table></figure><h3 id="二-debug调试">二. Debug调试</h3><p>Eclipse里面还提供有debug（代码的跟踪识别）功能</p><ol><li>设置断点 : 在需要设置的断点的那一行的&quot;行数&quot;上双击 出现蓝点（也就是&quot;断点&quot;）</li><li>进入调试模式 : 代码空白处，右键 → Debug As → Java Application</li><li>运行之后有三种调试模式:<ul><li>单步进入 【F5】 : 指的是进入到执行的方法之中观察方法的执行效果;</li><li>单步跳过 【F6】 : 在当前代码的表面上执行;</li><li>单步返回 【F7】 : 不再观察了。而返回到进入处;</li><li>恢复执行 【F8】 : 停止调试，而直接正常执行完毕。</li></ul></li></ol><h3 id="三-加入第三方程序包-jar包">三. 加入第三方程序包（jar包）</h3><p>SET CLASSPATH没用</p><blockquote><p>正确做法: 右键 项目 → Properties → Java Build Path → Libraries<br>→ Add External JARs → 找到你的jar文件</p></blockquote><h3 id="四-eclipse添加源码-鼠标移动到一个类上-按f3即可进入java源码">四. Eclipse添加源码(鼠标移动到一个类上，按F3即可进入java源码)</h3><p>源码文件一般在java安装目录下(src.zip)，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_201\//src.zip</span><br></pre></td></tr></table></figure><p>打开Eclipse，鼠标移动到一个类上，按F3</p><p>Attach Source → Extenal location → Extenal File → 找到这个src.zip → ok</p><h3 id="五-修改eclipse-jdk环境-的三种方法">五. 修改Eclipse JDK环境 的三种方法</h3><p>1 window → preferences → Java → Compiler → 选11/1.8/1.7/…</p><p>2 window → preferences → Java → Installed JREs → add  → standed VM → next → directory → 选择jdk文件夹</p><p>3 右键Eclipse资源管理器中的项目文件夹 → Build Path → Configure Build Path → remove旧jre版本，再Add Library → JRE System Library → next → 选择jre版本</p><h3 id="n-快捷键">N. 快捷键</h3><p><a href="http://www.runoob.com/eclipse/eclipse-shortcuts.html">Eclipse 快捷键</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>$jsimpe(Hexo) 进阶自定义</title>
      <link href="/tech/87486813.html"/>
      <url>/tech/87486813.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-hexo-push-源码的时候-把主题也提交上去">一. hexo push 源码的时候，把主题也提交上去</h3><p>因为我想高度自定义jsimple，所以我删除了子模块的功能，也就是push的时候提交主题。</p><ul><li>优点: 以后不用分别 push hexo源码 和 主题源码了</li><li>缺点: 以后jsimple更新就要手动更新了。听说子模块更新起来很方便</li></ul><blockquote><p>以后就用这个版本的jsimple了，要是到时候万一出了问题，我再下载作者的jsimple按照自己自定义的jsimple文件，再修改一次就好了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --stage | grep 160000</span><br><span class="line">git rm --cached themes/主题名字</span><br></pre></td></tr></table></figure><h3 id="二-置顶功能-安装">二. 置顶功能 安装</h3><ul><li>把 \hexo\themes\jsimple\patch 放到 hexo\ 下</li><li>运行 hexo\patch\<a href="http://run.sh">run.sh</a></li><li>运行hexo,就能看见效果</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell 解除系统对脚本的禁止</title>
      <link href="/tech/fd9f88e.html"/>
      <url>/tech/fd9f88e.html</url>
      
        <content type="html"><![CDATA[<p>功能&amp;外观&amp;便利&amp;稳定 : cmder &gt; PowerShell &gt; cmd</p><p>启动速度: cmd &gt; PowerShell &gt; cmder</p><h3 id="一-powershell-比cmd稳定-启动2s">一. PowerShell （比cmd稳定）（启动2s）</h3><h4 id="技巧1-windows直接在当前目录打开cmd命令行"><strong>技巧1 Windows直接在当前目录打开cmd命令行</strong></h4><p>​       **<strong>方法：在文件夹的空白处，使用 shift+鼠标右键 在弹出的菜单里面选择 在此处打开命令窗口 即可。</strong></p><h3 id="二-powershell-解除系统对脚本的禁止">二. PowerShell 解除系统对脚本的禁止</h3><blockquote><p>ERROR1：无法加载文件C:…因为在 统上禁止运行脚本。有关详细信息</p></blockquote><p>​    首次在计算机上启动 Windows PowerShell 时，现用执行策略很可能是 Restricted（默认设置）。Restricted 策略不允许任何脚本运行。</p><p>​    若要了解计算机上的现用执行策略，请键入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-executionpolicy</span></span><br></pre></td></tr></table></figure><p>​    若要在本地计算机上运行您编写的未签名脚本和来自其他用户的签名脚本，请使用以下命令将计算机上的，执行策略更改为 RemoteSigned：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> remotesigned</span><br></pre></td></tr></table></figure><blockquote><p>然后出现了主题似得，颜色好看了些，但出现了中文乱码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sample</title>
      <link href="/tech/f6a773f5.html"/>
      <url>/tech/f6a773f5.html</url>
      
        <content type="html"><![CDATA[<script>    if("8264"==prompt("请输入文档密码"))    {        alert("密码正确");    }    else    {        alert("密码错误返回主页");        location="/";    }</script><h3 id="一-生成sitemap站点地图">一. 生成sitemap站点地图</h3><blockquote><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p></blockquote><ol><li><p>安装插件</p><blockquote><p>在你hexo的根目录，执行下面两个命令来安装针对google和百度的插件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li><li><p>在站点根目录下的_config.yml添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># hexo sitemap网站地图</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line"></span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>现在在执行<code>hexo generate</code>的时候，在博客根目录下的public文件夹下面，就会生成sitemap.xml和baidusitemap.xml。</p></li></ol><h3 id="二-获取github接口的调用权限-获取token">二. 获取github接口的调用权限(获取token)</h3><p><a href="http://github.com">github.com</a> → 右上角 → Settings → Developer settings → Personal access tokens → Generate new token → 取个名字，勾选√repo → 复制token</p><h3 id="三-gitalk批量初始化">三. gitalk批量初始化</h3><ol><li>安装依赖包</li></ol><p>在你hexo的根目录，执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install request --save &amp;&amp;</span><br><span class="line">npm install xml-parser --save &amp;&amp;</span><br><span class="line">npm install yamljs --save &amp;&amp; </span><br><span class="line">npm install cheerio --save</span><br></pre></td></tr></table></figure><ol start="2"><li>创建脚本文件</li></ol><p>在站点根目录下创建comment.js文件，将下面的代码粘贴进文件中，然后修改config中的配置项，其中<code>token</code>就是上一步中获取的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">"request"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">const</span> xmlParser = <span class="built_in">require</span>(<span class="string">"xml-parser"</span>);</span><br><span class="line"><span class="keyword">const</span> YAML = <span class="built_in">require</span>(<span class="string">"yamljs"</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>);</span><br><span class="line"><span class="comment">// 根据自己的情况进行配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    username: <span class="string">"GitHub 用户名"</span>, <span class="comment">// GitHub 用户名</span></span><br><span class="line">    token: <span class="string">"GitHub Token"</span>,  <span class="comment">// GitHub Token</span></span><br><span class="line">    repo: <span class="string">"daihaoxin.github.io"</span>,  <span class="comment">// 存放 issues的git仓库</span></span><br><span class="line">    <span class="comment">// sitemap.xml的路径，commit.js放置在根目录下，无需修改，其他情况自行处理</span></span><br><span class="line">    sitemapUrl: path.resolve(__dirname, <span class="string">"./public/sitemap.xml"</span>),</span><br><span class="line">    kind: <span class="string">"Gitalk"</span>,  <span class="comment">// "Gitalk" or "Gitment"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> issuesUrl = <span class="string">`https://api.github.com/repos/<span class="subst">$&#123;config.username&#125;</span>/<span class="subst">$&#123;config.repo&#125;</span>/issues?access_token=<span class="subst">$&#123;config.token&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requestGetOpt = &#123;</span><br><span class="line">    url: <span class="string">`<span class="subst">$&#123;issuesUrl&#125;</span>&amp;page=1&amp;per_page=1000`</span>,</span><br><span class="line">    json: <span class="literal">true</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">"User-Agent"</span>: <span class="string">"github-user"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> requestPostOpt = &#123;</span><br><span class="line">    ...requestGetOpt,</span><br><span class="line">    url:issuesUrl,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    form: <span class="string">""</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"开始初始化评论..."</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始检索链接，请稍等..."</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> websiteConfig = YAML.parse(fs.readFileSync(path.resolve(__dirname, <span class="string">"./_config.yml"</span>), <span class="string">"utf8"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> urls = sitemapXmlReader(config.sitemapUrl);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`共检索到<span class="subst">$&#123;urls.length&#125;</span>个链接`</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"开始获取已经初始化的issues:"</span>);</span><br><span class="line">        <span class="keyword">let</span> issues = <span class="keyword">await</span> send(requestGetOpt);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`已经存在<span class="subst">$&#123;issues.length&#125;</span>个issues`</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> notInitIssueLinks = urls.filter(<span class="function">(<span class="params">link</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !issues.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">                link = removeProtocol(link);</span><br><span class="line">                <span class="keyword">return</span> item.body.includes(link);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (notInitIssueLinks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`本次有<span class="subst">$&#123;notInitIssueLinks.length&#125;</span>个链接需要初始化issue：`</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(notInitIssueLinks);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"开始提交初始化请求, 大约需要40秒..."</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 部署好网站后，直接执行start，新增文章并不会生成评论</span></span><br><span class="line"><span class="comment">             * 经测试，最少需要等待40秒，才可以正确生成， 怀疑跟github的api有关系，没有找到实锤</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            setTimeout(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">                <span class="keyword">let</span> initRet = <span class="keyword">await</span> notInitIssueLinks.map(<span class="keyword">async</span> (item) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> html = <span class="keyword">await</span> send(&#123; ...requestGetOpt, <span class="attr">url</span>: item &#125;);</span><br><span class="line">                    <span class="keyword">let</span> title = cheerio.load(html)(<span class="string">"title"</span>).text();</span><br><span class="line">                    <span class="keyword">let</span> pathLabel = url.parse(item).path;</span><br><span class="line">                    <span class="keyword">let</span> body = <span class="string">`<span class="subst">$&#123;item&#125;</span>&lt;br&gt;&lt;br&gt;<span class="subst">$&#123;websiteConfig.description&#125;</span>`</span>;</span><br><span class="line">                    <span class="keyword">let</span> form = <span class="built_in">JSON</span>.stringify(&#123; body, <span class="attr">labels</span>: [config.kind, pathLabel], title &#125;);</span><br><span class="line">                    <span class="keyword">return</span> send(&#123; ...requestPostOpt, form &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`已完成<span class="subst">$&#123;initRet.length&#125;</span>个！`</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"可以愉快的发表评论了！"</span>);</span><br><span class="line">            &#125;,<span class="number">40000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"本次发布无新增页面，无需初始化issue!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`初始化issue出错，错误如下：`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sitemapXmlReader</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = fs.readFileSync(file, <span class="string">"utf8"</span>);</span><br><span class="line">    <span class="keyword">let</span> sitemap = xmlParser(data);</span><br><span class="line">    <span class="keyword">return</span> sitemap.root.children.map(<span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> loc = url.children.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.name === <span class="string">"loc"</span>;</span><br><span class="line">        &#125;)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> loc.content;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeProtocol</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url.substr(url.indexOf(<span class="string">":"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        request(options, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                resolve(body);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行脚本</li></ol><blockquote><p>需要注意的是第一步中的sitemap插件会生成的sitemap.xml会包含<strong>全部的界面</strong>，包括标签页、关于页等，执行上面的代码也会对这些页面生成评论框(也就是issue)</p></blockquote><p>完成上述操作后，执行下面的命令，就可以部署站点，并初始化所有的评论了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp;</span><br><span class="line">hexo generate &amp;&amp;</span><br><span class="line">hexo deploy &amp;&amp;</span><br><span class="line">node ./comment.js</span><br></pre></td></tr></table></figure><p>也可以通过在站点根目录的package.json文件中，新建npm脚本，一个命令搞定清除缓存、生成静态文件、提交git并生成issue的所有操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"hexo clean &amp;&amp; hexo s"</span>,</span><br><span class="line">    <span class="string">"deploy"</span>: <span class="string">"hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; node ./comment.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>完成文章编写，或者其他的更新操作后，直接执行deploy即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sample </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-简单密码</title>
      <link href="/tech/f6a773f5.html"/>
      <url>/tech/f6a773f5.html</url>
      
        <content type="html"><![CDATA[<p>把一下这段加到文章中去，建议在 more 之后:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"987654312"</span>==prompt(<span class="string">"请输入文档密码"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        alert(<span class="string">"密码正确"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        alert(<span class="string">"密码错误返回主页"</span>);</span><br><span class="line">        location=<span class="string">"/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-代码复制</title>
      <link href="/tech/c148c37.html"/>
      <url>/tech/c148c37.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-下载第三方插件clipboard-js">一.下载第三方插件clipboard.js</h3><p><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.js">clipboard.js</a><br><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js">clipboard.min.js</a> (推荐)<br>保存到 themes/hexo-theme-xxxx/source/js/ 下</p><h3 id="二-创建js文件">二. 创建js文件</h3><p>创建clipboard-use.js 和 clipboard.min.js 保存到 themes/hexo-theme-xxxx/source/js/ 下，其内容如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*页面载入完成后，创建复制按钮*/</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123; </span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copyHtml = <span class="string">''</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'  &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">        target: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><h3 id="三-修改-footer-ejs">三. 修改 footer.ejs</h3><p>hexo\themes\jsimple\layout_partial\footer.ejs</p><p>在末尾添加,注意一定先添加 clipboard.min ，另外后面不带.js后缀</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- js(<span class="string">'js/clipboard.min'</span>) %&gt;</span><br><span class="line">&lt;%- js(<span class="string">'js/clipboard-use'</span>) %&gt;</span><br></pre></td></tr></table></figure><h3 id="四-添加css样式">四. 添加css样式</h3><p>he  xo\themes\jsimple\source\css\JSimple.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">copy</span><span class="selector-class">.highlight</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#fcfcfc,#eee);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">-o-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-copy</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己微调的css样式:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#fcfcfc, #eee);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#d5d5d5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">-o-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-参考">五. 参考</h3><p><a href="http://wushuning.com/2018/10/19/hexo%E7%BB%93%E5%90%88gitpage%E6%90%AD%E5%BB%BA%E6%97%A0%E9%99%90%E7%A9%BA%E9%97%B4%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/index.html">hexo结合gitpage搭建无限空间静态博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk-安装</title>
      <link href="/tech/72be7dab.html"/>
      <url>/tech/72be7dab.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-获得-clientid-和-clientsecret">一. 获得 clientID 和 clientSecret</h3><p>由于需要调用 Github API ,首先<a href="https://github.com/settings/applications/new">点击注册</a>一个 Github Application 。</p><p>callback URL 填博客主页</p><h3 id="二-设置-hexo-themes-jsimple-config-yml">二. 设置 hexo\themes\jsimple_config.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  disqus_shortname:</span> </span><br><span class="line"><span class="attr">  gitment:</span>  </span><br><span class="line"><span class="attr">    repo:</span>  </span><br><span class="line"><span class="attr">    githubID:</span> </span><br><span class="line"><span class="attr">    ClientID:</span> </span><br><span class="line"><span class="attr">    ClientSecret:</span> </span><br><span class="line"><span class="attr">    lazy:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  gitalk:</span></span><br><span class="line"><span class="attr">    on:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    owner:</span> <span class="string">ngp320</span></span><br><span class="line"><span class="attr">    repo:</span> <span class="string">gitalk-comment</span></span><br><span class="line"><span class="attr">    admin:</span> <span class="string">['ngp320']</span></span><br><span class="line"><span class="attr">    clientID:</span> <span class="string">xxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="attr">    clientSecret:</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="attr">    pagerDirection:</span> <span class="string">first</span> <span class="comment">#这个默认就好了，是指评论排序方式。</span></span><br></pre></td></tr></table></figure><h3 id="三-进入一下-你的博客主页-github登陆授权一下">三. 进入一下 你的博客主页 ，github登陆授权一下</h3><p>没了 =。= wo kao 10分钟解决? 比gitment简单12~24小时</p><h3 id="四-gitalk-css-样式-与主题原来的样式冲突">四. gitalk.css 样式 与主题原来的样式冲突</h3><ol><li>注释引入的 gitalk.css</li><li>下载 gitalk.css，删去markdown部分L5~582，重命名为 gitalk_without_markdown_style.css</li><li>再从代码中引入本地的 gitalk_without_markdown_style.css</li><li>这样 markdown部分就不会互相干扰了 =。=  完美</li></ol>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitalk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>$Git Error记录</title>
      <link href="/tech/6941e1ba.html"/>
      <url>/tech/6941e1ba.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-ssh-could-not-resolve-hostname-github-name-or-service-not-known">1. ssh: Could not resolve hostname github: Name or service not known</h4><p>ssh: Could not resolve hostname github: Name or service not known<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.</p><p>一般是</p><p>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:GitHub用户名/新建的仓库的英文名.git</p><p>哪里没写对的锅</p><h3 id="二-error-failed-to-push-some-refs-to-git-github-com-ngp320-hexo-jsimple-src-git">二. error: failed to push some refs to ‘git@github.com:ngp320/hexo-jsimple-src.git’</h3><p>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details.<br>npm ERR! code ELIFECYCLE</p><p>原因: 在不同的机器上上做了提交？？  (或者把本地分支提交的记录删除了)</p><blockquote><p>远程分支上存在本地分支中不存在的提交，往往是多人协作开发过程中遇到的问题，可以先<code>fetch</code>再<code>merge</code>，也就是<code>pull</code>，把远程分支上的提交合并到本地分支之后再<code>push</code>。</p></blockquote><p>解决:</p><p>如果你确定远程分支上那些提交都不需要了，那么直接<code>git push origin master -f</code>，强行让本地分支覆盖远程分支。。。</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 不常用命令</title>
      <link href="/tech/ac1a5db9.html"/>
      <url>/tech/ac1a5db9.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git初始化:</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">取消远程库关联</span><br><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令</title>
      <link href="/tech/b4973c45.html"/>
      <url>/tech/b4973c45.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-分支">一. 分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建dev分支，并切换到dev分支(等同于git branch dev &amp;&amp; git checkout dev)：</span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看本地分支 [-a]本地和远程 [-r]远程   默认是,本地所有分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>提交本地分支到远程分支(dev有文件的前提下)</span><br><span class="line">git checkout dev</span><br><span class="line">git add .</span><br><span class="line">git commit -m "branch push test"</span><br><span class="line"><span class="meta">#</span>把本地的dev push 到远程 dev, :左右的名字可更改. 默认值为 master:master</span><br><span class="line">git push origin dev:dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>合并本地分支 dev 2 master</span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>删除本地分支</span><br><span class="line">git branch -d dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>删除远程分支</span><br><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>$Git SS加速</title>
      <link href="/tech/95966ba6.html"/>
      <url>/tech/95966ba6.html</url>
      
        <content type="html"><![CDATA[<h5 id="1-首先-本地挂好代理工具-不多说-默认情况下端口是-1080">1. 首先，本地挂好代理工具，不多说。默认情况下端口是 <code>1080</code>。</h5><h5 id="2-在-git-命令行输入以下配置全局代理：">2. 在 <code>Git</code> 命令行输入以下配置全局代理：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//127.0.0.1指的是本地，1080指的是代理工具设置的端口</span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><h5 id="3-使用以下命令查看是否配置好">3. 使用以下命令查看是否配置好</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global -e</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Vim代码</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">:wq</td><td style="text-align:center">保存并退出</td></tr><tr><td style="text-align:center">q:</td><td style="text-align:center">不保存，退出</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">不保存，强制退出vim</td></tr></tbody></table><p>打开后有如下所示，即配置成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[http]  proxy = sock5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><h5 id="4-使用-https-形式进行-git-clone-下载-例如：">4. 使用 <code>https</code> 形式进行 <code>git clone</code> 下载，例如：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/xxx/xxxxx.git</span><br></pre></td></tr></table></figure><h5 id="5-https的方式git每次都要输入密码-按照如下设置即可输入一次就不用再手输入密码的困扰而且又享受https带来的极速">5. https的方式Git每次都要输入密码，按照如下设置即可输入一次就不用再手输入密码的困扰而且又享受https带来的极速:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">设置记住密码（默认15分钟）：</span><br><span class="line">git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line">如果想自己设置时间，可以这样做：</span><br><span class="line">git config credential.helper 'cache --timeout=259200'      //--timeout=3600 1个小时</span><br><span class="line">这样就设置三天之后失效</span><br><span class="line"></span><br><span class="line">长期存储密码【1】：(重装git，改密码也存在。)</span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line">删掉git config --global credential.helper store保存的账号和密码【1】</span><br><span class="line">rm ~/.git-credentials</span><br><span class="line"></span><br><span class="line">增加远程地址的时候带上密码也是可以的。(推荐) (好像不能用 2019-04-16 21:35:01)</span><br><span class="line">http://yourname:password@git.oschina.net/name/project.git</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git config --global credential.helper store该命令可以将用户名和密码长期全局地长期地存储在客户端（实际是客户端所在电脑，并非git的任何目录下，也就是说，即使重装git，改密码也存在。），注意是全局地。</span><br><span class="line">&gt; 原作者不推荐的原因正是这个。因为，这里保存的账号和密码会自动应用到每一个git clone指令，如果想要克隆的不是该账号下的项目，就只会得到403错误。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="6-取消代理使用命令：">6. 取消代理使用命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy1(好像，不知道怎么换回ssh了。。。=。=，改天再弄)</span><br></pre></td></tr></table></figure><p>使用此命令取消，再次使用第四条查看会看到有残留的 <code>[http]</code>，可以手动删除掉。</p><p>备份自： <a href="https://blog.csdn.net/curioust/article/details/81291699">Git 配置 SS 代理， 加速 git clone</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git_Hexo源码备份到单独的库</title>
      <link href="/tech/9846314.html"/>
      <url>/tech/9846314.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>先在GitHub上新建一个库</p></li><li><p>在本地初始化仓库(需要git),如果已经有仓库，跳到下一步</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ol start="3"><li>添加远程库(需要先配置ssh key)(大概这个意思)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:GitHub用户名/新建的仓库的英文名.git</span><br><span class="line">例如: ↓</span><br><span class="line">git remote add origin git@github.com:ngp320/Hexo_src.git(推荐)</span><br><span class="line">如果 origin已存在，也就是已经连接了一个库，可以改为: ↓</span><br><span class="line">git remote add hs_origin git@github.com:ngp320/Hexo_src.git</span><br></pre></td></tr></table></figure><p><code>hexo d</code> 默认关联 <code>***.github.io</code></p><ol start="4"><li>第一次推送</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。(-u表示默认推送的库？)</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>$Npm提高下载速度,替换国内镜像</title>
      <link href="/tech/d253e92c.html"/>
      <url>/tech/d253e92c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>npm install的速度慢，还经常安装失败，换成国内镜像后确实快了好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多好多。</p></blockquote><blockquote><p>国内镜像：<br>cnpm镜像地址：<a href="http://registry.cnpmjs.org/">http://registry.cnpmjs.org</a><br>淘宝镜像地址：<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></blockquote><h3 id="一-直接修改镜像地址-设置镜像方法之一-：">一. 直接修改镜像地址（设置镜像方法之一）：</h3><p><strong>直接设置镜像有3种方法：</strong></p><p>1.npm config set key value 命令，设置指定的镜像地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org </span><br><span class="line">npm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息）</span><br></pre></td></tr></table></figure><p>2.npm --registry命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org info underscore （npm info underscore依然是为了检验是否设置成功）</span><br></pre></td></tr></table></figure><p>3.修改配置文件~/.npmrc （win系统在C:\Users\用户名.npmrc） 加入下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>其实1,2，3都是修改npm的配置文件.npmrc .</p><h3 id="二-用封装好的cnpm命令-设置镜像方法之二">二. 用封装好的<code>cnpm</code>命令（设置镜像方法之二）</h3><p>如果觉得直接修改比较麻烦的话，就用<code>cnpm</code>命令吧，先用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装cnpm包，然后就可以敲<code>cnpm install [name]</code>命令了，很方便~~</p><p>如果网络状况不好，或者觉得npm install慢的可以换成国内的镜像试下~~~</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> nodejs </tag>
            
            <tag> 让npm起飞的国内镜像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/tech/784dd132.html"/>
      <url>/tech/784dd132.html</url>
      
        <content type="html"><![CDATA[<p><img src="..https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/husky.png" alt="img"></p><p>test 2019-04-07 15:14:5</p><h4 id="1-代码条">1. <code>代码条</code> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h4><blockquote><p>p 段   <code>p段内嵌代码条</code></p></blockquote><ul><li>t1</li><li>t2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">bbbbbbbb</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccccccccccc</span><br></pre></td></tr></table></figure><h4 id="2-123">2. 123</h4><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th></tr></thead><tbody><tr><td style="text-align:center"><code>11</code></td><td style="text-align:center">12</td><td style="text-align:center">13</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">22</td><td style="text-align:center">23</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">31</td><td style="text-align:center">32</td><td style="text-align:center">33</td><td style="text-align:center">34</td></tr><tr><td style="text-align:center">41</td><td style="text-align:center">42</td><td style="text-align:center">43</td><td style="text-align:center">44</td></tr></tbody></table><p>test n2019-04-16 21:04:34</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1"  class="footnote-item"><p><a href="tanghao.fun">1.主页</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> main </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo) TOC目录</title>
      <link href="/tech/859f5cdc.html"/>
      <url>/tech/859f5cdc.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-修改post-ejs文件">一. 修改post.ejs文件</h3><blockquote><p>不同的主题位置不一，Ctrl+f 找post.content ,应该就能找到。</p><p>notepad<ins>批量打开文件见：Notepad</ins> 插件&amp;技巧&amp;特殊技巧</p></blockquote><p>在文件中添加如下代码至<code>&lt;%- post.content %&gt;</code>之前。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Table <span class="keyword">of</span> Contents begin--&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span>(post.toc == <span class="literal">true</span>)&#123; %&gt;</span><br><span class="line">    &lt;div id=<span class="string">"toc"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"toc-article"</span>&gt;</span><br><span class="line">        &lt;strong <span class="class"><span class="keyword">class</span></span>=<span class="string">"toc-title"</span>&gt;目录&lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">        &lt;%- toc(post.content,&#123;list_number:false&#125;) %&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;!--Table <span class="keyword">of</span> Contents end --&gt;</span><br></pre></td></tr></table></figure><h3 id="二-在对应-css或-tyle文件中增加样式">二. 在对应<code>.css</code>或<code>.tyle</code>文件中增加样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*toc*/</span></span><br><span class="line"><span class="selector-class">.toc-article</span> &#123;</span><br><span class="line">  background #eee;</span><br><span class="line">  <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#bbb</span>;</span><br><span class="line">  <span class="selector-tag">border-radius</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">margin</span>: 1<span class="selector-class">.5em</span> 0 0<span class="selector-class">.3em</span> 1<span class="selector-class">.5em</span>;</span><br><span class="line">  <span class="selector-tag">padding</span>: 1<span class="selector-class">.2em</span> 1<span class="selector-tag">em</span> 0 1<span class="selector-tag">em</span>;</span><br><span class="line">  <span class="selector-tag">max-width</span>: 28%</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.toc-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">120%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#toc</span> &#123;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line"><span class="attribute">float</span>: right</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.toc</span> &#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.8em</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 增加无序列表的小圆点 还要修改上面第6行 li包括ol和ul,所以把li改为ol即可,toc的锅也是没想到*/</span> </span><br><span class="line"><span class="comment">/* 原版: li&#123; */</span></span><br><span class="line"><span class="selector-tag">ol</span>&#123;</span><br><span class="line"><span class="attribute">list-style-type</span>: none</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.toc-child</span> &#123;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">1em</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-在文章中添加-toc-true">三. 在文章中添加 <code>toc: true</code></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">sample</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">sample</span></span><br><span class="line"><span class="attr">name:</span> <span class="number">97</span><span class="string">年的顽石</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>运行一下，完</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsimple </tag>
            
            <tag> toc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo) 永久Url</title>
      <link href="/tech/9eeee2c3.html"/>
      <url>/tech/9eeee2c3.html</url>
      
        <content type="html"><![CDATA[<p>使用hexo-abbrlink这个插件，abbrlink根据算法+时间算出，并在文章中加入 <code>abbrlink字段</code>,后期不管怎么修改标题，只要不修改这个 <code>date字段</code>，永久链接都不会变.<br>以后不用考虑分类中文化的问题。而且后面的层级更短，更利于SEO。(一般SEO只爬三层)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>站点配置文件里:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#permalink: :category/:title.html </span></span><br><span class="line"><span class="comment">#permalink: post/:abbrlink.html</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"><span class="attr">  alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line"><span class="attr">  rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitbook 安装&amp;使用</title>
      <link href="/tech/a083481.html"/>
      <url>/tech/a083481.html</url>
      
        <content type="html"><![CDATA[<p>lalallaaaaaaaaa</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo) 简单插件</title>
      <link href="/tech/d2463eb7.html"/>
      <url>/tech/d2463eb7.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-数据分析">一. 数据分析</h3><p><a href="https://analytics.google.com/">谷歌分析</a></p><h3 id="二-hexo-更换markdown渲染-支持emoji插件">二. Hexo 更换markdown渲染+支持emoji插件</h3><h4 id="1-命令行安装-powershell-cmder-cmd">1. 命令行安装（powershell/cmder/cmd）</h4><p>很简单，换一个 markdown 引擎，然后再增加 emoji 插件即可。😊</p><p>(以下三行得分开执行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save </span><br><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure><p>据说 <a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a> 的速度要比 Hexo 原装插件要快，而且功能更多：</p><blockquote><p>Main Features</p><ul><li>Support for <a href="https://daringfireball.net/projects/markdown/">Markdown</a>, <a href="https://help.github.com/articles/github-flavored-markdown/">GFM</a> and <a href="http://commonmark.org/">CommonMark</a></li><li>Extensive configuration</li><li>Faster than the default renderer | <code>hexo-renderer-marked</code></li><li>Safe ID for headings</li><li>Anchors for headings with ID</li><li>Footnotes</li><li><code>&lt;sub&gt;</code> H2O</li><li><code>&lt;sup&gt;</code> x2</li><li><code>&lt;ins&gt;</code> Inserted</li></ul></blockquote><p>然后编辑 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line"><span class="attr">  plugins:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">markdown-it-footnote</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">markdown-it-sup</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">markdown-it-sub</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">markdown-it-abbr</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">markdown-it-emoji</span></span><br></pre></td></tr></table></figure><h4 id="2-使用方法">2. 使用方法</h4><h5 id="markdown">markdown</h5><ol><li>markdown的脚标能用了</li></ol><h5 id="emoji">emoji</h5><ol><li><p>在 <a href="https://emoji.codes/">Emoji</a> 中找到你想要的表情，然后点击即可复制。</p></li><li><p>比如你想发一个笑脸 😄 直接输入笑脸对应的 emoji 编码 <code>:smile:</code> 就可以。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsimple简单插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mactype配置</title>
      <link href="/tech/c2be46c6.html"/>
      <url>/tech/c2be46c6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-初步配置">一. 初步配置</h3><p>下载安装 → Mactype用户向导 → default字体</p><h3 id="二-进阶">二. 进阶</h3><p>无。。。好像就到这了。也足够日常使用了</p><p>tes 2019-04-02 13:03:29</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mactype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo) 滑动条</title>
      <link href="/tech/9588cfbb.html"/>
      <url>/tech/9588cfbb.html</url>
      
        <content type="html"><![CDATA[<p>2019-04-01_</p><p>test 2019-04-02 11:41:44</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsimple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo) 思源宋体</title>
      <link href="/tech/6fb06931.html"/>
      <url>/tech/6fb06931.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-打开-google-font-找到-思源宋体-noto-serif-sc">一. 打开 Google Font 找到 思源宋体( Noto Serif SC)</h3><blockquote><p>Google Font ：<a href="https://fonts.google.com/">https://fonts.google.com/</a></p></blockquote><ul><li>找到 思源宋体 → 搜索 Noto Serif SC → 点击字体</li><li>点击 select this font → 点击 Family select</li></ul><h3 id="二-跟随官方教程-配置字体">二. 跟随官方教程，配置字体</h3><h4 id="1-在head部分加入一串-link-样式-引入google字库">1. 在head部分加入一串 link 样式，引入Google字库</h4><p>在 head 文件 中添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://fonts.googleapis.com/css?family=Noto+Serif+SC"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-修改-css文件">2. 修改 <code>.css文件</code></h4><blockquote><p>全局设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; * &#123; <span class="attribute">font-family</span>: <span class="string">'Noto Serif SC'</span>, serif; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>*</code> 表示匹配一切，也就是全局字体</p><p>(也可以部分设置,Ctrl+f font-family 一个个设置就好了)</p><p>格式： a { font-family: ‘Noto Serif SC’, serif; }  等等</p></blockquote><p>现在运行，应该就能看到效果了</p><h3 id="3-测试自己的博客-并不影响加载速度">3. 测试自己的博客，并不影响加载速度</h3><blockquote><p>用手机热点：</p><p>清空缓存数据，加载到可以点开博客 12-20s ,加载出所有图片60s 左右</p><p>用Google Font，好像还迷之快一点的感觉</p></blockquote><blockquote><p>正常网络(500kb/s最大速度)：</p><p>加载到可以点开博客 5-10s ,加载出所有图片20s 左右</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> jsimple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 安装与简单设置</title>
      <link href="/tech/17d4b477.html"/>
      <url>/tech/17d4b477.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-安装">一. 安装</h3><ul><li><p>下载 <code>node.js</code> 并安装（官网下载安装），默认会安装 <code>npm</code></p></li><li><p>下载安装 <code>git</code>（官网下载安装）</p></li><li><p>下载安装 <code>hexo</code>  方法：打开 <code>cmd</code> 运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo  #fan墙会快很多</span><br></pre></td></tr></table></figure></li></ul><h3 id="二-更换主题">二. 更换主题</h3><ol><li>把主题下载解压到themes</li><li>修改 <code>hexo\_config.yml</code> 的 <code>theme: XXX</code></li></ol><h3 id="三-创建标签-分类-头像">三. 创建标签、分类、头像</h3><h4 id="1-创建标签">1. 创建标签</h4><p>(1) 运行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>同时，在/source目录下会生成一个tags文件夹，里面包含一个<code>index.md</code>文件</p><p>(2) 改/source/tags目录下的<code>index.md</code>文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: <span class="number">2015</span>-<span class="number">09</span>-<span class="number">29</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">02</span></span><br><span class="line">type: <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><p>(3) 修改<strong>主题配置文件</strong> <code>hexo\_config.yml</code><br>去掉tags的注释</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /                       #主页</span><br><span class="line">  categories: /categories       #分类页（需手动创建）</span><br><span class="line">  #about: /about                #关于页面（需手动创建）</span><br><span class="line">  archives: /archives           #归档页</span><br><span class="line">  tags: /tags                   #标签页（需手动创建）</span><br><span class="line">  #commonweal: /404.html        #公益 404 （需手动创建）</span><br></pre></td></tr></table></figure><h4 id="2-分类页面-同上-不同之处仅仅是-tags-改为-categories-而已">2. 分类页面(同上，不同之处仅仅是“tags”改为“categories”而已)</h4><h4 id="3-侧边栏头像设置">3. 侧边栏头像设置</h4><h3 id="四-图片插入处理">四. 图片插入处理</h3><p>​同一放在 <code>hexo\source\images</code> 下，按日期备份</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo源码 备份到分支</title>
      <link href="/tech/e005c70.html"/>
      <url>/tech/e005c70.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-手动-回滚">一. 手动 回滚</h3><ol><li><p>把github上的【<a href="http://yourName.github.io">yourName.github.io</a>】，下载zip到本机，</p></li><li><p>把【[1]本地hexo博客文件夹】+【[2]主题文件(e.g jsimple)(哪怕是重大破损的)】+【[3]_post文章存放的文件夹】 关掉运行的终端，压缩分别压缩一遍，打上日期，放到桌面，(如果没有重大破损的话)再复制一份到自己的hexo本地备份文件夹。</p><p>（尤其是主题，如果常修改主题的话，记得定期备份主题）</p><p>（请务必压缩已经弄坏的主题，复制出来，因为，不知道距离上一次改了多少了， ╥﹏╥…）</p></li><li><p>删除 【本地hexo博客文件夹】</p></li><li><p>把下载的【<a href="http://yourName.github.io">yourName.github.io</a>】(通常是完好的)，解压，放入清空的文件夹</p></li><li><p>打开cmd/powershell，输入 <code>npm install hexo --save</code> 回车，2分半，安装hexo完毕</p></li><li><p>把 主题 和 文章复制进去，</p></li><li><p>完毕，可以继续写了。  但是为了下一次的上传到github，还需要，继续设置一些东西。</p></li></ol><h3 id="二-手动回滚后的-连接github仓库等操作">二. 手动回滚后的，连接github仓库等操作</h3><ol><li><p>删除.git 和 .deploy_git文件，cmd cd到在hexo文件夹下，输入 <code>git init</code></p></li><li><p>手动删除远程库</p></li><li><p>按照，上文的 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一. 备份</span><br></pre></td></tr></table></figure><p>再来一次上传。嗯，当当，不会玩git的萌新的手动回滚 完成。</p></li></ol><h3 id="三-error汇总-全部出现于-没有删除github远程库-就尝试上传代码">三. Error汇总 (全部出现于，没有删除github远程库，就尝试上传代码)</h3><ol><li>fatal: not a git repository</li></ol><p>解决： 输入 <code>git init</code>回车</p><ol start="2"><li>warning: adding embedded git repository:</li></ol><p>解决： repository 中包含带有 .git 文件夹的目录，打开提示的文件夹，删除.git文件就好</p><ol start="3"><li>fatal: remote origin already exists. 远程库已存在<br>问题：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:ngp320/ngp320.github.io.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>解决： 先删除远程库，再连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:ngp320/ngp320.github.io.git</span><br></pre></td></tr></table></figure><ol start="4"><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo源码 备份到分支</title>
      <link href="/tech/bbe6eaf9.html"/>
      <url>/tech/bbe6eaf9.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-配置git">一. 配置Git</h3><h4 id="1-添加git-bin路径到path">1 添加Git\bin路径到path</h4><p>例如添加：<code>C:\Program Files\Git\bin</code> 到 path</p><h4 id="2-配置-ssh-key">2 配置 ssh key</h4><p>值得注意的只有一点： 上传 github 之前注意别忘了配置 <code>ssh</code> 密匙</p><p>方法如下：</p><p><strong>第一步：</strong></p><p>命令行 输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "youremail@example.com"   #youremail请改为你的github邮箱</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第二步：</strong></p><p>登陆 GitHub，打开“Account settings”，“SSH Keys”页面。</p><p>然后，点“Add SSH Key”，填上任意 Title，在 Key 文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><p>点“Add Key”，你就应该看到已经添加的 Key。</p><p>配置完成。</p><h3 id="二-备份">二. 备份</h3><ol><li><p>第一次备份的话（因为要新建分支，所以 ↓ )</p><p>1.1 先部署 hexo ，顺带就创建了主分支</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g                                // generate </span><br><span class="line">hexo d                                // deploy</span><br></pre></td></tr></table></figure><p>1.2 第一次备份源码(即远程仓库没有hexo_src分支)</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .                             // </span><br><span class="line">git commit -m 'backup'                // </span><br><span class="line">git branch hexo_src                   // 新建本地分支</span><br><span class="line">git checkout hexo_src                 // 切换到本地分支hexo_src</span><br><span class="line">git push origin hexo_src:hexo_src     // 提交本地分支到远程分支</span><br></pre></td></tr></table></figure></li><li><p>以后备份的话</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add . </span><br><span class="line">git commit -m 'backup'                // 也可以写一些有意义的备注，方便以后学会git后的回滚</span><br><span class="line">git checkout hexo_src                 // 切换到本地分支hexo_src</span><br><span class="line">git push origin hexo_src:hexo_src     // 提交本地分支到远程</span><br></pre></td></tr></table></figure></li></ol><p>p.s. 分支ps神奇的是，hexo 部署到 <a href="http://github.io">github.io</a> 并不需要切换分支，神奇 =。=<br>p.s. git好像识别不了删除的改动 e.g 删除5个字,会显示没有可以提交的内容</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《这就是马云》摘录</title>
      <link href="/arts/dc61272a.html"/>
      <url>/arts/dc61272a.html</url>
      
        <content type="html"><![CDATA[<h4 id="第五章-忙碌的阿里人-2009年那些事儿">第五章 忙碌的阿里人→2009年那些事儿</h4><blockquote><p>马云很有女人缘。有一回马云在女企业家论坛上发言：“在座的都是女强人，中国历史上最强的女强人有两个，武则天和慈禧。男人和女人是完全不同的动物。看女人强不强，主要看她能不能欣赏男人，用好男人。把男人变得更男人的女人才是女人中的女人。从管理学的角度，那就是‘通过别人拿成果’。” 马云接着说，“女强人往往在婚姻上都不顺，我告诉你们原因，男人就好比食堂里的大锅菜，很普通，但去晚了就没有了！ 女强人就好比是高级餐馆的高档菜，虽然好，但不见得会有人点，而且很快又被新菜取代了…”说得各个女强人笑得花枝乱颤。</p></blockquote><h4 id="第六章-兴趣与哲学-三亚休假再-禁语">第六章 兴趣与哲学→三亚休假再“禁语”</h4><blockquote><p>马云认为，毛主席的军事思想“在战略上藐视敌人，在战术上重视敌人”，把其中的“敌人”改成“自己”同样好用——“在战略上藐视自己，在战术上重视自己”。就是为什么马云常说“我们都是平凡人，我们要一起去完成一件不平凡的事”的原因。</p><p>马云常说的还有一句话：“工作本身是没有意义的，你也是你赋予它的。”这句话其实沉淀了我们很深的哲学思考。</p><p>哲学家罗素曾说过：“人类所有成就的殿堂都将消失在宇宙废墟的瓦砾中。”爱因斯坦也曾经说过：“从广义上来说，人类的生存和发展也是毫无意义的。”基督教为什么追求“审判”后的“永生”，因为他们认为没有“永生”就没有“意义”。</p><p>简而概之，马云看到了有些哲学思想会让人走向极端的消极，所以他认为只有培养积极的欲望，才会有积极的人生，只要你赋予了生活与工作积极的意义，工作和生活就会有意义。马云常说的另外一句话，我认为也是基于这种思考 ：“我们并不在乎你知道多少，我们只想知道你有多在乎。”</p></blockquote><h4 id="第六章-兴趣与哲学-马云读-道德经">第六章 兴趣与哲学→马云读《道德经》</h4><blockquote><p>有一次我问马云：“您常说‘运气是实力的一部分’，这句话我不是太理解。”</p><p>“你真的不理解吗？”马云说，“假如有一天淘宝网的总裁和副总裁及所有高管同时离职，你也没有机会做淘宝的CEO，‘运气’不会降临到你的头上，因为你不懂淘宝网。哈哈！还有，你听过马克·吐温和贝尔的故事吗？”</p><p>当年马克·吐温热衷投资科学发明，可每次都投资失败，他灰心了。当再有一个年轻人背着一个奇怪的机器，希望他投资500美元时，他拒绝了，为了不伤害这位年轻人，马克吐温最后说：“祝你成功，贝尔！”这个贝尔，就是电话的发明人。从表面上看是马克·吐温“运气”不好，而实质上是马克·吐温不具备判断科技创新的“实力”。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《这就是马云》 </tag>
            
            <tag> 马云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 技巧</title>
      <link href="/tech/t1/27c296dc.html"/>
      <url>/tech/t1/27c296dc.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-tags-和-categories-使用方法">1. tags 和 categories 使用方法 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3><p>(1) <code>categories</code>  只支持 分层分类</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">科技</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">t1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">t2</span></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">科学</span></span><br></pre></td></tr></table></figure><p>(2) <code>tags</code> 只支持 多标签</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">t1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">t2</span></span><br><span class="line"><span class="string">或者</span> </span><br><span class="line"><span class="attr">tags:</span> <span class="string">t1</span></span><br></pre></td></tr></table></figure><h4 id="2-输入文章属性：">2. 输入文章属性：</h4><p>输入 - - - (三个横杠) 会出现： YAML 巴拉巴拉巴拉。。然后输入 文章属性就好。</p><h3 id="n-参考">N. 参考</h3><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1"  class="footnote-item"><p><a href="">1.test</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
          <category> t1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> t1 </tag>
            
            <tag> t2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoHotKey脚本</title>
      <link href="/tech/c5eaf112.html"/>
      <url>/tech/c5eaf112.html</url>
      
        <content type="html"><![CDATA[<p>我的脚本备份:  <a href="https://pan.baidu.com/s/1ceTunj-CzTeAayasLNr2YQ">https://pan.baidu.com/s/1ceTunj-CzTeAayasLNr2YQ</a>  密码: 30e0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">;======本文是萌新的AHK常用脚本。原理不是很懂。AHK也没用多久。若有不恰当之处，望不吝赐教。========</span><br><span class="line">;============================基本按键介绍==================================</span><br><span class="line">; ! →  [Alt]        ; ! 想象成 Alt   的 l</span><br><span class="line">; # →  [win]        ; # 想           windows开始图案</span><br><span class="line">; ^ →  [Ctrl]       ; ^ 想象成 Ctrl  的 倒C</span><br><span class="line">; + →  [Shift]      ; + 想象成 Shift 的 f拉长</span><br><span class="line"></span><br><span class="line">; p.s. 开机启动 ahk脚本 →  把对应脚本的【快捷方式】放到：</span><br><span class="line">; C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\   【即可】</span><br><span class="line">;===============================特殊功能区1: 复制替换区==========================================</span><br><span class="line">;当前目录 打开CMD</span><br><span class="line">;解决： 打开PowerShell就好了(资源管理器 → [Shift] + 鼠标右键)，cmd 能做的 PowerShell 都能做</span><br><span class="line"></span><br><span class="line">;把选中文本的 tab键 换为 4个空格键  ([Ctrl] + V 黏贴覆盖就好，会有稍微变形 原因如下 ↓ )</span><br><span class="line">;缺陷1： 原理是替换空格。而tab键能够4个空格内，自动适应，所以tab实际可能等于1~4个空格，替换会导致轻微变形</span><br><span class="line">^!/::</span><br><span class="line">Send ^c</span><br><span class="line">Send ^c</span><br><span class="line">clipboard := StrReplace(clipboard, A_Tab, A_Space A_Space A_Space A_Space)</span><br><span class="line">tooltip,%clipboard%</span><br><span class="line">sleep,800</span><br><span class="line">tooltip,</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;复制选择文字并转换 &quot; ＼ &quot; 为 &quot;／&quot;</span><br><span class="line">^!\::        ;操作: 先选中文本，再按 [Alt] +　＼ , 再黏贴(按下 [Ctrl] +V)，完毕</span><br><span class="line">Send ^c</span><br><span class="line">Send ^c</span><br><span class="line">StringReplace, clip, clipboard, \, /, All   </span><br><span class="line">StringReplace, clip, clipboard, \, /, All   </span><br><span class="line">tooltip,%clip%;在鼠标右侧显示clipboard内容</span><br><span class="line">sleep,800</span><br><span class="line">tooltip,</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;复制选择文字并转换 &quot;空格&quot; 为 &quot;下划线&quot;</span><br><span class="line">^!-::        </span><br><span class="line">Send ^c</span><br><span class="line">Send ^c</span><br><span class="line">clip := RegExReplace(clipboard, &quot;\s&quot;,&quot;_&quot;)</span><br><span class="line">clip := RegExReplace(clipboard, &quot;\s&quot;,&quot;_&quot;)</span><br><span class="line">tooltip,%clip%;在鼠标右侧显示clipboard内容</span><br><span class="line">sleep,800</span><br><span class="line">tooltip,</span><br><span class="line">return</span><br><span class="line">;===============================特殊功能区2: 搜索区============================================</span><br><span class="line">;用Google搜索选中的文字;</span><br><span class="line">;解决: Send ^c 有时候没用 (编程语句用两次,防止 偶然/未知原因 导致的失败)</span><br><span class="line">;使用正则替换(RegExReplace)实现了，空格替换为 &quot;+&quot;号, 使搜索功能有更好的使用体验</span><br><span class="line">!g::  </span><br><span class="line">Send ^c</span><br><span class="line">Send ^c</span><br><span class="line">clipboard := RegExReplace(clipboard, &quot;\s&quot;,&quot;+&quot;)</span><br><span class="line">clipboard := RegExReplace(clipboard, &quot;\s&quot;,&quot;+&quot;)</span><br><span class="line">Chrome = C:\Program Files (x86)\Google\Chrome\Application\chrome.exe</span><br><span class="line">Run %Chrome%  http://www.google.com/search?q=%clipboard% </span><br><span class="line">return </span><br><span class="line">;===============================特殊功能区3: 复制/打开 文件路径区===============================</span><br><span class="line">Explorer_GetSelection(hwnd=&quot;&quot;)   </span><br><span class="line">&#123;  </span><br><span class="line">    WinGet, process, processName, % &quot;ahk_id&quot; hwnd := hwnd? hwnd:WinExist(&quot;A&quot;)  </span><br><span class="line">    WinGetClass class, ahk_id %hwnd%  </span><br><span class="line">    if (process != &quot;explorer.exe&quot;)  </span><br><span class="line">        return  </span><br><span class="line">    if (class ~= &quot;Progman|WorkerW&quot;) &#123;  </span><br><span class="line">            ControlGet, files, List, Selected Col1, SysListView321, ahk_class %class%  </span><br><span class="line">            Loop, Parse, files, `n, `r  </span><br><span class="line">                ToReturn .= A_Desktop &quot;\&quot; A_LoopField &quot;`n&quot;  </span><br><span class="line">        &#125; else if (class ~= &quot;(Cabinet|Explore)WClass&quot;) &#123;  </span><br><span class="line">            for window in ComObjCreate(&quot;Shell.Application&quot;).Windows </span><br><span class="line">&#123;</span><br><span class="line">try&#123;</span><br><span class="line">                if (window.hwnd==hwnd)  </span><br><span class="line">                    sel := window.Document.SelectedItems  </span><br><span class="line">&#125;catch e &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            for item in sel  </span><br><span class="line">                ToReturn .= item.path &quot;`n&quot;  </span><br><span class="line">        &#125;  </span><br><span class="line">    return Trim(ToReturn,&quot;`n&quot;)  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;[Win] + Z ;一键拷贝文件路径 ;</span><br><span class="line">#Z::</span><br><span class="line">clipboard := % Explorer_GetSelection(hwnd) ;调用了 函数</span><br><span class="line">Tooltip,%clipboard%;在鼠标右侧显示【拷贝的文件路径】</span><br><span class="line">Sleep,800</span><br><span class="line">Tooltip,</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;一键用notepad++[打开选中的文件]or[选中文件夹]的所有子文件</span><br><span class="line">;路径中有空格就会很糟糕</span><br><span class="line">;[Win] + E</span><br><span class="line">#E::</span><br><span class="line">path :=% Explorer_GetSelection(hwnd) ;调用了 函数</span><br><span class="line">Software = C:\Program Files\Notepad++\notepad++.exe </span><br><span class="line">IfInString, path, %A_Space%</span><br><span class="line">&#123;</span><br><span class="line">Tooltip, path中有空格;在鼠标右侧显示【错误信息】</span><br><span class="line">Sleep,800</span><br><span class="line">Tooltip,</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">Run, %Software% %path%</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;C:\Users\NGP\Desktop\12 23</span><br><span class="line">;numOfSpacesInPath := RegExMatch(clipboard,&quot;\s&quot;) 【正则匹配被取代，有更好的】</span><br><span class="line"></span><br><span class="line">;===============================特殊功能区4: 特殊热字串区===================================</span><br><span class="line">;发送当前日期  【？号表示在单词中也会替换，e.g. Vnnow → V2019.....】</span><br><span class="line">:?:nnow::</span><br><span class="line">FormatTime, CurrentDateTime,, yyy-MM-dd HH:mm:ss  </span><br><span class="line">Send %CurrentDateTime%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;==================================特殊功能区n: 特殊区======================================</span><br><span class="line">;显示 复制和剪切的内容</span><br><span class="line">~^x::</span><br><span class="line">~^c::;~ 表示次热键并不屏蔽按键原有功能</span><br><span class="line">Sleep, 100;等待0.1s 强制机械等待剪贴板出现内容 </span><br><span class="line">;clip:=clipboard</span><br><span class="line">StringLeft,clipboard_left,clipboard,500</span><br><span class="line">Tooltip,%clipboard_left%;在鼠标右侧显示clip(clipboard内容)</span><br><span class="line">Sleep,800</span><br><span class="line">Tooltip,</span><br><span class="line">Return </span><br><span class="line"></span><br><span class="line">;================================便捷输入区=================================================</span><br><span class="line">;以下cmd命令可以解决部分中文乱码问题</span><br><span class="line">;chcp 936 </span><br><span class="line"></span><br><span class="line">;便捷输入 常用账号名</span><br><span class="line">::nnev:: XXXXXXXXXXXXXXX</span><br><span class="line"></span><br><span class="line">;放弃【段首缩进】。使用【换行】实现 【换段】，有效减轻【文字过于密集，以至于阅读体验不好】的问题。</span><br><span class="line"></span><br><span class="line">;===============================软件快捷启动区==============================================</span><br><span class="line"></span><br><span class="line">;打开AutoHotkey中文教程</span><br><span class="line">!y::</span><br><span class="line">Run, E:\00win10装机\03装机必备软件\4AHK\AutoHotkeyHelp_CN\AutoHotkey.chm</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;打开Eclipse</span><br><span class="line">!e::</span><br><span class="line">Run, D:\0Software\eclipse\eclipse.exe</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;###############################以下内容均已注释【注释】#############################################</span><br><span class="line">;##################################特殊功能区【注释】################################################</span><br><span class="line">;[Ctrl] + [Shift] + C ;一键拷贝文件路径  【功能已被替换Win+Z】</span><br><span class="line">;缺陷1: 无法拷贝父文件夹路径</span><br><span class="line">;缺陷2: 路径中不能有空格(也不能说是缺陷吧,了解点为什么路径最好是全英文+下划线的原因)</span><br><span class="line">;缺陷3: 偶尔[Ctrl] + C 不灵，不知道是不是这个热键导致的。</span><br><span class="line">;缺陷4：因为用的是 ^C 也就是Ctrl+C实现的，剪切板会被当前路径覆盖</span><br><span class="line">;优势1: 意外地能复制文本。</span><br><span class="line">;^+c::</span><br><span class="line">;Send ^c</span><br><span class="line">;sleep,200</span><br><span class="line">;clipboard=%clipboard% ;%null%</span><br><span class="line">;tooltip,%clipboard%;在鼠标右侧显示clipboard内容</span><br><span class="line">;sleep,800</span><br><span class="line">;tooltip,</span><br><span class="line">;return</span><br><span class="line"></span><br><span class="line">;按一下tab输出4个空格，把原来的 [Tab] 键屏蔽了 【功能已被替换Ctrl+Alt+/】</span><br><span class="line">;Tab::</span><br><span class="line">;Send &#123;space&#125;</span><br><span class="line">;Send &#123;space&#125;</span><br><span class="line">;Send &#123;space&#125;</span><br><span class="line">;Send &#123;space&#125;</span><br><span class="line">;return</span><br><span class="line"></span><br><span class="line">;###############################软件快捷启动区【注释】###############################################</span><br><span class="line">;!s::        ;Notepad++ 打开预设位置的py文件</span><br><span class="line">;RuanJian # C:\Program Files\Notepad++\notepad++.exe</span><br><span class="line">;WenJian # D:\pythonDemo\TestDemo.py</span><br><span class="line">;Run, %RuanJian% &quot;%WenJian%&quot; </span><br><span class="line">;return</span><br><span class="line"></span><br><span class="line">;打开 cmder</span><br><span class="line">;!c::</span><br><span class="line">;Run, D:\0Software\cmder\Cmder.exe</span><br><span class="line">;return</span><br><span class="line"></span><br><span class="line">;!c::        ;打开cmd 并输入一段命令</span><br><span class="line">;缺陷1：同一时间同一路径只能打开一个cmd</span><br><span class="line">;缺陷2：必须在英文输入法下</span><br><span class="line">;缺陷3：偶尔标点输入出错</span><br><span class="line">;run cmd.exe</span><br><span class="line">;WinWait, cmd.exe</span><br><span class="line">;Send cd /d D:\blog\ &#123;Enter&#125; ;</span><br><span class="line">;return</span><br><span class="line"></span><br><span class="line">;##################################便捷输入区【注释】#################################################</span><br><span class="line">;Java 便捷输入</span><br><span class="line">;输入//e8后再空格 →  输入替换</span><br><span class="line">;::/cpy::cd /d D:\pythonDemo\ &#123;Enter&#125;  </span><br><span class="line">;::/e8:: -encoding utf-8</span><br><span class="line"></span><br><span class="line">;CSDN 便捷输入</span><br><span class="line">;::nbsp::&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line"></span><br><span class="line">;Hexo 便捷输入  (文档: 超长替换,即替换可以输出特殊符号)</span><br><span class="line">;::nnot:: </span><br><span class="line">;(</span><br><span class="line">;notepad++ * -r </span><br><span class="line">;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ahk </tag>
            
            <tag> autohotkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>$jsimple(Hexo) Error</title>
      <link href="/others/a128c46f.html"/>
      <url>/others/a128c46f.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-tags标签页-不显示标签">一. tags标签页,不显示标签</h3><p>(1) 先在 ***\hexo 下 打开 cmd , 输入 hexo new page “tags” 回车</p><p>(2) 在 ***\hexo\source\tags\<a href="http://index.md">index.md</a> 中添加一句 layout: “tags”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tagcloud</span><br><span class="line">date: 2017-04-26 17:47:43</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="二-table排版乱了">二. table排版乱了</h3><p>修改 D:\blog\themes\jsimple\source\css\JSimple.css  ↓</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.markdown-body</span> <span class="selector-tag">table</span> &#123;</span><br><span class="line"><span class="comment">/* display:block; */</span> <span class="comment">/* 注释后tr就撑满了table */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.markdown-body</span> <span class="selector-tag">table</span> <span class="selector-tag">tr</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* display: flex; */</span> <span class="comment">/* 注释以后table上下就对齐了 */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-英文标点自动变中文标点-自动加空格">三. 英文标点自动变中文标点， 自动加空格</h3><p>原因: 油猴 脚本 → 为什么不加个空格呢 =。=</p><h3 id="四-部分标签点开404">四. 部分标签点开404</h3><ol><li>部分原因是git的设置，以及没有强制更新标签云，部分原因是:</li></ol><blockquote><p>格式错误1(tags: […] 这种格式能显示标签，但是标签页打不开，也就是兼容性不好?):</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; tags: [t1,t2] </span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>格式错误2(标签大小写不一样会冲突，还是得赶紧写一个 文件替换程序):<br>| 有的是 | 有的是 |<br>| --------------------------- | ---- |<br>|      tags:      | tags: |<br>| - Notepad++ | - notepad++ |</p></blockquote><ol start="2"><li>解决步骤1: 文章属性的替换</li></ol><p>(1) LV1: Notepad++ 批量打开所有md文件，批量查找 ,再手动替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags:.*\[.+\]//正则表达式之一</span><br><span class="line">tags:.*(\s)&#123;1,3&#125;.*-.*hexo//(\s)&#123;1,3&#125;表示1-3个回车键  精确匹配</span><br></pre></td></tr></table></figure><blockquote><p>缩小了工程量，如果需要修改的量不大的话~  可是一般都很大，所以</p></blockquote><p>(2) Lv3: python/java 代码操作</p><blockquote><p>还没弄明白 python的 各种gbk error问题</p><p>java到时觉得可以搞一搞 =。=  可是就是觉得想用python写，java没什么难度的赶脚</p></blockquote><ol start="3"><li>解决 步骤2:</li></ol><p>修改 git 设置不忽略大小写 (不使用步骤1的话 git和Git就被分为了两个标签，不适合查阅)</p><blockquote><p>进入博客文件夹，进入 git 目录：.deploy_git ，修改 .git 文件中的配置文件 config，</p><p>将ignorecase=true 改为 ignorecase=false</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim . deploy_git/.git/config</span><br><span class="line"><span class="meta">#</span> ignorecase = true</span><br><span class="line">ignorecase = false</span><br></pre></td></tr></table></figure><ol start="4"><li>解决 步骤3:</li></ol><p>问题: 本地完好，上传就出错  还是错误的标签 : mactype ahk autohotkey hexo</p><p>解决: 清空远程库，重新上传:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">git rm -rf *</span><br><span class="line">git commit -m 'clean all file'</span><br><span class="line">git push</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>引发的问题1: 主页404，标签页正常了<br>解决: ping <a href="http://ngp320.github.io">ngp320.github.io</a> 发现ping的ip变了，故修改 阿里云解析DNS 的解析设置 的ip就好了。</p><p>引发的问题2: 要重新配置origin</p><blockquote><p>清空远程库是把本地暂存区清空，再提交上去，故，要重新配置origin</p></blockquote><p>git remote add origin git@github<font color=red font-weight=900>.com</font>:GitHub用户名/新建的仓库的英文名.git <font color=orange font-weight=900>(仓库名别写错了)</font></p><p>引发的问题3: git提交源码的时候  error: Updates were rejected because the remote contains work that you do not have locally.</p><p>解决请看: <a href="https://tanghao.fun/post/6941e1ba">$Git Error</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> jsimple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 简化运行测试&amp;部署</title>
      <link href="/tech/cdf7a176.html"/>
      <url>/tech/cdf7a176.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-简化测试-部署">一. 简化测试&amp;部署</h3><p>(1) 新建 package.json 文件<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>使用 npm init 即可在当前目录创建一个 package.json 文件</p><p>输入 npm init 后会弹出一堆问题，我们可以输入对应内容，也可以使用默认值。在回答一堆问题后输入 yes 就会生成图中所示内容的 package.json 文件。</p><p>如果嫌回答这一大堆问题麻烦，可以直接输入 npm init --yes 跳过回答问题步骤，直接生成默认值的 package.json 文件。</p><p><strong>简化部署命令</strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>每次更新博客都需要 <code>hexo clean</code> <code>hexo g</code>，太繁琐，我们可以通过 node.js 的 scripts 来简化部署命令，打开 `` 在末尾的 } 前添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;g&quot;: &quot;hexo clean &amp;&amp; hexo douban &amp;&amp; hexo g&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样我们执行 <code>npm run g</code> 就相当于执行了 <code>hexo clean &amp;&amp; hexo douban &amp;&amp; hexo g</code></p><h3 id="n-参考">N. 参考</h3><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1"  class="footnote-item"><p><a href="https://blog.csdn.net/u011240877/article/details/76582670#packagejson-%E6%96%87%E4%BB%B6">1.npm 与 package.json 快速入门教程 - 张拭心的博客 shixinzhang - CSDN博客</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2"  class="footnote-item"><p><a href="https://www.iots.vip/post/hexo-build-to-optimize.html">2.hexo的搭建、设置与部分优化</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo) 标签云 简单美化</title>
      <link href="/tech/58c567ff.html"/>
      <url>/tech/58c567ff.html</url>
      
        <content type="html"><![CDATA[<p>我的博客采用的是： 标签简单分3类，用标签代替任何 【更细分的分类】</p><h3 id="一-hexo-自动生成-tag-cloud-标签云页面">一. Hexo 自动生成 Tag Cloud 标签云页面</h3><p>在<code>/layout/.../tags.ejs</code> 添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.path === <span class="string">"tags/index.html"</span>)&#123; %&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;%- list_categories(&#123;</span><br><span class="line">        depth: <span class="number">1</span>,</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tags"</span>&gt;</span><br><span class="line">        &lt;%- tagcloud(&#123;</span><br><span class="line">            min_font: <span class="number">16</span>, </span><br><span class="line">            max_font: <span class="number">35</span>, </span><br><span class="line">            amount: <span class="number">999</span>, </span><br><span class="line">            color: <span class="literal">true</span>, </span><br><span class="line">            start_color: <span class="string">'gray'</span>, </span><br><span class="line">            end_color: <span class="string">'black'</span>,</span><br><span class="line">        &#125;) %&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        .category-list li&#123;</span></span><br><span class="line"><span class="regexp">            display: inline-block;</span></span><br><span class="line"><span class="regexp">            margin: 0 1em .5em 0;</span></span><br><span class="line"><span class="regexp">            padding: 4px;</span></span><br><span class="line"><span class="regexp">            border: 1px solid lightgray;</span></span><br><span class="line"><span class="regexp">            font-size: 1.2em;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .category-list a &#123;</span></span><br><span class="line"><span class="regexp">            color: gray;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .category-list-item:hover a &#123;</span></span><br><span class="line"><span class="regexp">            color: gray;</span></span><br><span class="line"><span class="regexp">            text-decoration: none;</span></span><br><span class="line"><span class="regexp">            font-weight: bold;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .category-list-count &#123;</span></span><br><span class="line"><span class="regexp">            margin-left: 2px;</span></span><br><span class="line"><span class="regexp">            font-size: .9em;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .article-entry ul li:before&#123;</span></span><br><span class="line"><span class="regexp">            display: none;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .article-inner  &#123;</span></span><br><span class="line"><span class="regexp">            text-align: center;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .tags &#123;</span></span><br><span class="line"><span class="regexp">            max-width: 40em;</span></span><br><span class="line"><span class="regexp">            margin: 2em auto;</span></span><br><span class="line"><span class="regexp">            margin-top: 0em;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .tags a &#123;</span></span><br><span class="line"><span class="regexp">            margin-right: 1em;</span></span><br><span class="line"><span class="regexp">            border-bottom: 1px solid gray;</span></span><br><span class="line"><span class="regexp">            line-height: 65px;</span></span><br><span class="line"><span class="regexp">            white-space: nowrap;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .tags a:hover &#123;</span></span><br><span class="line"><span class="regexp">            border-bottom: 2px solid black;</span></span><br><span class="line"><span class="regexp">            font-style: italic;</span></span><br><span class="line"><span class="regexp">            text-decoration: none;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="二-彩色标签云-这种方式会让原来的样式消失">二. 彩色标签云 (这种方式会让原来的样式消失)</h3><p>修改 tagcloud部分如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- tagcloud(&#123; <span class="comment">// <span class="doctag">TODO:</span> remember to fix this.</span></span><br><span class="line">       min_font: <span class="number">16</span>, </span><br><span class="line">       max_font: <span class="number">40</span>, </span><br><span class="line">       amount: <span class="number">999</span>, </span><br><span class="line">       color: <span class="literal">true</span>, </span><br><span class="line">       start_color: <span class="string">'gray'</span>, </span><br><span class="line">       end_color: <span class="string">'red'</span>,</span><br><span class="line">   &#125;) %&gt;</span><br><span class="line">   &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">     <span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tagscloud a'</span>);</span><br><span class="line">     <span class="built_in">Array</span>.prototype.forEach.call(list, (item, index) =&gt; &#123;</span><br><span class="line">       <span class="comment">//item.style.fontSize = Math.floor(Math.random() * 29 + 12) + 'px';//12 ~ 40</span></span><br><span class="line">       <span class="comment">//item.style.color = 'rgb(' + Math.floor(Math.random() * 201) + ', ' + Math.floor(Math.random() * 201) + ', ' + Math.floor(Math.random() * 201) + ')';// 0,0,0 -&gt; 200,200,200</span></span><br><span class="line">       S = <span class="string">"90"</span>;      <span class="comment">//wa kao, 直接写 "100%,100%)"; 就是不行，非得用个变量 =。= </span></span><br><span class="line">       L = <span class="string">"49"</span>;       <span class="comment">//莫非重载函数只有 全是变量和全是常量两个？</span></span><br><span class="line">       item.style.color = <span class="string">"hsl("</span> + <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">360</span>) + <span class="string">","</span> + S + <span class="string">'%,'</span> + L + <span class="string">'%)'</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> jsimple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell</title>
      <link href="/tech/a2c49dae.html"/>
      <url>/tech/a2c49dae.html</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmder 安装&amp;简单优化</title>
      <link href="/tech/b0a42d7.html"/>
      <url>/tech/b0a42d7.html</url>
      
        <content type="html"><![CDATA[<p>功能&amp;外观&amp;便利&amp;稳定 : cmder &gt; PowerShell &gt; cmd</p><p>启动速度: cmd &gt; PowerShell &gt; cmder</p><h3 id="一-cmder-介绍">一. cmder 介绍</h3><blockquote><p>有两个版本，分别是mini与full版；</p><p>唯一的差别在于有没有内建msysgit工具，这是Git for Windows的标准配备；</p><p>全安装版 cmder 自带了 msysgit, 压缩包 23M, 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。</p></blockquote><h3 id="二-cmder-安装">二. cmder 安装</h3><p>​解压后，点击<code>Cmder.exe</code>即可运行。</p><ol><li><p>把 <strong>cmder</strong> 加到环境变量<br>可以把<code>Cmder.exe</code>存放的目录添加到系统环境变量；加完之后,<code>Win+r</code>一下输入<code>cmder</code>,即可。</p></li><li><p><strong>添加 cmder 到右键菜单</strong><br>在某个文件夹中打开终端, 这个是一个(超级)痛点需求, 实际上上一步的把 <strong>cmder</strong> 加到环境变量就是为此服务的, 在管理员权限的终端输入以下语句即可:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmder.exe /REGISTER ALL</span><br></pre></td></tr></table></figure></li></ol><h3 id="三-解决mactype与cmder冲突">三. 解决Mactype与cmder冲突</h3><p>(0) Mactype 与 冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in config file X:\Program Files\MacType\ini\***.ini(安装的那个ini)</span><br><span class="line">at [ExcludeSub] add:</span><br><span class="line">ConEmuC.exe</span><br><span class="line">ConEmuC64.exe</span><br><span class="line">at [UnloadDll] add:</span><br><span class="line">ConEmuC.exe</span><br><span class="line">ConEmuC64.exe</span><br></pre></td></tr></table></figure><p>(1) 启动速度加速到 4s左右</p><p><code>win + alt + p</code> → StartUp → specified named task → PowerShell</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora Hexo 问题&amp;技巧</title>
      <link href="/others/c66ebb09.html"/>
      <url>/others/c66ebb09.html</url>
      
        <content type="html"><![CDATA[<h3 id="error">ERROR:</h3><h4 id="1-说date标签错误">1 说date标签错误</h4><p>结果：</p><p>可能1: 文章标题 下面不能放链接 =。=</p><p>可能2: 还有就是title里不能放: “:”,…待试错测出</p><p>“:” 可以替换为 “ → ”</p><p>…</p><p>反正是: 某处语法错误</p><h4 id="2-ejs和css文件注释">2. ejs和css文件注释</h4><p>ejs文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最终决定使用 &lt;%/* comment */%&gt; 即匹配语法高亮（绿色注释），也不会显示到html里去</span><br><span class="line"></span><br><span class="line">&lt;!-- comment  --&gt; 注释的话 → 怪怪的，不能匹配语法高亮</span><br><span class="line">/* comment */ 注释的话 →  会显示到html里去</span><br></pre></td></tr></table></figure><p>css文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* comment */</span><br></pre></td></tr></table></figure><h3 id="技巧：">技巧：</h3><h4 id="1-多标签-和-分层目录-的时候">1 多标签 和 分层目录 的时候</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Java</span><br><span class="line">- 反射</span><br><span class="line">tags:</span><br><span class="line">- 反射机制</span><br><span class="line">- haha</span><br></pre></td></tr></table></figure><p><strong>“-” 后面有一个空格特别注意</strong></p><h4 id="2-修改-typora-默认主题-以github主题为模版">2 修改 typora 默认主题 (以GitHub主题为模版)</h4><p>主要修改内容如下(文件→偏好设置→打开主题模版→复制github模版重命名为my-typora-theme.css→打开修改)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    /* 更改默认 英文 中文 字体 */</span><br><span class="line">    /* 前提是安装这两款字体: Inconsolata,&quot;思源宋体&quot; */</span><br><span class="line">    font-family: Inconsolata,&quot;思源宋体&quot;,&quot;Open Sans&quot;,&quot;Clear Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif;</span><br><span class="line">    color: rgb(51, 51, 51);</span><br><span class="line">    line-height: 1.6;</span><br><span class="line">    background-color: #eeeeee; /* 更改默认背景颜色 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-typora修改表格宽度">3. typora修改表格宽度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 &lt;br/&gt; 来给更长的一部分换行。 手动设置宽度 =。=</span><br></pre></td></tr></table></figure><h4 id="4">4.</h4><h4 id="p-s-typora-和-hexo-显示的不同">P.S. typora 和 hexo 显示的不同</h4><table><thead><tr><th style="text-align:center">原内容</th><th style="text-align:center">替换为</th></tr></thead><tbody><tr><td style="text-align:center">文章中的tab</td><td style="text-align:center">1个空格</td></tr><tr><td style="text-align:center">表格里的句首空格</td><td style="text-align:center">空</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo)简单自定义</title>
      <link href="/others/c1364d50.html"/>
      <url>/others/c1364d50.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-去掉标签之间的不怎么好看的-符号">1 去掉标签之间的不怎么好看的.符号</h4><p>路径: themes\jsimple\layout\_widget\category-items.ejs    post-meta → em</p><h4 id="2-技术改为科技">2 技术改为科技</h4><p>位置：</p><p>hexo\_config.yml</p><p>hexo\themes\jsimple\_config.yml</p><p>hexo\themes\jsimple\<a href="http://README.zhCN.md">README.zhCN.md</a></p><h4 id="n-添加分类显示-只是一个尝试-实际上不需要">n. 添加分类显示 (只是一个尝试，实际上不需要)</h4><p>(1) 生成categories页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>在 <code>categories\index.md</code> 中添加： <code>layout: “categories”</code></p><p>(2) 在 <code>blog\themes\jsimple\_config.yml</code> 里，添加如下部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Customize left navigation menus. faName is FontAwesome style name</span><br><span class="line">left_nav_menus:</span><br><span class="line">- uri: help</span><br><span class="line">    title: 帮助</span><br><span class="line">    faName: fa-question-circle</span><br><span class="line">- uri: categories</span><br><span class="line">    title: 分类</span><br><span class="line">    faName: fa-question-circle</span><br></pre></td></tr></table></figure><p>(3) 在 <code>D:\blog\themes\jsimple\layout</code> 里，复制tags.ejs重命名为categories.ejs</p><p>(4) 适当修改categories.ejs，即可生成分类页，不过顶部那一栏已经实现了分类，所以，这只是为了记录经验。以防以后用得到，categories主要要更改tags.ejs的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  &lt;p&gt;&lt;img src=&quot;/images/dog.png&quot; alt=&quot;tags-bg&quot;&gt;&lt;/p&gt;  --&gt;</span><br><span class="line">      &lt;div class=&quot;post-content markdown-body&quot; itemprop=&quot;articleBody&quot;&gt;</span><br><span class="line">          &lt;% if (page.path === &quot;categories/index.html&quot;)&#123; %&gt;</span><br><span class="line">              &lt;hr&gt;</span><br><span class="line">              &lt;br&gt;</span><br><span class="line">              &lt;%- list_categories(&#123;</span><br><span class="line">                  depth: 1,</span><br><span class="line">              &#125;) %&gt;</span><br><span class="line">          &lt;% &#125; %&gt;</span><br><span class="line">          &lt;!--  注释原有的tags界面</span><br><span class="line">          &lt;ul class=&quot;tag-list&quot;&gt;</span><br><span class="line">              &lt;% site.tags.sort(&apos;name&apos;).map(function(tag)&#123;  %&gt;</span><br><span class="line">              &lt;li&gt;&lt;a href=&quot;&lt;%- url_for(tag.path) %&gt;&quot;&gt;&lt;%= tag.name %&gt;(&lt;%= tag.length %&gt;)&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">              &lt;% &#125;) %&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">          --&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> jsimple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsimple(Hexo) 代码高亮 失败</title>
      <link href="/others/a0613def.html"/>
      <url>/others/a0613def.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-代码高亮-算了算了-默认的就好-google-prettify-code-操作一天还把主题玩坏了">1 代码高亮 算了算了，默认的就好， google prettify code 操作一天还把主题玩坏了</h3><blockquote><p>所有文章的输出界面是layout.ejs，head和footer都在里面没有分开， ╥﹏╥… (cost: 2h+)</p><p>即是 → <code>jsimple\layout\layout.ejs</code></p><p>在 jsimple\layout_partial\head.ejs  和 footer.ejs 弄了好久</p></blockquote><h3 id="本来这个主题的高亮-能匹配上的话-还是挺好看的诶">本来这个主题的高亮，能匹配上的话，还是挺好看的诶~</h3>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> jsimple </tag>
            
            <tag> 代码高亮 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notepad ++简单美化</title>
      <link href="/tech/289a3e99.html"/>
      <url>/tech/289a3e99.html</url>
      
        <content type="html"><![CDATA[<h3 id="零-下载最新版本-notepad-7-6-1">零、下载最新版本 Notepad++ (7.6.1)</h3><p><a href="https://notepad-plus-plus.org">下载地址</a></p><h3 id="一-选择中文版本">一、选择中文版本</h3><p>         点击Settings(设置) →  perferences (首选项) → General → Localization → 中文简体</p><h3 id="二-修改默认主题-字体">二、修改默认主题&amp;字体</h3><p><font color=gray size=2> 此部分转载自: <a href="https://cloud.tencent.com/developer/article/1147369">Notepad++ 主题配色配置</a></font><br><font color=gray size=2> 其实默认主题，也挺好用的，obsidian有点酷，但有时候有点不实用<br></font><br>         点击Settings(设置) → Style Configuration (样式配置)<br><strong>方案1:</strong><br><font size= 2 color=orange>请一定要勾选全局字体！<br>请一定要勾选全局字体！<br>请一定要勾选全局字体！<br></font><br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-19-1.png" alt="1"><br><font size= 2 color=red>请一定要勾选全局字体！<br>请一定要勾选全局字体！<br>请一定要勾选全局字体！<br></font><br><strong>方案2:</strong><br><a href="https://pan.baidu.com/s/1P75YRecz50yu15LVuGJxtA">字体微软雅黑和Consolas的混合字体(点击下载)</a>——<font color=orange>注意：字体应放在“C:\WINDOWS\Fonts”路径下。</font></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-19-2.png" alt="2"><br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-19-3.png" alt="3"></p><h3 id="三-设置">三、设置</h3><ul><li>符号补全（设置 → 首选项）<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-19-4.png" alt="4"></li><li>显示空格与制表符（视图 → 现世符号 → 显示空格与制表符）<br>制表符自动替换空格 （设置 → 首选项）<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-19-5.png" alt="5"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> notepad++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome使用技巧备忘</title>
      <link href="/tech/2a7f2876.html"/>
      <url>/tech/2a7f2876.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>前提： 科学上网</p></blockquote><h3 id="一-下载chrome-离线版">一. 下载Chrome 离线版</h3><p>Google Chrome 已经是许多人的默认浏览器，但由于“你懂的”原因，在线安装基本没有成功过，他自己的自动更新也多数一直在加载中，所以我们会到一些下载站下载安装包，但我的多次经历告诉我，下载回来的一般都是32位的。</p><p>因为我用的是64位的 Windows 7 ，相信许多人会有和我一样的感受，64位的**<a href="https://link.zhihu.com/?target=http%3A//lib.csdn.net/base/operatingsystem">操作系统</a>**用起来比32位的似乎更流畅一起，因此，我们要的是64位的 Google Chrome 最新版离线安装包。</p><p>1、打开 Chrome 浏览器主页：<a href="https://link.zhihu.com/?target=http%3A//www.google.cn/chrome">http://www.google.cn/chrome</a></p><p>2、地址栏最后的网址是这样的：<a href="https://link.zhihu.com/?target=http%3A//www.google.cn/chrome/browser/desktop/index.html">http://www.google.cn/chrome/browser/desktop/index.html</a></p><p>3、在网址最后加上：?standalone=1&amp;platform=win64，回车键后打开的是 64位下载页面，点击“下载Chrome”按钮，得到的就是 Google Chrome 64位离线安装包</p><p>解释下添加的参数，?standalone=1 指离线安装包，platform=win64 指64位Windows 版本。</p><p>如果加上的只是“?standalone=1”可以用来下载32位的Chrome离线包。用“mac”替换“win”，就可以下载 Mac 版本的了。</p><h3 id="二">二.</h3>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java(高级编程)正则表达式</title>
      <link href="/tech/dbaeb4f.html"/>
      <url>/tech/dbaeb4f.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-正则引出">一. 正则引出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;123&quot;;</span><br><span class="line">System.out.println(str.matches(&quot;\\d+&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     如以上代码，在判断字符串是否为数字的时候，如果用if语句判断，那么可能要8行左右才能做到，而用正则表达式，只需要一行简单的操作就实现了，而其中出现的 <code>\\d+</code> 就是正则表达式。<br>     正则是从JDK1.4的时候正式引入到 java中的工具类，所有正则支持的类都定义在 java.util.regex包里面。在JDK1.4之前，如果要想使用正则，则需要单独下载一个正则表达式的开发包后才可以使用。<strong>(正则表达式的原理: 离散数学)</strong><br>     在 java.util.regex包里面定义了两个主要的类:</p><ul><li>Pattern类: 此类对象如果想要取得必须使用compile()方法，方法的功能是编译正则。</li><li>Matcher类: 通过Pattern类取得。</li></ul><p>（正则里面最重要的不是方法名称，而是标记，例如 <code>\\d+</code> ）</p><h3 id="二-正则-标记-核心-核心-核心">二. 正则 标记（核心、核心、核心）</h3><p>     所有的正则可以使用的标记都在 java.util.regex.Pattern类里面定义。<br>1、单个字符（数量: 1）</p><ul><li>字符 : 表示由以为字符所组成;</li><li><code>\\</code> : 表示转义字符  &quot;  \  &quot; ;</li><li>\t : 表示一个  &quot; \t &quot;  符号;</li><li>\n : 匹配换行 ( &quot; \n &quot;  符号)</li></ul><p>2、字符集（数量:1）:</p><ul><li>[abc] : 表示可能是字符a、或者是字符b、或者是字符c中的任意一位；</li><li>[^abc] : 表示不是a、b、c中的任意一位；</li><li>[a-z] : 所有的小写字母；</li><li>[A-Z] : 所有的大写字母；</li><li>[a-zA-Z] : 表示任意的一位字母，不区分大小写；</li><li>[0-9] : 表示任意的一位数字。</li></ul><p>3、简化的字符集表达式（数量:1）:</p><ul><li>. : 表示任意的一位字符；</li><li>\d : 等价于 &quot; [0-9] &quot; ，属于简化写法；</li><li>\D : 等价于 &quot; \[^0-9] &quot; ，属于简化写法；</li><li>\s : 表示任意的空白字符，例如 &quot; - \t &quot; 、 &quot; - \n &quot; ；</li><li>\S : 表示任意的非空白字符；</li><li>\w : 等价于 &quot; [a-zA-Z_0-9] &quot; ，表示由任意的字母、数字、_所组成;</li><li>\W : 等价于 &quot; [^a-zA-Z_0-9] &quot; ，表示不是由任意的字母、数字、_所组成;</li></ul><p>4、边界匹配（不要在Java中使用，在JavaScript中使用） :</p><ul><li>^ : 正则的开始;</li><li>$ : 正则的结束;</li></ul><p>5、数量表达 :</p><ul><li>正则? : 表示此- 正则可以出现0次或1次;</li><li>正则+ : 表示此- 正则可以出现1此或1次以上；</li><li>正则* : 表示此- 正则可以出现0次、1次或多次；</li><li>正则{n} : 此- 正则<strong>正好</strong>出现n次；</li><li>正则{n,} : 表示此- 正则出现n次以上（包含n）；</li><li>正则{n,m} : 表示此- 正则出现n~m次（包含n和m）；</li></ul><p>6、逻辑运算 :</p><ul><li>正则1 正则2 : 正则1判断完成之后判断正则2 （相当于&amp;的操作）；</li><li>正则1 | 正则2  : 正则1或者是正则2有一组满足即可；</li><li>(正则) : 将多个正则作为1组**(当成一个整体)**，可以为这一组单独设置出现的次数。</li></ul><h3 id="三-string类对正则的支持-重点">三. String类对正则的支持（重点）</h3><p>     在JDK1.4之后，由于正则的引入，所以String类里面也相应的增加了心的操作方法支持。<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-10-1.png" alt="1"><br>     这三组方法在工作中用得特别多。<br>     给出的几个方法里面对于替换和拆分实际上难度不高，最关键就是正则匹配，在验证上使用的特别多。</p><p><strong>范例:</strong> 实现字符串拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;I2389have283a239dream39&quot;;</span><br><span class="line">String regex = &quot;\\d+&quot;;  //此处编写正则</span><br><span class="line">String result [] = str.split(regex);</span><br><span class="line">for(int x = 0 ; x &lt; result.length ; x ++) &#123;</span><br><span class="line">System.out.println(result[x]);//按任意长度的数字进行拆分</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     所有正则之中最应该引起我们兴奋的事情是因为可以使用它进行验证。（str.matches）</p><p>范例: 验证一个字符串是否是数字，如果是则将其变为double型<br>数字可能是整数（10），也可能是小数（10.2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;10&quot;;</span><br><span class="line">String regex = &quot;\\d+(\\.\\d+)?&quot;;  </span><br><span class="line">System.out.println(str.matches(regex));</span><br><span class="line">if(str.matches(regex)) &#123;</span><br><span class="line">System.out.println(Double.parseDouble(str));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong> 判断给定的字符串是否是一个IP地址（IPV4）<br>IP地址:192.168.1.1 每一个段最大是三个长度（1~3个长度都可以）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;192.168.1.1&quot;;</span><br><span class="line">//String regex = &quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;; </span><br><span class="line">String regex = &quot;(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;&quot;;  // 优化</span><br><span class="line">System.out.println(str.matches(regex));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong> 给定一个字符串，判断是否是日期格式，如果是则将其转换为Date型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;2019-03-09&quot;;</span><br><span class="line">String regex = &quot;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;&quot;;</span><br><span class="line">System.out.println(str.matches(regex));</span><br><span class="line">if(str.matches(regex)) &#123;</span><br><span class="line">Date date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(str);</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong>  判断电话号码，一般要编写电话号码以下几种格式都是满足的:</p><ul><li>格式一: 51283346     //一般长度是7~8位的数字是电话号码<ul><li>验证格式:  <code>\\d{7,8}</code></li></ul></li><li>格式二: 010-51283346   //区号一般是3~4位，而且区号的电话之间的 “-” 只有在出现区号时出现<ul><li>验证格式:  <code>(\\d{3,4}-)?\\d{7,8}</code></li></ul></li><li>格式三: (010)-51283346 //两边括号得同时存在，所以↓<ul><li>验证格式:  <code>((\\d{3,4}-)|(\\(\\d{3,4}\\)-))?\\d{7,8}</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;(010)-51283346&quot;;</span><br><span class="line">String regex = &quot;((\\d&#123;3,4&#125;-)|(\\(\\d&#123;3,4&#125;\\)-))?\\d&#123;7,8&#125;&quot;;</span><br><span class="line">System.out.println(str.matches(regex));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong> 验证email地址<br>要求格式一:  （最简单的拆分）<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-10-2.png" alt="2"></p><ul><li>验证格式: <code>\\w+@\\w+\\.\\w+</code></li></ul><p>要求格式二: （比较有难度更符合实际的拆分）<br>     用户名要求由字母、数字、<code>_</code> 、<code>.</code>、组成，其中必须以字母开头,可以以字母和数字结尾，用户名长度不超过30，最后的根域名只能够是 .com、.cn、.net、<code>com.cn</code>、 <code>net.cn</code> 、edu 、gov 、org 。<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-10-3.png" alt="3"></p><ul><li>验证格式:  <code>[a-zA-Z][a-zA-Z0-9_\\.]{0,28}[a-zA-Z0-9]@\\w+\\.(com|cn|net|com.cn|net.cn|edu|gov|org)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;hello.nihao123_123@ngp.cn&quot;;</span><br><span class="line">String regex = &quot;[a-zA-Z][a-zA-Z0-9_\\.]&#123;0,28&#125;[a-zA-Z0-9]@\\w+\\.(com|cn|net|com.cn|net.cn|edu|gov|org)&quot;;</span><br><span class="line">System.out.println(str.matches(regex));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     以上是几个典型的数据检验操作，而在以后会接触到类似检验的时候，一定可以要求自己直接写出。</p><h3 id="四-java-util-regex包支持-理解">四. java.util.regex包支持（理解）</h3><p>     在大多数情况下使用正则的时候采用String类完成，但是正则最原始的开发包是java.util.regex，这个包里面也提供有两个类。<br><strong>范例:</strong> Pattern类</p><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java(高级编程)比较器</title>
      <link href="/tech/d84d58a9.html"/>
      <url>/tech/d84d58a9.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-比较器-arrays类">一. 比较器 （Arrays类）</h3><p>     在之前一直使用 “java.util.Arrays.sort()” 可以实现数组的排序，而Arrays类就是java.util包中提供的一个工具类，这个工具类主要是完成数组有关的操作功能。<br>     在这个类里面存在二分查找法:<br>public static int binarySearch(byte[] a,byte key)<br>public static int binarySearch(数据类型[] a, 数据类型  key)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] data = new int[] &#123;1,5,6,2,3,4,9,8,7,10&#125;;</span><br><span class="line">java.util.Arrays.sort(data);// 排序</span><br><span class="line">System.out.println(Arrays.binarySearch(data, 9));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     Arrays类提供了数据比较: public static boolean equals(数据类型 [] a，数据类型[] a2)，只不过借用了equals()方法名称，与Object类的equals()屁关系都没有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] dataA = new int[] &#123;1,2,3&#125;;</span><br><span class="line">int[] dataB = new int[] &#123;1,2,3&#125;;</span><br><span class="line">System.out.println(Arrays.equals(dataA, dataB));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     要判断数组是否相同，需要顺序完全一致。</p><p>其他操作:</p><ul><li>填充数组: static voidfill(数据类型[] a, 数据类型 val);</li><li>将数组变为字符串输出: public static String toString(数据类型 [] a);</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] data = new int[10];</span><br><span class="line">Arrays.fill(data, 3);</span><br><span class="line">System.out.println(Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     以上实际上就属于数组的基本操作，只不过这样的操作在实际的开发里面很少出现。</p><h3 id="二-比较器-comparable-核心">二. 比较器 Comparable（核心）</h3><p>     下面来观察一下Arrays类中提供的数组排序方法:</p><blockquote><ul><li>对象数组排序: public static void sort(Object[] a);<br>     发现Arrays类里面可以直接利用sort()方法实现对象数组排序。</li></ul></blockquote><p>范例(错误):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">class Book &#123;</span><br><span class="line">private String title;</span><br><span class="line">private double price;</span><br><span class="line">public Book(String title, double price) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;书名：《&quot; + this.title + &quot;》，价格：&quot; + this.price + &quot;元。&quot; + &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Book books[] = new Book[] &#123; </span><br><span class="line">new Book(&quot;Java从入门到精通&quot;, 79.6),</span><br><span class="line">new Book(&quot;Oracle从入门到精通&quot;, 88.6),</span><br><span class="line">new Book(&quot;Android从入门到精通&quot;, 66.9) &#125;;</span><br><span class="line">Arrays.sort(books);</span><br><span class="line">System.out.println(Arrays.toString(books));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Exception in thread “main” java.lang.ClassCastException: cn.ngp.demo.Book cannot be cast to java.lang.Comparable<br>at java.util.ComparableTimSort.countRunAndMakeAscending(Unknown Source)<br>at java.util.ComparableTimSort.sort(Unknown Source)<br>at java.util.Arrays.sort(Unknown Source)<br>at cn.ngp.demo.TestDemo.main(TestDemo.java:21)</p></blockquote><p>     造成此类异常只有一个原因: 两个没有关系的类对象发生了强制性的转换。<br>     每一个对象实际上只保留有地址信息，地址里面是有内容的，所以如果是普通的int型数据要进行比较，只要判断大小就够了，但是如果是对象数组，里面包含的如果只是编码（地址）比较式没意义的 ，就拿上面的代码来讲，应该按照价格排序才是有意义的，所以此处必须明确设置出比较的规则:<br>     比较的规则就是由Comparable接口定义的，此接口定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     实际上String类就是Comparable接口的子类，之前使用的compareTo()方法就是比较的操作功能，如果用户现在针对于对象进行比较，建议compareTo()方法返回三类数据: 1(大于)、0(等于)、-1(小于)</p><p>范例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">class Book implements Comparable&lt;Book&gt; &#123;</span><br><span class="line">private String title;</span><br><span class="line">private double price;</span><br><span class="line">public Book(String title, double price) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;书名：《&quot; + this.title + &quot;》，价格：&quot; + this.price + &quot;元。&quot; + &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Book o) &#123;</span><br><span class="line">if (this.price &gt; o.price) &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else if (this.price &lt; o.price) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Book books[] = new Book[] &#123; </span><br><span class="line">new Book(&quot;Java从入门到精通&quot;, 79.6),</span><br><span class="line">new Book(&quot;Oracle从入门到精通&quot;, 88.6),</span><br><span class="line">new Book(&quot;Android从入门到精通&quot;, 66.9) &#125;;</span><br><span class="line">Arrays.sort(books);</span><br><span class="line">System.out.println(Arrays.toString(books));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     compareTo()方法由Arrays.sort()自动进行调用。</p><p><strong>总结:</strong></p><ul><li><strong>以后不管何种情况下，只要是一组对象要排序，对象所在的类一定要实现comparable接口。</strong></li></ul><h3 id="三-数据结构-binarytree-了解">三. 数据结构 —— BinaryTree（了解）</h3><p>     树是一种比链表更为复杂的概念应用，本质也属于动态对象数组，但是与链表不同在于，树的最大特征是可以针对于数据进行排序。<br>     树的操作原理: 选择第一个数据作为根节点，而后比根节点小的放在根节点的左子树（左节点），比根节点大的数据放在右子书（右节点），取得的时候按照中序遍历的方式取出（左-中-右）。<br>     在任何数据结构里面Node类的核心功能是保存真实数据以及配置节点关系。</p><p>范例: 实现二叉树</p><ul><li>定义出要使用的数据，数据所在的类实现comparable接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">class Book implements Comparable&lt;Book&gt; &#123;</span><br><span class="line">private String title;</span><br><span class="line">private double price;</span><br><span class="line">public Book(String title, double price) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;书名：《&quot; + this.title + &quot;》，价格：&quot; + this.price + &quot;元。&quot; + &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Book o) &#123;</span><br><span class="line">if (this.price &gt; o.price) &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else if (this.price &lt; o.price) &#123;//此处改为&quot;&gt;&quot;号，即变为升序输出</span><br><span class="line">return -1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">class BinaryTree&#123;</span><br><span class="line">private class Node&#123;</span><br><span class="line">private Comparable data;//排序的依据就是Comparable</span><br><span class="line">private Node left;//保存左节点</span><br><span class="line">private Node right;//保存右节点</span><br><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">public Node(Comparable data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void addNode(Node newNode) &#123;</span><br><span class="line">if(this.data.compareTo(newNode.data) &lt; 0) &#123;</span><br><span class="line">if(this.left == null) &#123;</span><br><span class="line">this.left = newNode;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.left.addNode(newNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if(this.right == null) &#123;</span><br><span class="line">this.right = newNode;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.right.addNode(newNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void toArrayNode() &#123;</span><br><span class="line">if(this.left != null) &#123;//表示有左节点</span><br><span class="line">this.left.toArrayNode();</span><br><span class="line">&#125;</span><br><span class="line">BinaryTree.this.retData[BinaryTree.this.foot ++] = this.data;</span><br><span class="line">if(this.right != null) &#123;</span><br><span class="line">this.right.toArrayNode();//右子树输出</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private Node root;//定义根节点</span><br><span class="line">private int count;  //保存元素个数</span><br><span class="line">private Object [] retData;</span><br><span class="line">private int foot;</span><br><span class="line">public void add(Object obj) &#123;//进行数据的追加</span><br><span class="line">Comparable com = (Comparable) obj;//必须编程comparable才可以实现Node保存</span><br><span class="line">Node newNode = new Node(com);//创建新的节点</span><br><span class="line">if(this.root == null) &#123;//现在不存在根节点</span><br><span class="line">this.root = newNode;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.root.addNode(newNode);</span><br><span class="line">&#125;</span><br><span class="line">this.count ++;</span><br><span class="line">&#125;</span><br><span class="line">public Object[] toArray() &#123;</span><br><span class="line">if(this.root == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">this.foot = 0;</span><br><span class="line">this.retData = new Object[this.count];</span><br><span class="line">this.root.toArrayNode();</span><br><span class="line">return  this.retData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">BinaryTree bt = new BinaryTree();</span><br><span class="line">bt.add(new Book(&quot;Java从入门到精通&quot;, 79.8));</span><br><span class="line">bt.add(new Book(&quot;JSP从入门到精通&quot;, 68.8));</span><br><span class="line">bt.add(new Book(&quot;Oracle从入门到精通&quot;, 98.8));</span><br><span class="line">bt.add(new Book(&quot;Android从入门到精通&quot;, 89.8));</span><br><span class="line">Object obj[] = bt.toArray();</span><br><span class="line">System.out.println(Arrays.toString(obj));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     可是这些内容，Java的类库都有了自己的实现，所以这个代码是基本功的问题。<br>     <strong>自己对以上代码的理解: 用二叉树的结构实现了一种插入式的链表</strong></p><h3 id="四-挽救的比较器-comparator-理解">四. 挽救的比较器 Comparator （理解）</h3><p>     由于初期的设计并没有安排此类对象数组的排序。而后又突然需要实现对象数组的排序，那么这个时候，在不能修改Book类定义的情况下是不可能使用Comparable接口的，为此，在Java里面为了解决这个问题，又出现了另一个比较器: java.util.Comparator ，原本在Comparator接口下有两个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Comparator&lt;T&gt;&#123;</span><br><span class="line">int compare(T o1, T o2)</span><br><span class="line">boolean equals(Object obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     而真正实现的只有compara()方法，需要单独准备出一个类来实现Comparator接口，这个类将作为指定类的排序类。</p><p><strong>范例:</strong> 定义排序的工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">class Book &#123;</span><br><span class="line">private String title;</span><br><span class="line">private double price;</span><br><span class="line">public Book() &#123;&#125;</span><br><span class="line">public Book(String title,double price) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">public String getTitle() &#123;</span><br><span class="line">return title;</span><br><span class="line">&#125;</span><br><span class="line">public void setTitle(String title) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">&#125;</span><br><span class="line">public double getPrice() &#123;</span><br><span class="line">return price;</span><br><span class="line">&#125;</span><br><span class="line">public void setPrice(double price) &#123;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;书名: &quot; + this.title + &quot;, 价格: &quot; + this.price + &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class BookComparator implements Comparator&lt;Book&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(Book o1, Book o2) &#123;</span><br><span class="line">if(o1.getPrice() &gt; o2.getPrice()) &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;else if(o1.getPrice() &lt; o2.getPrice()) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Book books [] = new Book [] &#123;</span><br><span class="line">new Book(&quot;Java从入门到精通&quot;, 79.8),</span><br><span class="line">new Book(&quot;JSP从入门到精通&quot;, 68.8),</span><br><span class="line">new Book(&quot;Oracle从入门到精通&quot;, 98.8),</span><br><span class="line">new Book(&quot;Android从入门到精通&quot;, 89.8)</span><br><span class="line">&#125;;</span><br><span class="line">//之前使用Comparable 接口的时候利用的是Arrays类中的sort()方法，</span><br><span class="line">//可是现在更换了一个接口之后，那么也可以使用另外一个被重载的sort()方法:</span><br><span class="line">//public static &lt;T&gt; void sort(T[] a,Comparator&lt;? super T&gt; c)</span><br><span class="line">Arrays.sort(books,new BookComparator());</span><br><span class="line">System.out.println(Arrays.toString(books));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     使用Comparator比较麻烦，因为要定义一个专门的排序类，而且调用排序的时候也要明确的指明一个排序规则类。<br><strong>面试题:</strong> 请解释Comparable 和Comparator的区别？（面试题: 请解释两种比较器的区别）</p><ul><li>如果对象数组要进行排序那么必须设置排序规则，可以使用Compatable或Comparator接口实现;</li><li>java.lang.Comparable 是在一个类定义的时候实现好的接口，这样本类的对象的数组就可以进行排序，在Comparable接口下定义有一个CompareTo()方法</li><li>java.util.Comparator 是专门定义一个指定类的比较规则，属于挽救的比较操作，里面有两个方法: public int compare()、public boolean equals()。</li></ul><p><strong>总结:</strong></p><ol><li>以后不管何种情况下只要是牵扯到对象数组的排序一定使用Comparable接口;</li><li>根据自己的实际情况来决定是否要熟练编写链表</li></ol><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java(高级编程)日期操作类</title>
      <link href="/tech/8f79a562.html"/>
      <url>/tech/8f79a562.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-date">一. Date</h3><p>    Data类的方法里面定义了如下几个重要方法:</p><ul><li>无参构造: public Data();</li><li>有参构造: public Data(long data)，接受long型数据;</li><li>转换为long型: public long getTime();</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">long time = System.currentTimeMillis();//取得当前的日期时间以long型返回</span><br><span class="line">Date date = new Date(time);</span><br><span class="line">System.out.println(date);//输出对象信息</span><br><span class="line">System.out.println(date.getTime());//输出对象信息</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    以后的代码编写过程中，依然需要以上的转换操作，尤其是getTime()方法</p><h3 id="二-日期格式化-simpledataformat-核心">二. 日期格式化: SimpleDataFormat（核心）</h3><p>    java.text是一个专门实现国际化程序的开发包，而SimpleDataFormat是一个专门处理格式化日期的工具类，即: 可以将Date型的对象转化为String的形式显示。而主要使用的是以下方法:</p><ul><li><strong>构造方法: public SimpleDateFormat(String pattern)，需要传递转换格式</strong></li><li><strong>将Data转换为String: public final String format(Data data);</strong></li><li><strong>将String转换为Date: public Date parse(String source) throws ParseException;</strong></li></ul><p>    现在的关键就在于转换格式上，对于常见的转换格式: 年(yyyy)、月(MM)、日(dd)、时(HH)、分(mm)、秒(ss)、毫秒(SSS)。<br><img src="C:%5CUsers%5CNGP%5CDesktop%5C1.png" alt=""><br><strong>范例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);</span><br><span class="line">String str = sdf.format(date); //将Date型变为String型</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    除了可以将日期变为字符串之外，也可以将字符串转换为日期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String str = &quot;2001-11-11 11:11:11.111&quot;;</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);</span><br><span class="line">Date date = sdf.parse(str); //将字符串变为日期型数据</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    在将字符串变为日期型数据的时候，如果日期型数据给的月不对，那么会自动进行进位。如果给定的字符串与要转换的格式不符合，那么机会出现异常。</p><p><strong>总结:关于数据类型的转换</strong><br>    <strong>在数据表的操作里面重点说过了有几个常用类型:VARCHAR2(String)、CLOB(String)、Number(Double、int)、Date(java.util.Date)。</strong></p><ul><li><strong>Date与String类之间的转换依靠的是SimpleDateFormat;</strong></li><li><strong>String与基本数据类型之间的转换依靠的是包装类与String.valueOf()方法;</strong></li><li><strong>long与Date转换依靠的是Date类提供的构造以及getTime()方法。</strong></li></ul><h3 id="三-calender">三. Calender</h3><p>    Date类和SimpleDate类两个往往是一起使用的，但是Calendar这个类主要是进行一些简单的日期计算的。<br>Calendar类定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Calendar</span><br><span class="line">extends Object</span><br><span class="line">implements Serializable, Cloneable, Comparable&lt;Calendar&gt;</span><br></pre></td></tr></table></figure><p>    这是一个抽象类。那么应该依靠子类进行对象的实例化操作。但是在这个类里面它提供有一个static方法，此方法返回的正是本类对象: public static Calendar getInstance()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Calendar cal = Calendar.getInstance(); //取得本类对象</span><br><span class="line">StringBuffer buf= new StringBuffer();</span><br><span class="line">buf.append(cal.get(Calendar.YEAR)).append(&quot;-&quot;);</span><br><span class="line">buf.append(cal.get(Calendar.MONTH) + 1).append(&quot;-&quot;);</span><br><span class="line">buf.append(cal.get(Calendar.DAY_OF_MONTH)).append(&quot; &quot;);</span><br><span class="line">buf.append(cal.get(Calendar.HOUR_OF_DAY)).append(&quot;:&quot;);</span><br><span class="line">buf.append(cal.get(Calendar.SECOND));</span><br><span class="line">System.out.println(buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     如果是日期计算，要比Date容易，如果使用Date要进行天的计算，那么就需要使用long完成了。</p><p>总结:</p><ol><li>以后数据库中的日期类型就使用 java.util.Date表示;</li><li>代码模型: SimpleDateFormat 类实现String与Date间的相互转换。</li></ol><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java(高级编程)数学操作类</title>
      <link href="/tech/cda39bd8.html"/>
      <url>/tech/cda39bd8.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-math类-了解">一. Math类 （了解）</h3><p>    Math就是一个专门进行数学计算的操作类，里面提供了一系列的数学计算方法。（数学开发则不够用，需要学习一个组件包）<br>    在Math类里面提供的一切方法都是static型的方法，因为Math类里面没有普通属性。<br>    在整个Math类里面实际上只有一个方法能够引起我们的注意:</p><ul><li>四舍五入: public static long round(double a)</li></ul><p>范例: 观察四舍五入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">System.out.println(Math.round(15.5));  //16</span><br><span class="line">System.out.println(Math.round(-15.5));  //-15</span><br><span class="line">System.out.println(Math.round(-15.51));  //-16</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-random类">二. Random类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.util.Random;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Random rand = new Random();</span><br><span class="line">for(int x = 0 ; x &lt; 10 ; x ++) &#123;</span><br><span class="line">System.out.print(rand.nextInt(10)+&quot;、&quot;);  //生成小于10的随机数</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-biginteger">三. BigInteger</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">BigInteger bigA = new BigInteger(&quot;11111111111111&quot;);</span><br><span class="line">BigInteger bigB = new BigInteger(&quot;2222222222&quot;);</span><br><span class="line">System.out.println(&quot;加法：&quot; + bigA.add(bigB));</span><br><span class="line">System.out.println(&quot;减法：&quot; + bigA.subtract(bigB));</span><br><span class="line">System.out.println(&quot;乘法：&quot; + bigA.multiply(bigB));</span><br><span class="line">System.out.println(&quot;除法：&quot; + bigA.divide(bigB));</span><br><span class="line">//数组里面只有两个元素: 第一个元素表示的是商，第二个元素表示的是余数</span><br><span class="line">BigInteger result[] = bigA.divideAndRemainder(bigB);</span><br><span class="line">System.out.println(&quot;商: &quot; + result[0] + &quot; , 余数: &quot; + result[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    在Java里面虽然提供了大数字的操作类，但是很多时候，我们项目开发可能对数字要求会更加的敏感，而这个时候Java本身所提供的数字类是帮助不大的。这个时候就只能去找第三方的数据开发包来实现了。</p><h3 id="四-大复点数-bigdecimal-重点">四. 大复点数 BigDecimal （重点）</h3><p>    BigInteger不能够保存小数，而BigDecimal可以保存小数数据。在BigDecimal类里面提供有如下的构造:</p><ul><li>构造一: public BigDecimal(String val);</li><li>构造二: public BigDecimal(double val);</li></ul><p>    与BigInteger一样，BigDecimal本身也支持基础的数学计算。课时使用BigDecimal还有一个非常重要的目的: 就是可以利用它来实现准确的四舍五入操作。<br>    之前使用过Math.round()实现过四舍五入操作，但是这个操作有一个问题，所有的小数都四舍五入了。那么假设一家公司的年收入按照亿进行计算，今年收入: 3.45678亿，按照Math.round()就少了4567.8万。</p><ul><li>除法操作: public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)<ul><li>BigDecimal divisor : 被除数;</li><li>int scale : 保留的小数位;</li><li>int roundingMode : 进位模式 （public static final int ROUND_HALF_UP）</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">class MyMath&#123;</span><br><span class="line">/**</span><br><span class="line"> * 实现准确的四舍五入操作</span><br><span class="line"> * @param num 要进行四舍五入操作的数字</span><br><span class="line"> * @param scale 要保存的小数位</span><br><span class="line"> * @return  处理后的四舍五入数据</span><br><span class="line"> */</span><br><span class="line">public static double round(double num,int scale) &#123;</span><br><span class="line">BigDecimal bigA = new BigDecimal(num);</span><br><span class="line">BigDecimal bigB = new BigDecimal(1);</span><br><span class="line">return bigA.divide(bigB,scale,BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(MyMath.round(15.5, 0));</span><br><span class="line">System.out.println(MyMath.round(-15.51, 0));</span><br><span class="line">System.out.println(MyMath.round(-15.5, 0));</span><br><span class="line">System.out.println(MyMath.round(4.5678, 2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    此类操作的功能在日后的开发之中一定要会使用，属于工具类的支持范畴。<br><strong>总结:</strong></p><ol><li>Math类重点要清楚round()方法的坑;</li><li>Random类生成随机数;</li><li>如果数据量大就使用BigInteger或BigDecimal，这两个类是Number的子类。</li></ol><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java(高级编程)基础类</title>
      <link href="/tech/20bb53a2.html"/>
      <url>/tech/20bb53a2.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-stringbuffer类">一. StringBuffer类</h3><h4 id="1-stringbuffer">1. StringBuffer</h4><p>[回顾]String类的特点:</p><ul><li>Stirng类对象有两种实例化方式:<ul><li>直接赋值: 只开辟一块堆内存空间，可以自动入池</li><li>构造方法: 开辟两块堆内存空间，不会自动入池，使用intern()手工入池;</li></ul></li><li>任何一个字符串都是String类的匿名对象;</li><li>字符串一旦声明则不可改变，可以改变的只是String类对象的引用。</li></ul><p>String类的内容不可改变，为此Java里面提供了另外一个类————StringBuffer类(里面的内容可以修改)<br>String类可以通过&quot;+&quot;进行字符串的连接操作，但是在StringBuffer类里面必须使用append()方法进行追加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//String类可以直接赋值实例化，但是StringBuffer类不行</span><br><span class="line">StringBuffer buf = new StringBuffer();</span><br><span class="line">buf.append(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;!!&quot;);</span><br><span class="line">change(buf);  //引用传递</span><br><span class="line">System.out.println(buf);</span><br><span class="line">&#125;</span><br><span class="line">public static void change(StringBuffer temp) &#123;</span><br><span class="line">temp.append(&quot;\n&quot;).append(&quot;Hello NGP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现StringBuffer类的内容是可以进行修改的，而String的内容是不可以修改的。</p><h4 id="2-charsequence接口">2. CharSequence接口</h4><p>String类 和 StringBuffer类 都是CharSequence接口的子类。而以后的开发之中，如果你看见某些方法的操作上出现的<br>是CharSequence接口，那么应该立刻清楚，只需要传递字符串即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">CharSequence seq = &quot;Hello&quot; ;</span><br><span class="line">System.out.println(seq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-string和stringbuffer类-不能够直接转换">3. String和StringBuffer类, 不能够直接转换</h4><p>虽然String和StringBuffer类有着共同的接口，但是这两个类对象之间如果要转换不能够直接转换。</p><h5 id="1-将-string变为stringbuffer类对象？">(1) 将 String变为StringBuffer类对象？</h5><p>方式一: 利用StringBuffer类的构造方法(public StringBuffer(String str))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">StringBuffer buf = new StringBuffer(&quot;Hello&quot;);  //String变为StringBuffer</span><br><span class="line">System.out.println(buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二: 利用append()方法(public StringBuffer append(String str))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">StringBuffer buf= new StringBuffer();</span><br><span class="line">buf.append(&quot;Hello&quot;);  //String变为StringBuffer</span><br><span class="line">System.out.println(buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-将stringbuffer变为string">(2) 将StringBuffer变为String</h5><p>方式一: 利用toString()方法可以将StringBuffer转化为String</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">StringBuffer buf= new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">String str = buf.toString();  //StringBuffer变为String</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以利用String类的构造方法(public String(StringBuffer buffer))实现StringBuffer变为String类</p><h5 id="3-string类-与-stringbuffer比较的方法">(3) String类 与 StringBuffer比较的方法</h5><p>String类里面有提供和StringBuffer比较的方法:public boolean contentEquals(StringBuffer sb)(大小写敏感)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">StringBuffer buf = new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">System.out.println(&quot;Hello&quot;.contentEquals(buf));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-stringbuffer类的方法-与string类互补">4. StringBuffer类的方法(与String类互补)</h4><h5 id="4-1-字符串反转-public-stringbuffer-reverse">4.1. 字符串反转:public StringBuffer reverse();</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">StringBuffer buf = new StringBuffer(&quot;12345&quot;);</span><br><span class="line">System.out.println(buf.reverse());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-指定位置添加数据：public-stringbuffer-insert-int-offset-数据类型-变量">4.2. 指定位置添加数据：public StringBuffer insert(int offset,数据类型 变量);</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">StringBuffer buf = new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">buf.insert(5, &quot; Java &quot;).insert(0, &quot; NGP &quot;);</span><br><span class="line">System.out.println(buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-删除部分数据-public-stringbuffer-delete-int-start-int-end">4.3. 删除部分数据:public StringBuffer delete(int start ,int end)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">StringBuffer buf = new StringBuffer(&quot;Hello World&quot;);</span><br><span class="line">System.out.println(buf.delete(0, 5));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-stringbuffer总结">5. StringBuffer总结</h4><p>从JDK1.5之后增加了一个新的字符串操作类: StringBuilder类，这个类定义结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuilder</span><br><span class="line">extends Object</span><br><span class="line">implements Serializable, CharSequence</span><br></pre></td></tr></table></figure><p>发现StringBuffer类与StringBuilder类在定义上非常的相似，几乎连方法也一样。<br>文档找不到区别，于是，找源代码</p><p><strong>面试题:</strong> 请解释String、StringBuffer、StringBuilder的区别？</p><ul><li>String的内容一旦声明不可改变，而StringBuffer和StringBuilder声明的内容可以改变。</li><li>StringBuffer类中提供的方法都是同步方法，属于安全的线程操作，二StringBuilder类提供的方法属于非线程安全的操作。</li></ul><blockquote><p>日后在开发之中，如果见到了字符串的应用，不需要思考95%使用的都是String类，只有在需要频繁修改的时候才会考虑到StringBuffer或者是StringBuilder类操作。</p></blockquote><p>总结:</p><ul><li>String类依然是最常用的字符串描述类，而 StringBuffer类由于出现时间较长，<br>所以使用要比StringBuilder多。(习惯问题)</li></ul><h3 id="二-runtime类-了解">二. Runtime类（了解）</h3><p>    在每一个JVM进程里面都会存在有一个Runtime类的对象，这个类的主要功能是取得一些与运行时有关的环境属性或者创建新的进程操作。<br>    在Runtime类定义的时候它的构造方法已经被私有化了，这就属于单例设计模式的应用，因为要保证在整个进程里面只有唯一的一个Runtime类的对象，所以在Runtime类里面提供有一个static的方法，这个方法可以取得Runtime类的实例化对象: public static Runtime getRuntime()。<br>    Runtime类是直接与本地运行有关的所有相关属性的集合，所以在Runtime类里面定义有如下方法:</p><ul><li>返回所有可用内存空间:public long totalMemory();</li><li>返回最大可用内存空间:public long maxMemory();</li><li>返回空余内存空间:public long freeMemory();</li></ul><p><strong>范例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Runtime run = Runtime.getRuntime();// 取得Runtime类实例化对象；</span><br><span class="line">System.out.println(&quot;1.MAX=  &quot; + run.maxMemory());</span><br><span class="line">System.out.println(&quot;1.TOTAL=&quot; + run.totalMemory());</span><br><span class="line">System.out.println(&quot;1.FREE= &quot; + run.freeMemory());</span><br><span class="line">String str = &quot; &quot;;</span><br><span class="line">for (int i = 0; i &lt; 2000; i++) &#123;</span><br><span class="line">str += i;// 制造垃圾</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;2.MAX=  &quot; + run.maxMemory());</span><br><span class="line">System.out.println(&quot;2.TOTAL=&quot; + run.totalMemory());</span><br><span class="line">System.out.println(&quot;2.FREE= &quot; + run.freeMemory());</span><br><span class="line"> run.gc();//释放垃圾空间</span><br><span class="line"> System.out.println(&quot;3.MAX=  &quot; + run.maxMemory());</span><br><span class="line"> System.out.println(&quot;3.TOTAL=&quot; + run.totalMemory());</span><br><span class="line"> System.out.println(&quot;3.FREE= &quot; + run.freeMemory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题:</strong> 请解释什么叫GC？ 如何处理？</p><ul><li>GC（Garbage Collector）垃圾收集器，指的是释放无用的内存空间。</li><li>GC 会由系统不定期进行自动的回收，或者调用Runtime类中的gc()方法手工回收.<br>实际上Runtime类还有一个更加有意思的功能，就是说它可以调用本机的可执行程序，冰且创建进程</li></ul><p><strong>范例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Runtime run=Runtime.getRuntime();</span><br><span class="line">Process pro=run.exec(&quot;mspaint.exe&quot;);//调用本机画图程序</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">pro.destroy();//销毁进程</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><ol><li>Runtime类使用了单例设计模式，必须通过内部的getRuntime()方法才可以取得Runtime类的对象;</li><li>Runtime类提供了gc()方法，可以用于手工释放内存。</li></ol><h3 id="三-system类-了解">三. System类（了解）</h3><p>    之前一直使用的&quot;System.out.println()&quot;就属于System类的操作功能，只不过这个功能由于牵扯到 IO 部分，所以留到以后继续讲解。</p><blockquote><p>    在System类里面之前也使用过一个System.arraycopy()方法实现数组拷贝，而这个方法的真是定义如下:</p><ul><li>数组拷贝: public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length);</li></ul><blockquote><p>    在System类里面定义有一个重要的方法:</p><ul><li>取得当前系统的时间:  public static long currentTimeMillis();</li></ul></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">String str = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; 2000; i++) &#123;</span><br><span class="line">str += i;</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;本次操作消耗的时间是：&quot; + (end - start));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    如果想要统计出所花费的毫秒时间，就用long型数据进行数学计算后得来。<br>    在System类里面定义了一个操作方法: public static  void gc()，这个gc方法并不是一个新定义的方法，而是连一个收尾的机会都没有，如果需要给对象一个收尾的机会，那么就可以考虑覆写Object类中的finalize()方法完成。</p><ul><li>finalize()方法: <strong>protected</strong> void finalize() throws <strong>Throwable</strong><ul><li>在对象回收是就算抛出了任何的异常，也不会影响到整个程序的正常执行。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">class Message &#123;</span><br><span class="line">public Message() &#123;</span><br><span class="line">System.out.println(&quot;灰太狼来啦&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void finalize() throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;灰太狼被赶走啦&quot;);</span><br><span class="line">throw new Exception(&quot;我还会回来的！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Message msg = new Message();  //会出现一些出生时的辅助操作</span><br><span class="line">msg = null; //会产生垃圾</span><br><span class="line">System.gc();  //手工处理垃圾</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    构造方法是留给对象初始化时使用的，而finalize()方法是留给对象回收前使用的。<br><strong>面试题:</strong> 请解释 final、finally、finalize 的区别？</p><ul><li>final: 关键字，定义不能被继承的类、不能被覆写的方法、常量;</li><li>finally: 关键字，异常的统一出口;</li><li>finalize: 方法，Object类提供的方法(protected void finalize() throws Throwable)，指的是对象回收前的收尾方法，技术出现了异常也不会导致程序中断执行。</li></ul><p>总结:</p><ol><li>System类可以使用currentTimeMillies()方法取得当前的系统时间;</li><li>System类中的gc()方法就直接调用了 “Runtime.getRuntime().gc()” 方法。</li></ol><h3 id="四-对象克隆">四. 对象克隆</h3><p>    对象克隆指的就是对象的复制操作，在Object类里面提供有一个专门的克隆方法:</p><ul><li>对象克隆: <strong>protected</strong> Object clone() throws <strong>CloneNotSupportedException</strong><br>    此方法上抛出一个 “CloneNotSupportedException” 异常，如果要使用对象克隆的类没有实现Cloneable接口，那么就会抛出此异常。但是Cloneale接口看不见方法，此为标识接口，表示一种操作能力。<br><strong>范例:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">class Book implements Cloneable&#123;  //此类的对象可以被克隆</span><br><span class="line">private String title;</span><br><span class="line">private double price;</span><br><span class="line"> </span><br><span class="line">public Book(String title, double price) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">public void setTitle(String title) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;书名《&quot; + this.title + &quot;》价格：&quot; + this.price + &quot;元。&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//由于此类需要对象克隆操作，所以才需要进行对象的覆写</span><br><span class="line">@Override</span><br><span class="line">public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return super.clone(); //调用父类的克隆方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Book booka = new Book(&quot;Java开发&quot;, 88.6);</span><br><span class="line">Book bookb = (Book) booka.clone();</span><br><span class="line">bookb.setTitle(&quot;C++开发&quot;);</span><br><span class="line">System.out.println(booka);</span><br><span class="line">System.out.println(bookb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    对象克隆的操作，理论价值大于实际价值，因为在实际的工作里面很少会用到对象克隆操作。重点在于标识接口上，以后依然会见到没有方法的接口，这样的接口就好比通行证一样，表示的是能力。<br><strong>总结:</strong><br>    标识接口: 没有任何方法定义，只是一个空接口的声明。</p><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程(高级编程)2-19  缺7，10,11,12 -Java10</title>
      <link href="/tech/3500f2c5.html"/>
      <url>/tech/3500f2c5.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-多线程的实现">一. 多线程的实现.</h3><h4 id="1-thread">1. Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="comment">//线程操作主类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; <span class="comment">//这就是一个多线程的操作类</span></span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.title = title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//覆写run()方法,作为线程的主体操作方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.title + <span class="string">"-&gt;"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; <span class="comment">//主类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line">MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程2"</span>);</span><br><span class="line">MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">"线程3"</span>);</span><br><span class="line">mt1.start();</span><br><span class="line">mt2.start();</span><br><span class="line">mt3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">疑问: 为什么多线程必须使用start()而不是run()？</span></span><br><span class="line"><span class="comment">1 Thread类的方法里面存在有一个"IllegalThreadStateException"异常,并且属于RuntimeException.</span></span><br><span class="line"><span class="comment">    如果一个线程重复启动就会抛出此异常</span></span><br><span class="line"><span class="comment">2 start()方法里面要调用start0()方法，而且此方法的结构与抽象方法类似，使用了native声明，在Java的</span></span><br><span class="line"><span class="comment">    开发里面有一门技术成为JNI技术(JavaNative Interface)，这么技术的特点: 是使Java调用本机操作系统提供的函数。</span></span><br><span class="line"><span class="comment">    但是这样的技术有一个缺点，不能够离开特定的操作系统。</span></span><br><span class="line"><span class="comment">    如果要想线程能够执行，需要操作系统来进行资源分配，所以此操作严格来讲主要是由JVM负责根据不同的操作的操作系统</span></span><br><span class="line"><span class="comment">而实现的。</span></span><br><span class="line"><span class="comment">    即: 使用Thread类的start()方法不仅仅要启动多线程的执行代码，还要去根据不同的操作系统来进行资源的分配。</span></span><br><span class="line"><span class="comment">    所以要用start()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-runnanle">2. Runnanle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="comment">//线程操作主类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">//这就是一个多线程的操作类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.title = title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//覆写run()方法,作为线程的主体操作方法</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 50; i++) &#123;</span></span><br><span class="line"><span class="comment">//System.out.println(this.title + "-&gt;" + i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.title + <span class="string">"  ticket = "</span> + <span class="keyword">this</span>.ticket -- );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; <span class="comment">//主类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//MyThread mt1 = new MyThread("线程1");</span></span><br><span class="line"><span class="comment">//MyThread mt2 = new MyThread("线程2");</span></span><br><span class="line"><span class="comment">//MyThread mt3 = new MyThread("线程3");</span></span><br><span class="line"><span class="comment">//new Thread(mt1).start();</span></span><br><span class="line"><span class="comment">//new Thread(mt2).start();</span></span><br><span class="line"><span class="comment">//new Thread(mt3).start();</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(mt).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题: 请解释Thread类于Runnable接口实现多线程的区别？（请解释多线程两种实现方法的区别？）</p><ul><li>Thread类是Runnable接口的子类，使用Runable接口实现多线程可以避免单继承局限</li><li>Runnable接口实现的多线程可以比Thread类实现的多线程更加清楚的描述数据共享的概念</li></ul><p>Runnable是如何避免java单继承带来的局限性的？</p><ul><li>（接口实现和类继承的角度来说）如果你想写一个类C，但这个类C已经继承了一个类A，此时，你又想让C实现多线程。用继承Thread类的方式不行了。（因为单继承的局限性）<br>此时，只能用Runnable接口。<br>Runnable接口就是为了解决这种情境出现的。</li></ul><h4 id="3-callable">3. Callable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.title = title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.title + <span class="string">" ,买票  ticket = "</span> + <span class="keyword">this</span>.ticket -- );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"票已卖光"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line">MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程2"</span>);</span><br><span class="line">FutureTask&lt;String&gt; task1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(mt1);<span class="comment">//目的是为了取得call()返回结果</span></span><br><span class="line">FutureTask&lt;String&gt; task2 = <span class="keyword">new</span> FutureTask&lt;String&gt;(mt2);</span><br><span class="line"><span class="comment">//FutureTask是Runnable接口子类,所以可以使用Thread类的构造来接受task对象</span></span><br><span class="line"><span class="keyword">new</span> Thread(task1).start();<span class="comment">//启动多线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(task2).start();</span><br><span class="line"><span class="comment">//多线程执行完毕之后可以取得内容，依靠Future中的get()方法完成</span></span><br><span class="line">System.out.println(<span class="string">"A线程的返回结果: "</span> +task1.get());</span><br><span class="line">System.out.println(<span class="string">"B线程的返回结果: "</span> +task2.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 总结:</span></span><br><span class="line"><span class="comment"> * 1. 对于多线程的实现，重点在于Runnable接口与Thread类启动的配合上;</span></span><br><span class="line"><span class="comment"> * 2. 对于JDK1.5新特性，了解就行，知道区别就在于返回结果上</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><h3 id="二-线程的基本使用方法">二. 线程的基本使用方法</h3><h4 id="1-命名与取得">1. 命名与取得</h4><p>多线程的运行状态是不确定的，那么程序的开发之中为了可以获取到一些需要使用到是线程，就只能够依靠线程的名字来进行操作。所以线程的名字是一个至关重要的概念，这样在Thread类之中就提供有线程名称的处理:</p><ul><li>构造方法：public Thread(Runnable target,String name);<br>设置名字：public final void setName(String name);<br>取得名字：public final void getName（）;<br>取得当前线程对象:public static Thread currendThread（）;</li></ul><p>对于线程对象的获得是不可能只是依靠一个this来完成的，因为状态不可控，但是有一点是明确的，所有的线程对象一定要执行run()方法，那么这个时候可以考虑获取当前线程，在Thread类里面提供有获取当前线程的方法:</p><ul><li>获取当前线程: public static Thread currentThread()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"线程A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt).start();<span class="comment">//Thread-0  </span></span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"线程B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt).start();<span class="comment">//Thread-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化Thread类对象的时候没有为其设置名字，会自动编号和命名，这种自动的属性命名主要是依靠了static属性完成的。Thread类里面定义有如下操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong> 观察一个程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"线程对象"</span>).start();</span><br><span class="line">mt.run(); <span class="comment">//直接调用了run()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果:</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">线程对象</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>通过此时的代码可以发现当使用了 “mt.run()” 直接在主方法之中调用线程类对象中的run()方法所获得的线程对象的名字为 “main”，所以得出一个结论: **主方法也是一个线程。**那么问题来了，所有的线程都是在进程上划分，那么进程在哪里?</p><p><strong>范例:</strong> 新建一个 <code>Test.java</code> 文件，黏贴以下代码，用cmd编译、运行。:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Long x = <span class="number">0L</span>; x &lt; Interger.MAX_VALUE; x ++) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Win10)任务管理器 → 详细信息 → 将会看到java.exe运行中，cmd中按下Ctrl+C，中断程序，java.exe即消失</p><p>(win7)任务管理器 → 进程 → 将会看到java.exe运行中，cmd中按下Ctrl+C，中断程序，java.exe即消失</p><p>每当使用java命令执行程序的时候就表示启动了一个JVM的进程，一台电脑上可以启动若干个JVM进程，所以每一个JVM的进程都会有各自的线程。</p><p>在任何开发之中，主线程可以创建若干个子线程，创建子线程的目的是可以将一些复杂逻辑或者比较耗时的逻辑交给子线程处理;</p><p><strong>范例:</strong> 子线程处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"1. 执行操作任务一。"</span>);</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; Integer.MAX_VALUE; x++) &#123;</span><br><span class="line">temp += x ;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"2. 执行操作任务二。"</span>);</span><br><span class="line">System.out.println(<span class="string">"n. 执行操作任务N。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就会耽搁一下，此时就用lambda，用子线程处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"1. 执行操作任务一。"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; &#123;<span class="comment">//子线程负责统计</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; Integer.MAX_VALUE; x++) &#123;</span><br><span class="line">temp += x ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;); </span><br><span class="line">System.out.println(<span class="string">"2. 执行操作任务二。"</span>);</span><br><span class="line">System.out.println(<span class="string">"n. 执行操作任务N。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程负责处理整体流程，而子线程负责耗时操作。</p><p>问:** 每一个JVM进程启动的时候至少启动几个线程？</p><ul><li>mian线程: 程序的主要执行，以及启动子线程;</li><li>gc线程: 负责垃圾收集</li></ul><h4 id="2-线程的休眠">2. 线程的休眠</h4><p>如果说现在希望某一个线程可以暂缓处理，那么久可以使用休眠的处理，在Thread类之中定义的休眠的方法如下:</p><ul><li>休眠: public static void sleep(long millis) throws InterruptedException</li><li>休眠: public static void sleep(long millis,int nanos) throws InterruptedException</li></ul><p>在进行休眠的时候，有可能会产生中断异常 “InterruptException”，中断异常属于Exception的子类，所以必须处理。</p><p><strong>范例:</strong> 观察休眠处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x ++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"、x = "</span> + x);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);<span class="comment">// 暂缓执行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"线程对象"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>休眠的主要特点是可以实现线程的唤醒，以继续进行后续的处理。但是需要注意的是，如果现在有多个线程对象，那么休眠也是有先后顺序的。</p><p>**范例:**产生多个线程对象进行休眠处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Runnable run = ()-&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x ++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"、x = "</span> + x);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);<span class="comment">// 暂缓执行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; <span class="number">5</span> ; num ++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(run,<span class="string">"线程对象 - "</span> + num).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时将产生五个线程对象，并且这五个线程对象执行的方法体是相同的。此时从程序执行的感觉上来讲，好像是若干个线程一起进行了休眠，而后一起进行了自动唤醒，但是实际上是有差别的。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-03-1-219.png" alt="2"></p><blockquote><p>p.s. 所有对象一起进入run方法，但真正执行的时候还是有先有后的。</p><p>提示文字也是有先有后</p><p>休眠操作也是有先有后</p><p>由于操作时间非常短，所以所有的操作看起来就是一起执行。当然不乏处理很快，有一起的情况出现</p><p>总结: 大部分而言，线程的操作方法里面，由于它执行的顺序或者说优先级有先后关系，所以它们执行的时候并不是同时休眠，也不是同时唤醒，它中间是有适当的延迟操作的。</p><p>这句话，将是继续后面同步分析的关键所在。</p></blockquote><h4 id="3-线程中断">3. 线程中断</h4><p>在之前发现线程的休眠提供有一个中断异常，实际上就证明线程的休眠是可以被打断的，而这种打断肯定是由其他线程完成的，在Thread类里面提供有这种中断执行的处理方法:</p><ul><li>判断线程是否被中断: public boolean isInterrupted()</li><li>中断线程执行: public void interrupt()</li></ul><p><strong>范例:</strong> 观察线程的中断处理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"*** 连续战斗72个小时，我要睡觉。"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>); <span class="comment">//预计准备休眠10秒</span></span><br><span class="line">System.out.println(<span class="string">"*** 睡足了，可以继续战斗了"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"wo kao 才几点?"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;) ;</span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span>(!thread.isInterrupted()) &#123;  <span class="comment">//该线程中断了吗?</span></span><br><span class="line">System.out.println(<span class="string">"起床了，战斗，战斗，不要怂，起来嗨"</span>);</span><br><span class="line">thread.interrupt();  <span class="comment">//中断执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理。</p><h4 id="5-线程强制运行">5.线程强制运行</h4><p>所谓的线程的强制执行指的是当满足于某一些条件之后，某一个线程对象将可以一直独占资源，一直到该线程的程序执行结束。</p><p><strong>范例:</strong> 观察一个没有强制执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span> ; x ++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"执行、 x = "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"玩耍的线程"</span>) ;</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x ++) &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"【霸道的main线程】 number = "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候主线程和子线程都在交替执行着，但是如果说现在你希望主线程独占执行。那么就可以利用Thread类中的方法:</p><ul><li>强制执行: public final void join() throws InterruptedException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread mainThread = Thread.currentThread() ; <span class="comment">//获得主线程</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span> ; x ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">3</span>) &#123; <span class="comment">//现在霸道的线程来了</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mainThread.join();<span class="comment">//霸道的线程要先处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"执行、 x = "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"玩耍的线程"</span>) ;</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x ++) &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"【霸道的main线程】 number = "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行线程强制执行的时候一定要获取强制执行的线程对象之后才可以执行Join的调用。</p><h4 id="6-线程礼让">6. 线程礼让</h4><p>线程的礼让指的是先将资源让出去让别的线程先执行。线程的礼让可以使用Thread中提供的方法:</p><ul><li>礼让: public static void yield()</li></ul><p><strong>范例:</strong>  使用礼让操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span> ; x ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(x % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">Thread.yield();  <span class="comment">//线程礼让</span></span><br><span class="line">System.out.println(<span class="string">"### 玩耍的线程礼让执行 ###"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"执行、 x = "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">"玩耍的线程"</span>) ;</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x ++) &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"【霸道的main线程】 number = "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>礼让执行的时候每一次调用yield()方法都只会礼让一次当前的资源。</p><h4 id="7-线程优先级">7. 线程优先级</h4><p>从理论上来讲线程的优先级越高越有可能先执行(越有可能先抢占到资源)。在Thread类里面针对于优先级的操作提供有如下的两个处理方法:</p><ul><li>设置优先级: public final void setPriority(int newPriority)</li><li>获取优先级: public final int getPriority()</li></ul><p>在进行优先级定义的时候都是通过int型的数字来完成的，而对于此数字的选择在Thread类里面就定义有三个常量:</p><ul><li>最高优先级: MAX_PRIORITY、10</li><li>中等优先级: NORM_PRIORITY、5</li><li>最低优先级: MIN_PRIORITY、 1</li></ul><p><strong>范例:</strong> 观察优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Runnable run = () -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x ++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"执行。"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">Thread threadA = <span class="keyword">new</span> Thread(run,<span class="string">"线程对象A"</span>);</span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread(run,<span class="string">"线程对象B"</span>);</span><br><span class="line">Thread threadC = <span class="keyword">new</span> Thread(run,<span class="string">"线程对象C"</span>);</span><br><span class="line">threadA.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">threadB.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">threadC.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">threadA.start(); </span><br><span class="line">threadB.start(); </span><br><span class="line">threadC.start(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主方法是一个主线程，那么主线程的优先级呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程属于中等优先级，而默认创建的线程也是中等优先级。</p><blockquote><p>p.s. 优先级高的只是有可能先执行，而不是绝对先执行</p></blockquote><h3 id="三-线程的同步与死锁-笔记做到这了">三. 线程的同步与死锁   笔记做到这了 ↑</h3><p>再多线程的处理之中，可以利用Runnable描述多个线程操作的资源，而Thread描述每一个线程对象，于是当多个线程访问同一资源的时候如果处理不当就会产生数据的错误操作</p><h4 id="1-问题的引出">1. 问题的引出</h4><p>下面编写一个简单的卖票程序，将创建若干个线程对象实现卖票的处理操作。</p><p><strong>范例:</strong> 实现卖票操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span> ;  <span class="comment">//总票数为10张</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票 = "</span> + <span class="keyword">this</span>.ticket -- );</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"***** 票已经卖光了 *****"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子C"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的程序将穿件三个线程对象，并且这三个线程对象将进行10张票的出售。此时的程序在进行卖票处理的时候并没有任何的问题(假象)，下面可以，模拟一下买票中的延迟操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span> ;  <span class="comment">//总票数为10张</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);<span class="comment">//模拟网络延迟</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票 = "</span> + <span class="keyword">this</span>.ticket -- );</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"***** 票已经卖光了 *****"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子C"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候追加了延迟，问题就暴露出来了，而实际上这个问题一直都在。</p><p>执行之后出现负数，这就叫不同步<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-03-03-2-219.png" alt="2"></p><h4 id="2-同步处理">2. 同步处理</h4><h5 id="2-1-同步代码块">2.1 同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span> ;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//同步代码块</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">20</span> ; x ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票 = "</span> + <span class="keyword">this</span>.ticket -- );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子C"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子D"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-同步方法">2.2 同步方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">20</span> ;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">30</span> ; x ++) &#123;</span><br><span class="line"><span class="keyword">this</span>.sale();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123; <span class="comment">//同步方法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票 = "</span> + <span class="keyword">this</span>.ticket -- );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子C"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt, <span class="string">"票贩子D"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><ul><li>同步操作与异步操作相比，异步操作的执行速度要高于同步操作，但是同步操作时数据的安全性较高，属于安全的线程操作。</li><li>synchronized(同步的)在Java中很常用。</li></ul><h4 id="3-死锁">3.  死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A说: 把你的本给我，我给你笔，否则不给！"</span>);</span><br><span class="line">b.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A说: 得到了本，付出了笔，还是什么都干不了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"B说: 把你的笔给我，我给你本，否则不给！"</span>);</span><br><span class="line">a.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"B说: 得到了笔，付出了本，还是什么都干不了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="comment">//主类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> TestDemo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">b.say(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a.say(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题:</strong> 请解释多个线程访问同一资源时需要考虑到需要考虑到哪些情况？有可能带来哪些问题？</p><ul><li><p>多个编程访问同一资源时一定要处理好同步，可以使用同步代码块或同步方法来解决。</p><ul><li>同步代码块: synchronized(锁定对象) {代码}</li><li>同步方法: public synchronized 返回值 方法名称() {代码}</li></ul></li><li><p>但是过多的同步使用，有可能造成死锁</p></li></ul><p>总结:</p><ul><li>最简单的理解同步和异步的操作那么就可以通过 synchronized 来实现;</li><li>死锁是一种不定的状态.</li></ul><h3 id="四-综合实战-生产者与消费者">四. 综合实战: 生产者与消费者</h3><h4 id="1-问题引出">1. 问题引出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">class Info&#123;</span><br><span class="line">private String title;</span><br><span class="line">private String content;</span><br><span class="line">public void setTitle(String title) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">&#125;</span><br><span class="line">public String getTitle() &#123;</span><br><span class="line">return title;</span><br><span class="line">&#125;</span><br><span class="line">public void setContent(String content) &#123;</span><br><span class="line">this.content = content;</span><br><span class="line">&#125;</span><br><span class="line">public String getContent() &#123;</span><br><span class="line">return content;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Productor implements Runnable&#123;</span><br><span class="line">private Info info;</span><br><span class="line">public Productor(Info info) &#123;</span><br><span class="line">this.info = info;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 100 ; x ++) &#123;</span><br><span class="line">if (x % 2 == 0) &#123;//偶数</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">this.info.setTitle(&quot;我我我&quot;);</span><br><span class="line">this.info.setContent(&quot;你你你&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">this.info.setTitle(&quot;一一一一&quot;);</span><br><span class="line">this.info.setContent(&quot;二二二二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(this.info.getTitle());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Customer implements Runnable&#123;</span><br><span class="line">private Info info;</span><br><span class="line">public Customer(Info info) &#123;</span><br><span class="line">this.info = info;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 100 ; x ++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(this.info.getTitle()+&quot;-&quot;+this.info.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Info info = new Info();</span><br><span class="line">new Thread(new Productor(info)).start();</span><br><span class="line">new Thread(new Customer(info)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在实际上通过以上的代码可以发现两个严重的问题:</p><ul><li>数据错位， 发现不再是一个所需要的完整数据</li><li>数据重复取，数据重复设置</li></ul><h4 id="2-同步处理-v2">2. 同步处理</h4><p>数据的错位完全是因为非同步的操作所造成的，所以应该使用同步处理。<br>因为取和设置是两个不同的操作，<br>所以要想进行同步控制，那么就需要将其定义在一个类里面完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">class Info&#123;</span><br><span class="line">private String title;</span><br><span class="line">private String content;</span><br><span class="line">public synchronized void set(String title,String content) &#123;</span><br><span class="line">this.title = title;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(200);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">this.content = content;</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void get() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(this.title + &quot;-&quot; + this.content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Productor implements Runnable&#123;</span><br><span class="line">private Info info;</span><br><span class="line">public Productor(Info info) &#123;</span><br><span class="line">this.info = info;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 100 ; x ++) &#123;</span><br><span class="line">if (x % 2 == 0) &#123;//偶数</span><br><span class="line">this.info.set(&quot;我我我&quot;,&quot;你你你&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.info.set(&quot;一一一一&quot;,&quot;二二二二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Customer implements Runnable&#123;</span><br><span class="line">private Info info;</span><br><span class="line">public Customer(Info info) &#123;</span><br><span class="line">this.info = info;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 100 ; x ++) &#123;</span><br><span class="line">this.info.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Info info = new Info();</span><br><span class="line">new Thread(new Productor(info)).start();</span><br><span class="line">new Thread(new Customer(info)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时数据错位的问题得到了很好的解决，但是重复操作问题更加严重了。</p><h4 id="3-等待与唤醒机制-利用object类解决重复操作">3. 等待与唤醒机制(利用Object类解决重复操作)</h4><p>要想解决重复操作问题，必须加入等待与唤醒机制，在Object类里面提供有专门的处理方法。</p><ul><li>等待: public final void wait() throws InterrupedException;</li><li>唤醒第一个等待线程: public final void notify();</li><li>唤醒全部等待线程，那个优先级高就先执行: public final void notifyAll();</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">class Info&#123;</span><br><span class="line">private String title;</span><br><span class="line">private String content;</span><br><span class="line">private boolean flag =true;</span><br><span class="line">// flag = true : 表示可以生产，但是不可以取走</span><br><span class="line">// flag = false: 表示可以取走，但是不可以生产</span><br><span class="line">public synchronized void set(String title,String content) &#123;</span><br><span class="line">// 重复进入到了set()方法里面，发现不能够生产，所以要等待</span><br><span class="line">if(this.flag == false) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">super.wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.title = title;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(200);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">this.content = content;</span><br><span class="line">this.flag = false ; //修改生产标记</span><br><span class="line">super.notify(); //唤醒其他等待线程</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void get() &#123;</span><br><span class="line">if(this.flag == true) &#123;  //还没生产呢</span><br><span class="line">try &#123;</span><br><span class="line">super.wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(this.title + &quot;-&quot; + this.content);</span><br><span class="line">this.flag = true;  </span><br><span class="line">super.notify();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Productor implements Runnable&#123;</span><br><span class="line">private Info info;</span><br><span class="line">public Productor(Info info) &#123;</span><br><span class="line">this.info = info;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 100 ; x ++) &#123;</span><br><span class="line">if (x % 2 == 0) &#123;//偶数</span><br><span class="line">this.info.set(&quot;我我我&quot;,&quot;你你你&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.info.set(&quot;一一一一&quot;,&quot;二二二二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Customer implements Runnable&#123;</span><br><span class="line">private Info info;</span><br><span class="line">public Customer(Info info) &#123;</span><br><span class="line">this.info = info;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 100 ; x ++) &#123;</span><br><span class="line">this.info.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123; //主类</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Info info = new Info();</span><br><span class="line">new Thread(new Productor(info)).start();</span><br><span class="line">new Thread(new Customer(info)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题解决了，但是运行速度慢。</strong></p><p><strong>题:</strong> 请解释sleep()和wait()的区别?</p><ul><li>sleep()是Thread类定义的方法，wait()是Object类定义的方法;</li><li>sleep()可以设置休眠时间，时间一到自动唤醒，而wait()需要等待notify()进行唤醒。</li></ul><p>总结:</p><ul><li>这是一个非常经典的多线程处理模型。所以掌握它属于你个人能力的一个提升，同时可以更加理解Object类的作用。</li></ul><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Warframe(国际服) 技巧笔记</title>
      <link href="/others/bb2947a8.html"/>
      <url>/others/bb2947a8.html</url>
      
        <content type="html"><![CDATA[<p>护甲减伤的伤害调整因数 = 1 / （1 + 护甲值 * 护甲值调整因数 / 300）</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> warframe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Warframe(国际服) 个人备忘录</title>
      <link href="/others/6d44b99c.html"/>
      <url>/others/6d44b99c.html</url>
      
        <content type="html"><![CDATA[<p>一、 游戏下载、更新、稳定撒欢</p><p>以下四点，去一个好点的网咖，都能解决，只是。这个网咖价格你能接受的话一般没有预装Warframe(预装的呵呵，目前附近只见过一个网咖，6-10元一小时，比勉强能运行这游戏的网咖的贵5成左右)</p><p>而且你要在网吧玩的话，大概率情况，你至少需要买一个300多希捷/东芝 的移动硬盘（因为这个游戏25g，下载会花费相当长的无聊时间），感觉比u盘耐用，且不容易丢还能有别的用途。</p><p>而且后期打boss，很大概率要去网吧，因为网速稳定，ping不高，不会掉线（也就是游戏黑话→七字真言：网络连接无响应）</p><ol><li><p>在家里玩需要高性能电脑 长期玩耍这游戏(也就是在宿舍或家里玩)，需要5000元以上笔记本or台式电脑（+最好有一根稳定的网线，据说电信的延迟很低），3000+的几乎可以不用考虑了。我宿舍电脑7000+只敢开最低特效，才能全屏正常撒欢。。∠( ᐛ 」∠)_ 很多网咖玩起来一卡一卡的，不能全屏。。</p></li><li><p>注册steam和warframe，然后第一个问题来了，登不上。。。这个时候 连手机热点 登陆有大概率可以解决，然而还是有可能解决不了。 又或者 买vpn，然而对主体玩家学生党而言，一周只玩几个小时，买vpn不划算。。。</p></li><li><p>登陆进去很有可能第一个问题就是ping高。毕竟不是每个人都有条件用光纤(得看学校的基础设施，然鹅 学校一般是赛尔网，ping高到，只能当单机玩，买个cmcc web连可以做到勉强能组队，就是现在买不太到了)</p></li></ol><p>单机的话，就失去了很多乐趣。</p><p>4.更新游戏（25g的游戏，更新还需要一定的技巧）。。。。</p><p>大更新(&gt;2g)： 先去网吧！！！然后，删除，下载整包。下载之后再更新时(这时一般就只有200mb大小需要更新)，把设置里面的 勾 全取消(或者只取消分包下载和多线程下载)，可能会更快地更新。。。。</p><p>小更新： 只要记得更新游戏时，把设置里 钩 全取消就好了。</p><p>P.S. 网吧下载20G完整版只需0.5（10MB/s）~1个小时.然后更新个20MB（30分钟？）→GG</p><p>———————我是一根分割线———————————</p><p>二、 辅助网站</p><p>① 看 地球/平原 时间，看 奸商，看裂缝 <a href="https://rm.0-0.at/">https://rm.0-0.at/</a> [裂罅之镜]</p><p>② 看 目前赏金详情</p><p><a href="https://wfa.richasy.cn/#/info">https://wfa.richasy.cn/#/info</a> [Warframe Alerting 网页版](顺带 可以看看警报什么的)</p><p>③手机WF资讯APP</p><p><a href="https://www.coolapk.com/game/com.hefty.warframe">https://www.coolapk.com/game/com.hefty.warframe</a>[Warframe Ordis]</p><p>（这只是介绍 ，各大安卓手机app应用市场可直接搜索下载，功能很全很方便）</p><p>ios手机 推荐 [WF国际版]</p><p>④查不会的 名词/mod卡/任务</p><p><a href="http://warframe.huijiwiki.com/wiki/%E9%A6%96%E9%A1%B5%5B%E4%B8%AD%E6%96%87%E7%81%B0%E6%9C%BAwiki%5D">http://warframe.huijiwiki.com/wiki/首页[中文灰机wiki]</a></p><p>⑤ 组队频道的简称不到什么意思 请百度。 比如: 百度→[warframe 4k] 然后进相应的贴吧看看就知道个大概了。</p><p>⑥查配卡 bilibili→ [Warframe 女枪] 或者 [Warframe 女枪 配卡] 就出来了。</p><p>⑦看mod/p武器战甲/赋能(除了紫卡几乎所有东西的价格) 的价格 →</p><p><a href="https://warframe.market/">https://warframe.market/</a> [warframe market最大的warframe交易网站]</p><p>食用教程: 买家→https://tieba.baidu.com/p/4693662060</p><p>⑧查紫卡价格 只推荐Win10付费软件 <a href="%EF%BF%A511">Warframe Alerting Prime</a></p><p>P.S. 和国际友人交易需要一定的英文知识，用翻译软件尬聊也行。。。就是翻译不一定准确</p><p>三、玩了一定时间后不知道干什么</p><p>开图、刷段位经验（普通甲 P甲 全做了、氏族武器 装备 战甲 全做了）、玩没玩过的游戏模式（仲裁、圣殿、4k等）、刷出最好看的猫 和 狗、玩交易频道（和WarframeMarket）想办法长期赚白金、玩紫卡（特别消耗时间和精力，还容易被坑）</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> warframe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研备忘录</title>
      <link href="/tech/4eda24db.html"/>
      <url>/tech/4eda24db.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-考研资料-张宇只能当精神食粮乐一乐-其他看多看看-自己体验一下-多刷点盗版就好">一 考研资料 张宇只能当精神食粮乐一乐，其他看多看看，自己体验一下，多刷点盗版就好。</h2><h2 id="二-在知乎-考研复试真的很黑吗？-某匿名985高校导师得到的绝对重点：">二. 在知乎（考研复试真的很黑吗？）某匿名985高校导师得到的绝对重点：</h2><h3 id="1-突出优势">1. 突出优势</h3><ul><li>平时成绩不怎么样的话，就要有突出优势：和导师方向相关的知识学得很好，或者编程能力很好。<br>尤其是挂科多的情况，就要用专业课成绩以及复试成绩来证明重要的科目不仅仅是补好了，而且学得很好。</li></ul><h3 id="2-进初试提前联系导师">2. 进初试提前联系导师</h3><ul><li>进初试以后，了解导师还有没有名额，以及提前和导师一对一“复试”，很重要。当然尽可能多了解导师也是为这个提前面试以及后面正式的面试很重要。</li></ul><h3 id="3">3.</h3>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java(面向对象)泛型(generic)96-100</title>
      <link href="/tech/132ee783.html"/>
      <url>/tech/132ee783.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-泛型介绍">一. 泛型介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">//（generic）泛型避免了: 向下转型可能造成的安全隐患</span><br><span class="line">//此时设置的T在Point类定义上只表示一个标记，在使用的时候需要为其设置具体的类型</span><br><span class="line">class Point&lt;T&gt;&#123;//定义坐标， Type = T,是一个类型</span><br><span class="line">private T x ;//此属性的类型不知道,由Point类使用时动态决定</span><br><span class="line">private T y ;</span><br><span class="line">public void setX(T x) &#123;</span><br><span class="line">this.x = x;</span><br><span class="line">&#125;</span><br><span class="line">public T getX() &#123;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">public void setY(T y) &#123;</span><br><span class="line">this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">public T getY() &#123;</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//第一步: 设置数据</span><br><span class="line">//Point p = new Point&lt;&gt;();//JDK1.7之后，后一个方括号内的Integer可以省略，不过建议代码写得完善一些</span><br><span class="line">Point p = new Point();// 如果没有增加，将使用Object类型描述泛型</span><br><span class="line">p.setX(100); </span><br><span class="line">p.setY(20);</span><br><span class="line">//p.setX(&quot;东经100度&quot;); // 如果设置的数据类型是错误的，那么在编译的时候就会自动的排查</span><br><span class="line">//p.setY(&quot;北纬20度&quot;);</span><br><span class="line">//第二步: 取出数据，由于接受的类型就是String，所以不需要向下强制编译</span><br><span class="line">//利用了包装类的自动装箱功能</span><br><span class="line">int x = (Integer)p.getX();</span><br><span class="line">int y = (Integer)p.getY();</span><br><span class="line">//String x = (String) p.getX();</span><br><span class="line">//String y = (String) p.getY();</span><br><span class="line">System.out.println(&quot;x坐标: &quot; + x + &quot;  ,y坐标: &quot; + y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-通配符-extends-类-super-类">二. 通配符（&lt;?extends 类&gt;、&lt;?super 类&gt;）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">class Message&lt;T&gt;&#123;</span><br><span class="line">private T msg;</span><br><span class="line">public void setMsg(T msg) &#123;</span><br><span class="line">this.msg = msg;</span><br><span class="line">&#125;</span><br><span class="line">public T getMsg() &#123;</span><br><span class="line">return msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Message&lt;Integer&gt; m = new Message&lt;Integer&gt;();</span><br><span class="line">m.setMsg(1);</span><br><span class="line">//m.setMsg(&quot;Hello World!&quot;);//如果这里是字符串,就会提示错误,Eclipse的好处，在编译的时候提示错误</span><br><span class="line">fun(m);//引用传递</span><br><span class="line">&#125;</span><br><span class="line">//?extends 类: 设置泛型上限，可以再声明上和方法参数上使用;</span><br><span class="line">//        → ?extends Number:意味着可以设置Number或者是Number的子类(Integer、double、...)</span><br><span class="line">//?super 类:   设置泛型下限;</span><br><span class="line">//        → ?super String:意味着只能够设置String或者是它的父类Object</span><br><span class="line">public static void fun(Message&lt;? extends Number&gt; temp) &#123;//？表示不能设置，但能够取出</span><br><span class="line">System.out.println(temp.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-泛型接口">三. 泛型接口</h3><ol><li>子类也继续使用泛型,并且父类接口使用和子类相同的泛型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">//如果是接口,在前面加上字母I,例如: IMessage</span><br><span class="line">//如果是抽象类,在前面加上Abstract,例如:AbstractMessage</span><br><span class="line">//如果是普通类,直接编写,例如:Message</span><br><span class="line">interface IMessage&lt;T&gt;&#123;</span><br><span class="line">public void print(T t);</span><br><span class="line">&#125;</span><br><span class="line">//子类也继续使用泛型,并且父类接口使用和子类相同的泛型</span><br><span class="line">class MessageImpl&lt;T&gt; implements IMessage&lt;T&gt; &#123;</span><br><span class="line">public void print(T t) &#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">IMessage&lt;String&gt; msg = new MessageImpl&lt;String&gt;();</span><br><span class="line">msg.print(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.在子类不设置泛型，而为父接口明确定义一个泛型类型</span><br><span class="line">&gt;package cn.ngp.demo;</span><br><span class="line">//如果是接口,在前面加上字母I,例如: IMessage</span><br><span class="line">//如果是抽象类,在前面加上Abstract,例如:AbstractMessage</span><br><span class="line">//如果是普通类,直接编写,例如:Message</span><br><span class="line">interface IMessage&lt;T&gt;&#123;</span><br><span class="line">public void print(T t);</span><br><span class="line">&#125;</span><br><span class="line">//在子类不设置泛型，而为父接口明确定义一个泛型类型</span><br><span class="line">class MessageImpl implements IMessage&lt;String&gt; &#123;</span><br><span class="line">public void print(String t) &#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">IMessage&lt;String&gt; msg = new MessageImpl();</span><br><span class="line">msg.print(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-泛型方法">四. 泛型方法</h3><p>泛型方法不一定要定义在支持泛型的类里面。<br>一 → 四 所有存在有泛型的方法，都是在支持泛型的类里面定义的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package cn.ngp.demo;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str = fun(&quot;Hello&quot;);</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">//T的类型由传入的参数类型决定</span><br><span class="line">public static &lt;T&gt; T fun (T t) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-总结">五. 总结</h3><ul><li>泛型解决的是向下转型所带来的安全隐患，其核心的组成就是在声明类或接口的时候不设置参数或者属性的类型</li><li>&quot;?&quot;可以接受任意的泛型类型，只能够去除，但是不能够修改</li></ul><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 不常见错误</title>
      <link href="/tech/359b982e.html"/>
      <url>/tech/359b982e.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-系统级错误">一. 系统级错误</h3><h4 id="1-cmd-cd-mydemo-拒绝访问">1. cmd → cd mydemo 拒绝访问</h4><p>解决方案: 双击一次文件夹，确认一下权限即可o(╥﹏╥)o…</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础——经常用到又经常忘记的概念</title>
      <link href="/tech/be0686aa.html"/>
      <url>/tech/be0686aa.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="3-字符串-equals-被比较的string变量">3. “字符串”.equals(被比较的String变量)</h3><p>这样可以处理，输入的String变量为null的情况</p><h3 id="4-访问控制权限">4.  访问控制权限</h3><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-02-01-1-1234.png" alt="1"></p><h3 id="5-在jdk1-8里面有一个最重要的概念-内部类访问方法参数可以不加上final关键字">5.   在JDK1.8里面有一个最重要的概念: 内部类访问方法参数可以不加上final关键字</h3><h3 id="6-枚举的目的-多例设计">6.  枚举的目的→多例设计，</h3><h3 id="n-已理解">N. 已理解</h3><h5 id="2-匿名对象">2. 匿名对象</h5><p>没有栈指向的对象就称为<strong>匿名对象</strong></p><blockquote><p>普通申明一个对象是这样的<br>A a = new A();<br>那么这个时候a就是类A的一个对象，这个对象名字就是a<br>再来看下面一个例子:<br>method(A a);<br>整理method是一个方法，他需要传递一个对象来作为参数，那么这个时候有2种方法：<br>方法1：<br>A a =new A();<br>method (a);<br>方法2：<br>method (new A());<br>方法2中new A()就是一个匿名对象，他没有名字。这样可以理解了吧。<br>转自: <a href="https://zhidao.baidu.com/question/271175254.html">https://zhidao.baidu.com/question/271175254.html</a></p></blockquote><h5 id="1-string类-特点">1. String类 特点</h5><p>String类的特点:</p><ul><li>Stirng类对象有两种实例化方式:<ul><li>直接赋值: 只开辟一块堆内存空间，可以自动入池</li><li>构造方法: 开辟两块堆内存空间，不会自动入池，使用intern()手工入池;</li></ul></li><li>任何一个字符串都是String类的匿名对象;</li><li>字符串一旦声明则不可改变，可以改变的只是String类对象的引用。</li></ul><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础——理解难点</title>
      <link href="/tech/93a43c14.html"/>
      <url>/tech/93a43c14.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-java-引用传递">一. java 引用传递</h3><ol><li>代码</li></ol><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-02-01-1-20380.png" alt="1"></p><ol start="2"><li>内存图<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-02-01-2-20380.png" alt="2"></li></ol><h3 id="二-return-super-getdata">二. return super.getData();</h3><p>java.util.Arrays.sort(super.getData());  //功能: 原始数据被排序并覆盖<br>return super.getData();//引用传递  重新调用父类的getData()，返回的结果是已被上一行代码排序后的数组。</p><h3 id="三-异常处理机制">三. 异常处理机制</h3><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-02-01-3-20380.png" alt="3"></p><h3 id="参考">参考</h3><p>来自: 阿里云大学(笔记) → <a href="https://edu.aliyun.com/course/1012/">零基础学Java10系列三：Java高级编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10_Win7  打印机 [有线局域网共享]</title>
      <link href="/tech/66bc2d58.html"/>
      <url>/tech/66bc2d58.html</url>
      
        <content type="html"><![CDATA[<p>Win10/Win7  打印机 [有线局域网共享])</p><h3 id="p-s-网络打印机是新型的打印机-能独立于pc电脑使用-没有这个功能的打印机-只能用有线网连起来再共享使用">P.S. <a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%89%93%E5%8D%B0%E6%9C%BA/4579250">网络打印机</a>是新型的打印机，能独立于PC电脑使用，没有这个功能的打印机，只能用有线网连起来再共享使用。</h3><h3 id="一-人话-先让一台电脑能打印-1号主机-配置">一、(人话: 先让一台电脑能打印) [1号主机] 配置</h3><h4 id="1-安装好驱动-usb连接好打印机-打印出测试页">1.  安装好驱动，usb连接好打印机，打印出测试页。</h4><h4 id="2-设置-1号主机-的-sxc-3200打印机-假设是这个-的-共享属性">2.  设置 [1号主机] 的 [sxc-3200打印机][假设是这个] 的 [共享属性]</h4><p><font color=gray size=2>P.S.1  →  1号主机就是，usb连接打印机的那台机器。为了方便区分，姑且命名为 [1号主机]</font ><br>控制面板  →  设备与打印机  →  右键sxc-3200 → 打印机属性 → 共享 → 共享这台打印机[打勾] → 按 [确定]键 来保存设置。<br><font color=gray size=2>P.S.3 控制面板Win10可以通过cortana语音助手的 [搜索功能] 搜出来，关键字: control / 控制面板。<br>win7则 [右键]开始按钮出来，或者开始菜单栏里有。</font ></p><h4 id="3-打印机设置完毕">3.  打印机设置完毕。</h4><h3 id="二-人话-两台电脑都设置共享功能-1号主机-和-2号主机-分别设置-系统级别共享">二、(人话: 两台电脑都设置共享功能) [1号主机] 和 [2号主机] 分别设置 [系统级别共享]:</h3><p><font color=gray size=2>P.S.2 Win10和Win7有细微区别</font ></p><h4 id="1-控制面板-网络与共享中心-更改高级共享设置-启用网络发现-启用文件和打印机共享-关闭密码保护共享-按-保存修改-键-来保存设置">1.  控制面板 →  网络与共享中心 → 更改高级共享设置 → 启用网络发现 + 启用文件和打印机共享 + 关闭密码保护共享 → 按 [保存修改]键 来保存设置。</h4><p><font color=gray size=2>P.S.3 控制面板Win10可以通过cortana语音助手的 [搜索功能] 搜出来，关键字: control / 控制面板。<br>win7则 [右键]开始按钮出来，或者开始菜单栏里有。</font ></p><h4 id="2-系统级别共享-设置完毕">2.  系统级别共享 设置完毕。</h4><h3 id="三-人话-另一台电脑使用共享的打印机-2号主机-通过-1号主机-安装驱动">三、(人话: 另一台电脑使用共享的打印机) [2号主机] 通过 [1号主机] 安装驱动</h3><h4 id="1-2号主机-获取-1号主机-的打印机驱动">1. [2号主机] 获取 [1号主机] 的打印机驱动</h4><p>[2号主机] win + R 呼出 [运行窗口]，输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\%[1号主机] 的 [计算机名]%</span><br></pre></td></tr></table></figure><p><font color=gray size=2>P.S.5 比如说我的 [1号主机] 主机的计算机名是 joker，就在 [2号主机] 的运行框里，输入:<br><code>\\joker</code><br></font ><br><font color=gray size=2>P.S.6 [计算机名]<br>win7  : 右键我的电脑 → 属性 → 可以在[计算机名、域、工作组设置] 里 看到 [计算机名] win10 : 打开任意一个文件夹 → (在左下角)右键我的电脑 → 属性 → 可以在[计算机名、域、工作组设置] 里 看到 [计算机名]</font ></p><h5 id="一-joker-没反应或出现错误-应该是-网线-或者-之前步骤没设置好的问题">一、<code>\\joker</code> 没反应或出现错误，应该是 网线 或者 之前步骤没设置好的问题。</h5><p>测试:<br>Win + R 输入: cmd<br>再输入: ping joker</p><blockquote><p><font color=gray size=2>应该有返回有以下 样式 的代码。<br>如果出现有 request fail 的字样，那应该是网线 或者 之前的共享没设置好的问题。两台电脑都要设置共享 </font ><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-01-18-1.png" alt="1"></p></blockquote><h4 id="2-可能在弹出打印机前-会弹出一个-请输入网络凭据-此时只要输入-1号主机-的管理员账号和密码就好">2. 可能在弹出打印机前，会弹出一个[请输入网络凭据]，此时只要输入[1号主机] 的管理员账号和密码就好。</h4><p><font color=gray size=2>默认管理员账号密码是<br><code>账号: Administrator</code><br><code>密码:</code><br>密码一般为空，就是什么都不要输入。<br>保险一点，还是去[1号主机] 的控制面板，看看管理员账号密码比较好。</p><h4 id="3-在弹出的窗口-双击-显示的打印机-安装打印机驱动">3. 在弹出的窗口，双击 显示的打印机，安装打印机驱动。</h4><h4 id="4-2号主机-随便打印一个文档测试一下-完事">4. [2号主机] 随便打印一个文档测试一下，完事</h4><p><font color=gray size=2>理论上，这样，[2号主机] 就可以通过 [局域网]，使用 [1号主机] 的打印机了。</font ></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打印机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Warframe(国际服) 以后要用的萌新备注</title>
      <link href="/others/14227f7e.html"/>
      <url>/others/14227f7e.html</url>
      
        <content type="html"><![CDATA[<p>1. 看 地球/平原 时间，看 奸商，看裂缝  <a href="https://rm.0-0.at/">https://rm.0-0.at/</a> [裂罅之镜]<br>﻿2. 看 目前赏金详情<br><a href="https://wfa.richasy.cn/#/info">https://wfa.richasy.cn/#/info</a>  [Warframe Alerting 网页版](顺带 可以看看警报什么的)<br>﻿3. 手机WF资讯APP<br><a href="https://www.coolapk.com/game/com.hefty.warframe">https://www.coolapk.com/game/com.hefty.warframe</a>[Warframe Ordis]<br>（这只是介绍 ，各大安卓手机app应用市场可直接搜索下载，功能很全很方便）<br>ios手机 推荐 [WF国际版]<br>﻿4. 查不会的 名词/mod卡/任务<br><a href="http://warframe.huijiwiki.com/wiki/%E9%A6%96%E9%A1%B5%5B%E4%B8%AD%E6%96%87%E7%81%B0%E6%9C%BAwiki%5D">http://warframe.huijiwiki.com/wiki/首页[中文灰机wiki]</a><br>﻿5. 组队频道的简称不到什么意思 请百度。 比如: 百度→[warframe 4k] 然后进相应的贴吧看看就知道个大概了。<br>﻿6. 查配卡 bilibili→ [Warframe 女枪] 或者 [Warframe 女枪 配卡] 就出来了。<br>﻿7. 看mod/p武器战甲/赋能(除了紫卡几乎所有东西的价格)   的价格 →<br><a href="https://warframe.market/">https://warframe.market/</a>  [warframe market最大的warframe交易网站]<br>食用教程:  买家→https://tieba.baidu.com/p/4693662060<br>卖家链接被404了，请自行搜索。<br>﻿8. 查紫卡价格  只推荐Win10付费软件 <a href="%EF%BF%A511">Warframe Alerting Prime</a><br>﻿9. 大部分事情 得要自己去尝试一次才知道，慢慢探索吧，这个可以挖好几年的游戏 = =</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> warframe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>得力桌面吸尘器——使用方式-备忘</title>
      <link href="/others/6089b738.html"/>
      <url>/others/6089b738.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-01-09-1-543.png" alt="1"><br>就是这个 ↓<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-01-09-2-543.png" alt="2"></p><h3 id="功能有">功能有:</h3><ul><li>吸铅笔屑 （迅速、吸得干净）</li><li>吸宿舍床单上的灰尘等</li><li>蚊帐内吸蚊子（一吸一个准，按蚊子体型大→小: 打晕→分尸，除了有噪音、只能在蚊帐内这种小空间内使用外，简直完美）</li></ul><h3 id="淘宝32元-电池版-55元充电板">淘宝32元（电池版） 55元充电板</h3><blockquote><p>P.S. 配合小米 14元 10个 的彩虹五号电池简直完美<br>P.S. 我自己使用，两节电池 每天用的话大概1个月？<br>实际平时，很少用，但是，打蚊子很方便，尤其是想睡觉的时候，用了一学期了，电池还有电</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活小利器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-07-12 Win10-360-系统备份还原</title>
      <link href="/tech/4d008da8.html"/>
      <url>/tech/4d008da8.html</url>
      
        <content type="html"><![CDATA[<h3 id="简介-一键式一键备份还原-只能在同一型号的电脑上使用">简介: 一键式一键备份还原（只能在同一型号的电脑上使用）</h3><h3 id="一-软件安装">一、软件安装</h3><blockquote><p>仅仅使用了360安全卫士以及其的一个工具（插件）。<br>P.S. 我想大部分人的电脑都有360安全卫士吧。</p></blockquote><p>安装插件以及使用教程:<br><a href="https://jingyan.baidu.com/article/455a9950552e97a16627782e.html">windows系统如何一键备份还原</a></p><blockquote><p>P.S.教程过于简单，以上网站就包括了</p></blockquote><h3 id="二-常见问题">二、常见问题</h3><h4 id="1-一句话解释-备份-vhdx文件可以单独提取word等文件">1.一句话解释: 备份.vhdx文件可以单独提取word等文件</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2018-07-12-1-8848.png" alt="1"></p><h5 id="提取教程-a-href-http-bbs-360-cn-forum-php-mod-viewthread-tid-15459701-highlight-e3-80-90-e7-b3-bb-e7-bb-9f-e5-a4-87-e4-bb-bd-e8-bf-98-e5-8e-9f-e3-80-91-挂载360备份vhd文件-a"><strong>提取教程:</strong> <a href="http://bbs.360.cn/forum.php?mod=viewthread&tid=15459701&highlight=%E3%80%90%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E3%80%91">挂载360备份VHD文件</a></h5><hr><h4 id="2-一句话解释-系统盘换了不能直接还原">2. 一句话解释: 系统盘换了不能直接还原</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2018-07-12-2-8848.png" alt="2"></p><hr><h4 id="3-一句话解释">3. 一句话解释:</h4><h3 id="三-系统备份的拷贝-不推荐">三、系统备份的拷贝(不推荐)</h3><h4 id="1-360系统备份还原插件有一个小缺陷-采用的是增量备份-所以-想要保存多个备份就有点麻烦">1. 360系统备份还原插件有一个小缺陷。采用的是增量备份，所以，想要保存多个备份就有点麻烦。</h4><p>1.1 失败尝试——尝试只复制.vhxh文件，删除原文件，改名，拷贝回去360无法识别。<br>1.2 成功实现——拷贝整个WindowsImageBackup文件，就可以让360成功识别出来。<br>P.S. 拷贝到移动硬盘后，硬盘内不可再复制，但是可以复制给D盘或E盘等非系统盘。也就是说一个分区只能放一个备份。<br>P.S. 备份也不能直接（右键→删除），必须用360的系统备份还原来删除。。。不然白白浪费30+g的外存空间<br><font color=##00ffff>P.S. cmcc-web账号密码自动登录等。一切在c盘的软件以及其配置，一切系统配置都会保存</font></p><blockquote><p>理论依据: <a href="http://bbs.360.cn/forum.php?mod=viewthread&tid=15053661&highlight=%E3%80%90%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E3%80%91">【系统备份还原】“找不到备份文件（位置）”的解决方案</a><br>里面直说了，备份文件WindowsImageBackup里面的文件不能动。<br>###不建议 :<a href="http://bbs.360.cn/forum.php?mod=viewthread&tid=15084474&highlight=%E3%80%90%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E3%80%91">删除【360系统还原】开机引导菜单的方法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统备份还原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 优化、美化（主题、终端）</title>
      <link href="/tech/83db9cdb.html"/>
      <url>/tech/83db9cdb.html</url>
      
        <content type="html"><![CDATA[<h2 id="零-效果图">零 效果图</h2><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2017-11-04-1-9733.png" alt="1"><br><a href="http://pan.baidu.com/s/1o7VoJAq">壁纸分享</a></p><h2 id="一-优化ubuntu">一 优化Ubuntu</h2><h3 id="1-系统更新">\1 系统更新</h3><p>安装完系统之后，需要更新一些补丁。Ctrl+Alt+T调出终端，执行一下代码：<br><code>sudo apt-get update sudo apt-get upgrade</code></p><h3 id="2-安装gdebi-第三方软件安装">\2 安装GDebi（第三方软件安装）</h3><p><code>sudo apt-get install gdebi</code><br>然后就可以，在网上，下载第三方软件。<br>拷贝到Ubuntu ， 右键 以 GDebi 打开，安装。</p><h3 id="3-安装-搜狗输入法">\3 安装 搜狗输入法</h3><p><a href="http://pinyin.sogou.com/linux/">搜狗输入法 Ubuntu 16.04下载</a><br><a href="https://jingyan.baidu.com/article/adc815134f4b92f722bf7350.html?qq-pf-to=pcqq.c2c">在ubuntu下，把安装的中文输入法切换出来</a></p><h3 id="4-软件卸载-安装">\4 软件卸载，安装</h3><h4 id="4-1-卸载libreoffice-安装wps">4.1 卸载libreOffice  安装WPS</h4><p>libreoffice事ubuntu自带的开源office软件，体验效果不如windows上的office，于是选择用WPS来替代（wps的安装后面会提到）<br><code>sudo apt-get remove libreoffice-common</code></p><p><a href="http://community.wps.cn/download/">WPS官方网站下载</a></p><h4 id="4-2-卸载掉亚马逊链接">4.2 卸载掉亚马逊链接</h4><p><code>sudo apt-get remove unity-webapps-common</code></p><h4 id="4-3-卸载-firebox浏览器-安装chrome-chromium浏览器">4.3 卸载 firebox浏览器 安装Chrome/Chromium浏览器</h4><p><code>sudo apt-get remove firefox</code></p><blockquote><p><a href="https://zm12.sm-tc.cn/?src=l4uLj8XQ0IiIiNGTlpGKh5abnNGckJLQs5aRiofQzc%2FOzNLOz9DGzsfKyNGXi5I%3D&uid=bd3a4d1d8127bb4dbe4582343b1d5209&hid=a859296552832185eff9ca7bb2a33fcf&pos=2&cid=9&time=1510986787442&from=click&restype=1&pagetype=0000004000000402&bu=structure_web_kv&query=ubuntu+%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8&mode=&v=1&uc_param_str=dnntnwvepffrgibijbprsvdsdichei">Ubuntu基础教程——安装谷歌Chrome浏览器</a><br><strong>Chrome浏览器安装:</strong><br>终端输入:<br><code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code><br>下载完后，运行如下命令安装。<br><code>sudo dpkg -i google-chrome*; sudo apt-get -f install</code></p></blockquote><p><strong>Chromium浏览器</strong> 也可以在<strong>Ubuntu系统里的 “Ubuntu软件</strong> 里可以下载。</p><h3 id="5-修改-更新源">\5 修改 更新源</h3><p><font size=2px>Ubuntu下载软件速度有点慢，毕竟是从国外下载软件，就想更换到国内比较好的更新源。</font><br><a href="http://www.cnblogs.com/bovenson/p/5752213.html">Ubuntu 16.04 几个国内更新源</a><br>5.1  备份原来的更新源<br><code>sudo -s cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></p><p>5.2  修改更新源　<br><code>gedit /etc/apt/sources.list //这就是存放更新源的文件</code></p><p>将以下代码，粘贴并覆盖sources.list文件中的所有内容　<br><code># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties deb http://archive.canonical.com/ubuntu xenial partner deb-src http://archive.canonical.com/ubuntu xenial partner deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</code><br>5.3  让更新源生效<br><code>sudo apt-get update</code></p><p>5.4  安装软件，测试是否成功<br><code>sudo apt-get install vim //安装vim</code></p><h3 id="6-vim-配置">\6 vim 配置</h3><p>下载安装 vim:<br><code>sudo apt-get install vim</code></p><p>打开vim配置文件:<br><code>sudo vim /etc/vim/vimrc</code></p><p>添加以下代码，到文件尾:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 显示相关  </span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">set shortmess=atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示  </span><br><span class="line">winpos 5 5         &quot; 设定窗口位置  </span><br><span class="line">set lines=30 columns=85    &quot; 设定窗口大小  </span><br><span class="line">set nu              &quot; 显示行号  </span><br><span class="line">set go=             &quot; 不要图形按钮  </span><br><span class="line">&quot;color asmanian2     &quot; 设置背景主题  </span><br><span class="line">set guifont=Courier_New:h10:cANSI   &quot; 设置字体  </span><br><span class="line">syntax on           &quot; 语法高亮  </span><br><span class="line">autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  </span><br><span class="line">autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行  </span><br><span class="line">set ruler           &quot; 显示标尺  </span><br><span class="line">set showcmd         &quot; 输入的命令显示出来，看的清楚些  </span><br><span class="line">set cmdheight=1     &quot; 命令行（在状态行下）的高度，设置为1  </span><br><span class="line">&quot;set whichwrap+=&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  </span><br><span class="line">set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  </span><br><span class="line">set novisualbell    &quot; 不要闪烁(不明白)  </span><br><span class="line">set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;   &quot;状态行显示的内容  </span><br><span class="line">set laststatus=1    &quot; 启动显示状态行(1),总是显示状态行(2)  </span><br><span class="line">set foldenable      &quot; 允许折叠  </span><br><span class="line">set foldmethod=manual   &quot; 手动折叠  </span><br><span class="line">set background=dark &quot;背景使用黑色 </span><br><span class="line">set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  </span><br><span class="line">&quot; 显示中文帮助</span><br><span class="line">if version &gt;= 603</span><br><span class="line">    set helplang=cn</span><br><span class="line">    set encoding=utf-8</span><br><span class="line">endif</span><br><span class="line">&quot; 设置配色方案</span><br><span class="line">&quot;colorscheme murphy</span><br><span class="line">&quot;字体 </span><br><span class="line">&quot;if (has(&quot;gui_running&quot;)) </span><br><span class="line">&quot;   set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 </span><br><span class="line">&quot;endif </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencodings=ucs-bom,utf-8,cp936</span><br><span class="line">set fileencoding=utf-8</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;新建.c,.h,.sh,.java文件，自动插入文件头 </span><br><span class="line">autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; </span><br><span class="line">&quot;&quot;定义函数SetTitle，自动插入文件头 </span><br><span class="line">func SetTitle() </span><br><span class="line">    &quot;如果文件类型为.sh文件 </span><br><span class="line">    if &amp;filetype == &apos;sh&apos; </span><br><span class="line">        call setline(1,&quot;\#########################################################################&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;\# File Name     : &quot;.expand(&quot;%&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;\# Author        : enjoy5512&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;\# mail          : enjoy5512@163.com&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;\# Created Time  : &quot;.strftime(&quot;%c&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+4, &quot;\#########################################################################&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+5, &quot;&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;\#!/bin/bash&quot;) </span><br><span class="line">    call append(line(&quot;.&quot;)+7, &quot;&quot;)</span><br><span class="line">    call append(line(&quot;.&quot;)+8, &quot;&quot;)</span><br><span class="line">    else </span><br><span class="line">        call setline(1, &quot;/*************************************************************************&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;    &gt; File Name       : &quot;.expand(&quot;%&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;    &gt; Author          : enjoy5512&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail            : enjoy5512@163.com &quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time    : &quot;.strftime(&quot;%c&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+5, &quot;&quot;)</span><br><span class="line">    endif</span><br><span class="line">    if &amp;filetype == &apos;cpp&apos;</span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)</span><br><span class="line">    call append(line(&quot;.&quot;)+7, &quot;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+8, &quot;using namespace std;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+9, &quot;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+10, &quot;int main(int argc,char *argv[])&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+11, &quot;&#123;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+12, &quot;     &quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+13, &quot;    return 0;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+14, &quot;&#125;&quot;)</span><br><span class="line">    endif</span><br><span class="line">    if &amp;filetype == &apos;c&apos;</span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+7, &quot;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+8, &quot;int main(int argc,char *argv[])&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+9, &quot;&#123;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+10, &quot;     &quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+11, &quot;    return 0;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+12, &quot;&#125;&quot;)</span><br><span class="line">    autocmd BufNewFile * 12 j</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;键盘命令</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;C，C++ 按F5编译运行</span><br><span class="line">map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;</span><br><span class="line">func! CompileRunGcc()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    if &amp;filetype == &apos;c&apos;</span><br><span class="line">        exec &quot;!gcc % -o %&lt;&quot;</span><br><span class="line">        exec &quot;! ./%&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;cpp&apos;</span><br><span class="line">        exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">        exec &quot;! ./%&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;sh&apos;</span><br><span class="line">        :!./%</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">&quot;C,C++的调试</span><br><span class="line">map &lt;C-F5&gt; :call Rungdb()&lt;CR&gt;</span><br><span class="line">func! Rungdb()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    if &amp;filetype == &apos;c&apos;</span><br><span class="line">        exec &quot;!gcc % -g -o %&lt;&quot;</span><br><span class="line">        exec &quot;!gdb -tui ./%&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;cpp&apos;</span><br><span class="line">        exec &quot;!g++ % -g -o %&lt;&quot;</span><br><span class="line">        exec &quot;!gdb -tui ./%&lt;&quot;</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;实用设置</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 设置当文件被改动时自动载入</span><br><span class="line">set autoread</span><br><span class="line">&quot; quickfix模式</span><br><span class="line">autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;</span><br><span class="line">&quot;代码补全 </span><br><span class="line">set completeopt=preview,menu </span><br><span class="line">&quot;允许插件  </span><br><span class="line">filetype plugin on</span><br><span class="line">&quot;共享剪贴板  </span><br><span class="line">set clipboard+=unnamed </span><br><span class="line">&quot;从不备份  </span><br><span class="line">set nobackup</span><br><span class="line">&quot;自动保存</span><br><span class="line">set autowrite</span><br><span class="line">set ruler                   &quot; 打开状态栏标尺</span><br><span class="line">set cursorline              &quot; 突出显示当前行</span><br><span class="line">set magic                   &quot; 设置魔术</span><br><span class="line">set guioptions-=T           &quot; 隐藏工具栏</span><br><span class="line">set guioptions-=m           &quot; 隐藏菜单栏</span><br><span class="line">set foldcolumn=0</span><br><span class="line">set foldmethod=indent </span><br><span class="line">set foldlevel=3 </span><br><span class="line">set foldenable              &quot; 开始折叠</span><br><span class="line">&quot; 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 语法高亮</span><br><span class="line">set syntax=on</span><br><span class="line">&quot; 去掉输入错误的提示声音</span><br><span class="line">set noeb</span><br><span class="line">&quot; 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line">set confirm</span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line">&quot; Tab键的宽度</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot; 统一缩进为4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot;禁止生成临时文件</span><br><span class="line">set nobackup</span><br><span class="line">set noswapfile</span><br><span class="line">&quot;搜索忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line">&quot;搜索逐字符高亮</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line">&quot;行内替换</span><br><span class="line">set gdefault</span><br><span class="line">&quot;编码设置</span><br><span class="line">set enc=utf-8</span><br><span class="line">set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936</span><br><span class="line">&quot;语言设置</span><br><span class="line">set langmenu=zh_CN.UTF-8</span><br><span class="line">set helplang=cn</span><br><span class="line">&quot; 我的状态行显示的内容（包括文件类型和解码）</span><br><span class="line">set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;</span><br><span class="line">&quot;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]</span><br><span class="line">&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span><br><span class="line">&quot; 总是显示状态行</span><br><span class="line">set laststatus=2</span><br><span class="line">&quot; 命令行（在状态行下）的高度，默认为1，这里是2</span><br><span class="line">set cmdheight=2</span><br><span class="line">&quot; 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line">&quot; 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line">&quot; 保存全局变量</span><br><span class="line">set viminfo+=!</span><br><span class="line">&quot; 在被分割的窗口间显示空白，便于阅读</span><br><span class="line">set fillchars=vert:\ ,stl:\ ,stlnc:\</span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span><br><span class="line">set matchtime=1</span><br><span class="line">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set scrolloff=3</span><br><span class="line">&quot; 为C程序提供自动缩进</span><br><span class="line">set smartindent</span><br><span class="line">&quot; 高亮显示普通txt文件（需要txt.vim脚本）</span><br><span class="line">au BufRead,BufNewFile *  setfiletype txt</span><br><span class="line">&quot;自动补全</span><br><span class="line">&quot;:inoremap ( ()&lt;ESC&gt;i</span><br><span class="line">&quot;:inoremap ) &lt;c-r&gt;=ClosePair(&apos;)&apos;)&lt;CR&gt;</span><br><span class="line">:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span><br><span class="line">:inoremap &#125; &lt;c-r&gt;=ClosePair(&apos;&#125;&apos;)&lt;CR&gt;</span><br><span class="line">&quot;:inoremap [ []&lt;ESC&gt;i</span><br><span class="line">&quot;:inoremap ] &lt;c-r&gt;=ClosePair(&apos;]&apos;)&lt;CR&gt;</span><br><span class="line">&quot;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line">&quot;:inoremap &apos; &apos;&apos;&lt;ESC&gt;i</span><br><span class="line">function! ClosePair(char)</span><br><span class="line">    if getline(&apos;.&apos;)[col(&apos;.&apos;) - 1] == a:char</span><br><span class="line">        return &quot;\&lt;Right&gt;&quot;</span><br><span class="line">    else</span><br><span class="line">        return a:char</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line">filetype plugin indent on </span><br><span class="line">&quot;打开文件类型检测, 加了这句才可以用智能补全</span><br><span class="line">set completeopt=longest,menu</span><br></pre></td></tr></table></figure><h3 id="6-菜单栏位置">\6 菜单栏位置</h3><blockquote><p>放到<strong>底部</strong>（终端输入以下）：<br><code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom</code></p></blockquote><blockquote><p>放到<strong>左侧</strong>（终端输入以下）：<br><code>gsettings set com.canonical.Unity.Launcher launcher-position Left</code></p></blockquote><h3 id="7">\7</h3><hr><h2 id="二-美化ubuntu">二 美化Ubuntu</h2><h3 id="1-主题">\1 主题</h3><h4 id="1-1-安装unity-tweak-tool：">1.1 安装unity-tweak-tool：</h4><p><code>sudo apt-get install unity-tweak-tool</code></p><p><font size=2px>调整 Unity 桌面环境，还是推荐使用Unity Tweak Tool，这是一个非常好用的 Unity 图形化管理工具，可以修改工作区数量、热区等。</font></p><h4 id="1-2-flatabulous主题">1.2 Flatabulous主题</h4><p>下载主题<br><code>sudo add-apt-repository ppa:noobslab/themes sudo apt-get update sudo apt-get install flatabulous-theme</code><br>下载配套图标<br><code>sudo add-apt-repository ppa:noobslab/icons sudo apt-get update sudo apt-get install ultra-flat-icons</code><br><font size=2px>安装完成后，打开unity-tweak-tool软件，修改主题和图标：<br>进入主题 / 图标，修改为Flatabulous / Ultra-flat</font></p><hr><h3 id="2-字体">\2 字体</h3><p><font size=2px>Ubuntu自带的字体不太好看，所以 苹果字体 代替</font><br><a href="http://pan.baidu.com/s/1miHvNvi">monaco-font-master.zip(苹果字体)下载</a></p><p>复制 .zip文件到 ubuntu<br><code>unzip monaco-font-master.zip</code> //解压<br>进入解压文件，输入：<br><code>sudo ./install-font-ubuntu.sh https://github.com/todylu/monaco.ttf/blob/master/monaco.ttf?raw=true</code></p><p><font size=2px>安装完成后，通过unity-tweak-tool-&gt;font 来替换字体。</font></p><hr><h3 id="3-终端">\3 终端</h3><p>####3.1 <font color=red><strong>注意：安装的是 Shell，使用习惯和 bash 略有不同</strong></font><br>安装 zsh<br><code>sudo apt-get install zsh</code></p><p>下载oh-my-zsh<br><a href="https://github.com/robbyrussell/oh-my-zsh">github下载</a><br><a href="http://pan.baidu.com/s/1dE86t5f">百度云下载地址</a></p><p>安装oh-my-zsh<br>复制到 Ubuntu，解压，进入解压文件，进入tools<br><code>./install.sh</code></p><p>OK！</p><ul><li>这里其实需要澄清一个概念，那就是 <strong>终端</strong> 本身是不会解析命令的。它只是一个 <strong>界面</strong> 而已，是 <strong>负责人机交互的一个接口</strong> 而已。</li><li>真正处理命令的并不是这些终端，真正处理命令行的是shell。</li><li>终端只是负责提供一个输入命令的交互界面而已，在里面运行的命令并不归终端界面去解析，而是找到 <strong>专门的命令行程序</strong> ，这种程序我们一般将其称之为shell。</li></ul><p>来自: <a href="http://www.cnblogs.com/jplatformx/p/4366278.html">http://www.cnblogs.com/jplatformx/p/4366278.html</a></p><ul><li><p>Linux 中的 shell 有很多类型，其中最常用的几种是: Bourne shell (sh)、C shell (csh) 和 Korn shell (ksh), 各有优缺点。Bourne shell 是 UNIX 最初使用的 shell，并且在每种 UNIX 上都可以使用, 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。</p></li><li><p>Linux 操作系统缺省的 shell 是Bourne Again shell，它是 Bourne shell 的扩展，简称 Bash，与 Bourne shell 完全向后兼容，并且在Bourne shell 的基础上增加、增强了很多特性。</p></li><li><p>Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p></li></ul><p>来自: <a href="http://blog.csdn.net/monmama/article/details/53390610">http://blog.csdn.net/monmama/article/details/53390610</a></p><hr><h4 id="3-2-shell命令">3.2 Shell命令</h4><p>\1 确定在使用的shell是哪个？<br><code>echo $SHELL</code><br>\2 列出用户<br><code>sudo vi /etc/passwd</code><br>\3 <strong>切换</strong> root用户（不需要密码）<br><code>sudo -s -H</code>  或 <code>sudo -s</code><br>\4 退出 root<br><code>exit</code><br>\5 显示当前用户信息（权限 0 最高）<br><code>id</code><br>\6</p><hr><h4 id="3-3-好处：">3.3 好处：</h4><p><a href="http://shanker.blog.51cto.com/1189689/1765036">使用zsh的十大优点</a><br><a href="https://www.zhihu.com/question/21418449">为什么说 zsh 是 shell 中的极品？（知乎）</a><br>\1 跳转</p><p>输入<code>d</code>，将列出当前 session 访问过的所有目录，再输入数字跳转</p><p>\2 历史记录</p><p>zsh 的历史记录跨 session，可以共享。历史记录支持受限查找。比如，输入git，再按向上箭头，会搜索用过的所有 git 命令。</p><hr><h4 id="3-4-皮肤推荐">3.4 皮肤推荐</h4><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes#daveverwer">wiki皮肤预览</a></p><p>\0 更改皮肤<br><code>vi ~/.zshrc</code><br>找到 下面这句代码:<br><code>ZSH_THEME=&quot;robbyrussell&quot;</code><br>修改名字即可（大小写敏感）</p><p>\1  robbyrussell （原生皮肤）<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2017-11-04-2-9733.png" alt="2"></p><ul><li>红箭头表示 zsh 开始位置, 接着是绝对路径</li><li>git 表示此目录被git 仓库托管.</li><li>(dev) 表示当前目录内容所在git 分支 是 dev</li><li>x 号表示,当前文件中有内容变动,并且没有提交到代码库,如果提交以后,会变成绿色√号<br><a href="http://yijiebuyi.com/blog/6931f52dbbb62b02fca8142f2b2d0181.html">http://yijiebuyi.com/blog/6931f52dbbb62b02fca8142f2b2d0181.html</a></li></ul><p>\2 iGeek</p><hr><h4 id="3-5-插件安装">3.5 插件安装</h4><p><strong>\0 下载后配置</strong><br><font color=blue><strong>每</strong> 下载一个插件之后，<br>把插件名称添加至 ~/.zshrc <strong>的</strong> plugins(语句) 里<br>(plugins(语句) 在 .zshrc 文件60行左右的位置)<br>(~/.zshrc，注意前面有点，是隐藏文件)<br></font><br><code>vi ~/.zshrc</code></p><p><font color=blue>修改plugins</font><br><code>plugins=(git autojump zsh-autosuggestions zsh-syntax-highlighting)</code></p><p><font color=blue>然后，让软件检测到</font><br><code>source .zshrc</code></p><p><font color=blue>OK！</font><br></font><br>#####<strong>\1 下载安装 zsh-autosuggestions （自动补全可能路径）</strong><br><code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code><br>跳转到 <strong>\0 下载后配置</strong></p><h5 id="2-下载-autojump-快速跳转"><strong>\2 下载 autojump （快速跳转）</strong></h5><p><code>git clone https://github.com/joelthelion/autojump.git</code></p><p>进入下载文件，安装:<br><code>cd autojump</code><br><code>./install.py</code></p><p>把以下代码 <strong>添加到</strong>  (用户名)/.zshrc 文件尾<br><code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh</code></p><p>跳转到 <strong>\0 下载后配置</strong></p><h5 id="3-下载安装-zsh-syntax-highlighting-终端输入高亮-正确路径下划线"><strong>\3 下载安装 zsh-syntax-highlighting （终端输入高亮 正确路径下划线）</strong></h5><p><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></p><p>跳转到 <strong>\0 下载后配置</strong></p><hr><h3 id="4-杂项">\4 杂项</h3><p>4.1</p><ul><li>你可以将启动器移到屏幕底部。终端，输入这个命令：<br><code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom</code></li><li>想把启动器移回到屏幕一侧，只要进行这个微小的更改：<br><code>gsettings set com.canonical.Unity.Launcher launcher-position Left</code></li></ul><p>4.2   配置3D桌面…虚拟机还是算了。<br>compiz</p><h3 id="end-参考">End 参考:</h3><p>vim配置:<br><a href="http://blog.csdn.net/enjoy5512/article/details/53408213">http://blog.csdn.net/enjoy5512/article/details/53408213</a><br>更新源:<br><a href="http://blog.csdn.net/fengyuzhiren/article/details/54844870">http://blog.csdn.net/fengyuzhiren/article/details/54844870</a><br><a href="http://www.cnblogs.com/bovenson/p/5752213.html">http://www.cnblogs.com/bovenson/p/5752213.html</a><br>主题 :<br><a href="http://blog.csdn.net/wangweiqiang1325/article/details/53447123">http://blog.csdn.net/wangweiqiang1325/article/details/53447123</a><br><a href="http://blog.csdn.net/terence1212/article/details/52270210">http://blog.csdn.net/terence1212/article/details/52270210</a><br>oh-my-zsh:<br><a href="http://yijiebuyi.com/blog/6931f52dbbb62b02fca8142f2b2d0181.html">http://yijiebuyi.com/blog/6931f52dbbb62b02fca8142f2b2d0181.html</a><br><a href="http://yijiebuyi.com/blog/6931f52dbbb62b02fca8142f2b2d0181.html">http://yijiebuyi.com/blog/6931f52dbbb62b02fca8142f2b2d0181.html</a><br>字体 :<br><a href="http://blog.csdn.net/qq_26990831/article/details/51847416">http://blog.csdn.net/qq_26990831/article/details/51847416</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv学习实例（一）---Camshift 色块追踪(详细注释)</title>
      <link href="/tech/eeb2afcb.html"/>
      <url>/tech/eeb2afcb.html</url>
      
        <content type="html"><![CDATA[<p><font color=#00ccff>建议拷贝到本地看。借鉴了众多网站，才大概明白了这个程序</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序描述：来自OpenCV安装目录下Samples文件夹中的官方示例程序-彩色目标跟踪操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">增加了"非常"详细的注释。----97年的顽石</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------【头文件、命名空间包含部分】----------------------------------</span></span><br><span class="line"><span class="comment">描述：包含程序所使用的头文件和命名空间</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/video/tracking.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc/imgproc.hpp"</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">highgui为跨平台的gui/IO组件，支持平台包括windows,linux,mac,IOS,android，</span></span><br><span class="line"><span class="comment">可支持图像/视频/摄像头的读取显示以及转码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//ctype.h是C标准函数库中的头文件，定义了一批C语言字符分类函数--百度百科</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------【全局变量声明】-----------------------------------------</span></span><br><span class="line"><span class="comment">//描述：声明全局变量</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></span><br><span class="line">Mat image;</span><br><span class="line"><span class="keyword">bool</span> backprojMode = <span class="literal">false</span>;<span class="comment">//表示是否要进入反向投影模式，ture表示准备进入反向投影模式</span></span><br><span class="line"><span class="keyword">bool</span> selectObject = <span class="literal">false</span>;<span class="comment">//代表是否在选要跟踪的初始目标，true表示正在用鼠标选择</span></span><br><span class="line"><span class="keyword">int</span> trackObject = <span class="number">0</span>;<span class="comment">//代表跟踪目标数目？</span></span><br><span class="line"><span class="keyword">bool</span> showHist = <span class="literal">true</span>;<span class="comment">//是否显示直方图</span></span><br><span class="line">Point origin;<span class="comment">//用于保存鼠标选择第一次单击时点的位置</span></span><br><span class="line">Rect selection;<span class="comment">//用于保存鼠标选择的矩形框</span></span><br><span class="line"><span class="keyword">int</span> vmin = <span class="number">10</span>, vmax = <span class="number">256</span>, smin = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------【onMouse( )回调函数】------------------------------------</span></span><br><span class="line"><span class="comment">//描述：鼠标操作回调</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onMouse</span><span class="params">( <span class="keyword">int</span> event, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>, <span class="keyword">void</span>* )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">然后鼠标在移动触发if (selectObject)  这一行.</span></span><br><span class="line"><span class="comment">这时候新的坐标点的x，y值都会传过来，</span></span><br><span class="line"><span class="comment">不管是从哪个方向往哪个方向画都可以得到矩形</span></span><br><span class="line"><span class="comment">(因为他是取绝对值的，从左下往。。。，等等等都行)</span></span><br><span class="line"><span class="comment">http://blog.csdn.net/ddqqfree123/article/details/52173359</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>( selectObject )</span><br><span class="line">&#123;</span><br><span class="line">selection.x = MIN(x, origin.x);<span class="comment">//矩形左上角顶点坐标</span></span><br><span class="line">selection.y = MIN(y, origin.y);</span><br><span class="line">selection.width = <span class="built_in">std</span>::<span class="built_in">abs</span>(x - origin.x);<span class="comment">//矩形宽</span></span><br><span class="line">selection.height = <span class="built_in">std</span>::<span class="built_in">abs</span>(y - origin.y);<span class="comment">//矩形高</span></span><br><span class="line"><span class="comment">//用于确保所选的矩形区域在图片范围内 -----------------------???</span></span><br><span class="line">selection &amp;= Rect(<span class="number">0</span>, <span class="number">0</span>, image.cols, image.rows); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>( event )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//鼠标按下去是一个事件，传到这个函数里面,触发 case CV_EVENT_LBUTTONDOWN: 这一行  </span></span><br><span class="line"><span class="keyword">case</span> CV_EVENT_LBUTTONDOWN:</span><br><span class="line">origin = Point(x,y);</span><br><span class="line">selection = Rect(x,y,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">selectObject = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//左键鼠标抬起这个事件 传到函数里,触发 case CV_EVENT_LBUTTONUP:这一行  </span></span><br><span class="line"><span class="keyword">case</span> CV_EVENT_LBUTTONUP:</span><br><span class="line">selectObject = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>( selection.width &gt; <span class="number">0</span> &amp;&amp; selection.height &gt; <span class="number">0</span> )</span><br><span class="line"><span class="comment">//跟踪目标数量为什么要设置为-1? 后面有if（trackObject &lt;0）就画出直方图</span></span><br><span class="line">trackObject = <span class="number">-1</span>;  </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------【help( )函数】----------------------------------------------</span></span><br><span class="line"><span class="comment">//描述：输出帮助信息</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowHelpText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n\t此Demo显示了基于均值漂移的追踪（tracking）技术\n"</span></span><br><span class="line"><span class="string">"\t请用鼠标框选一个有颜色的物体，对它进行追踪操作\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n\t操作说明： \n"</span></span><br><span class="line"><span class="string">"\t\t用鼠标框选对象来初始化跟踪\n"</span></span><br><span class="line"><span class="string">"\t\tESC - 退出程序\n"</span></span><br><span class="line"><span class="string">"\t\tc - 停止追踪\n"</span></span><br><span class="line"><span class="string">"\t\tb - 开/关-投影视图\n"</span></span><br><span class="line"><span class="string">"\t\th - 显示/隐藏-对象直方图\n"</span></span><br><span class="line"><span class="string">"\t\tp - 暂停视频\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* keys =</span><br><span class="line">&#123; <span class="string">"&#123;1|  | 0 | camera number&#125;"</span></span><br><span class="line">&#125;;</span><br><span class="line">  <span class="comment">//-----------------------------------【main( )函数】--------------------------------------------</span></span><br><span class="line"><span class="comment">//描述：控制台应用程序的入口函数，我们的程序从这里开始</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ShowHelpText();</span><br><span class="line"></span><br><span class="line">VideoCapture cap; <span class="comment">//定义一个摄像头捕捉的类对象  </span></span><br><span class="line">Rect trackWindow;  </span><br><span class="line"><span class="keyword">int</span> hsize = <span class="number">16</span>;  <span class="comment">//---------------------------------------------------------------------------------------------精度</span></span><br><span class="line"><span class="keyword">float</span> hranges[] = &#123;<span class="number">0</span>,<span class="number">180</span>&#125;;<span class="comment">//直方图的范围//hranges在后面的计算直方图函数中要用到  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span>* phranges = hranges;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cap.open(<span class="number">0</span>); <span class="comment">//直接调用成员函数打开摄像头  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( !cap.isOpened() )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"不能初始化摄像头\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namedWindow( <span class="string">"Histogram"</span>, <span class="number">0</span> );</span><br><span class="line">namedWindow( <span class="string">"CamShift Demo"</span>, <span class="number">0</span> );</span><br><span class="line">setMouseCallback( <span class="string">"CamShift Demo"</span>, onMouse, <span class="number">0</span> );<span class="comment">//消息响应机制 </span></span><br><span class="line"><span class="comment">//createTrackbar函数的功能是在对应的窗口创建滑动条，</span></span><br><span class="line"><span class="comment">//滑动条Vmin,vmin表示滑动条的值，最大为256  </span></span><br><span class="line">createTrackbar( <span class="string">"Vmin"</span>, <span class="string">"CamShift Demo"</span>, &amp;vmin, <span class="number">256</span>, <span class="number">0</span> );</span><br><span class="line"><span class="comment">//最后一个参数为0代表没有调用滑动拖动的响应函数  </span></span><br><span class="line">createTrackbar( <span class="string">"Vmax"</span>, <span class="string">"CamShift Demo"</span>, &amp;vmax, <span class="number">256</span>, <span class="number">0</span> );</span><br><span class="line"><span class="comment">//vmin,vmax,smin初始值分别为10,256,30  </span></span><br><span class="line">createTrackbar( <span class="string">"Smin"</span>, <span class="string">"CamShift Demo"</span>, &amp;smin, <span class="number">256</span>, <span class="number">0</span> );</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CV_8UC1，CV_8UC2，CV_8UC3。最后的1、2、3表示通道数，譬如RGB3通道就用CV_8UC3。</span></span><br><span class="line"><span class="comment">CV_8UC3 表示使用8位的 unsigned char 型，每个像素由三个元素组成三通道,</span></span><br><span class="line"><span class="comment">初始化为（0，0，255） </span></span><br><span class="line"><span class="comment">http://blog.csdn.net/augusdi/article/details/8876459</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Mat::zeros 返回指定的大小和类型的零数组。</span></span><br><span class="line"><span class="comment">C++: static MatExpr Mat::zeros(int rows, int cols, int type)</span></span><br><span class="line"><span class="comment">rows–行数。cols  –列数。type– 创建的矩阵的类型。</span></span><br><span class="line"><span class="comment">A = Mat::zeros （3，3，CV_32F）；</span></span><br><span class="line"><span class="comment">在上面的示例中，只要A不是 3 x 3浮点矩阵它就会被分配新的矩阵。</span></span><br><span class="line"><span class="comment">否则为现有的矩阵 A填充零。</span></span><br><span class="line"><span class="comment">转自:http://blog.csdn.net/sherrmoo/article/details/40951997</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">hist 直方图数字矩阵 最后 -&gt; histimg 直方图图像</span></span><br><span class="line"><span class="comment">hsv -&gt;（取出h） hue</span></span><br><span class="line"><span class="comment">mask？ 掩膜？  --------------------------------------------------------------------------------------------------？？？？？</span></span><br><span class="line"><span class="comment">backproj 反向投影的矩阵</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Mat frame, hsv, hue, mask, hist, histimg = Mat::zeros(<span class="number">200</span>, <span class="number">320</span>, CV_8UC3), backproj;</span><br><span class="line"><span class="keyword">bool</span> paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !paused )<span class="comment">//没有暂停  </span></span><br><span class="line">&#123;</span><br><span class="line">cap &gt;&gt; frame;<span class="comment">//从摄像头抓取一帧图像并输出到frame中  </span></span><br><span class="line"><span class="keyword">if</span>( frame.empty() )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame.copyTo(image);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( !paused )<span class="comment">//没有按暂停键  </span></span><br><span class="line">&#123;  </span><br><span class="line">cvtColor(image, hsv, CV_BGR2HSV);<span class="comment">//将rgb摄像头帧转化成hsv空间的  --------------------转hsv</span></span><br><span class="line"><span class="comment">//trackObject初始化为0,或者按完键盘的'c'键后也为0，当鼠标单击松开后为-1  </span></span><br><span class="line"><span class="keyword">if</span>( trackObject )</span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">int</span> _vmin = vmin, _vmax = vmax;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inRange函数的功能是检查输入数组每个元素大小是否在2个给定数值之间，</span></span><br><span class="line"><span class="comment">可以有多通道,mask保存0通道的最小值，也就是h分量  </span></span><br><span class="line"><span class="comment">这里利用了hsv的3个通道，</span></span><br><span class="line"><span class="comment">比较h,0~180,s,smin~256,v,min(vmin,vmax),max(vmin,vmax)。</span></span><br><span class="line"><span class="comment">如果3个通道都在对应的范围内，则  </span></span><br><span class="line"><span class="comment">mask对应的那个点的值全为1(0xff)，否则为0(0x00).  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">inRange(hsv, Scalar(<span class="number">0</span>, smin, MIN(_vmin,_vmax)),  </span><br><span class="line">Scalar(<span class="number">180</span>, <span class="number">256</span>, MAX(_vmin, _vmax)), mask);  </span><br><span class="line"><span class="keyword">int</span> ch[] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;  </span><br><span class="line"><span class="comment">//hue初始化为与hsv大小深度一样的矩阵，色调的度量是用角度表示的，</span></span><br><span class="line"><span class="comment">//红绿蓝之间相差120度，反色相差180度  </span></span><br><span class="line">hue.create(hsv.size(), hsv.depth());<span class="comment">//HSV(Hue, Saturation, Value)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int from_to[] = &#123; 0,2, 1,1, 2,0, 3,3 &#125;;</span></span><br><span class="line"><span class="comment">mixChannels( &amp;rgba, 1, out, 2, from_to, 4 );</span></span><br><span class="line"><span class="comment">from_to:通道交换对，数组中每两个元素为一对，表示对应的交换通道</span></span><br><span class="line"><span class="comment">pair_count：通道交换对个数（即*from_to数组中行数）</span></span><br><span class="line"><span class="comment">http://blog.163.com/jinlong_zhou_cool/blog/static/22511507320138932215239/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bgr 三原色RGB混合能形成其他的颜色，所以不能用一个值来表示颜色</span></span><br><span class="line"><span class="comment">hsv H是色彩  S是深浅,S = 0时，只有灰度  V是明暗 </span></span><br><span class="line"><span class="comment">hsv -&gt; hue 把色彩单独分出来</span></span><br><span class="line"><span class="comment">http://blog.csdn.net/viewcode/article/details/8203728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mixChannels(&amp;hsv, <span class="number">1</span>, &amp;hue, <span class="number">1</span>, ch, <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( trackObject &lt; <span class="number">0</span> )<span class="comment">//鼠标选择区域松开后，该函数内部又将其赋值-1  </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">//此处的构造函数roi用的是Mat hue的矩阵头，</span></span><br><span class="line"><span class="comment">//且roi的数据指针指向hue，即共用相同的数据，select为其感兴趣的区域  </span></span><br><span class="line">Mat roi(hue, selection), maskroi(mask, selection);//mask保存的hsv的最小值  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将roi的0通道计算直方图并通过mask放入hist中，hsize为每一维直方图的大小  </span></span><br><span class="line"><span class="comment">calcHist函数来计算图像直方图</span></span><br><span class="line"><span class="comment">---calcHist函数调用形式</span></span><br><span class="line"><span class="comment">C++: void calcHist(const Mat* images, int nimages, const int* channels, </span></span><br><span class="line"><span class="comment">InputArray mask, OutputArray hist, int dims, const int* histSize,</span></span><br><span class="line"><span class="comment">const float** ranges, bool uniform=true, bool accumulate=false </span></span><br><span class="line"><span class="comment">参数详解</span></span><br><span class="line"><span class="comment">onst Mat* images：输入图像</span></span><br><span class="line"><span class="comment">int nimages：输入图像的个数</span></span><br><span class="line"><span class="comment">const int* channels：需要统计直方图的第几通道</span></span><br><span class="line"><span class="comment">InputArray mask：掩膜，，计算掩膜内的直方图  ...Mat()</span></span><br><span class="line"><span class="comment">OutputArray hist:输出的直方图数组</span></span><br><span class="line"><span class="comment">int dims：需要统计直方图通道的个数</span></span><br><span class="line"><span class="comment">const int* histSize：指的是直方图分成多少个区间，，，就是 bin的个数</span></span><br><span class="line"><span class="comment">const float** ranges： 统计像素值得区间</span></span><br><span class="line"><span class="comment">bool uniform=true::是否对得到的直方图数组进行归一化处理</span></span><br><span class="line"><span class="comment">bool accumulate=false：在多个图像时，是否累计计算像素值得个数</span></span><br><span class="line"><span class="comment">http://blog.csdn.net/qq_18343569/article/details/48027639</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="comment">//--------------------------------------calcHist源代码要不要去找找看？</span></span><br><span class="line">calcHist(&amp;roi, <span class="number">1</span>, <span class="number">0</span>, maskroi, hist, <span class="number">1</span>, &amp;hsize, &amp;phranges);  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将hist矩阵进行数组范围归一化，都归一化到0~255  </span></span><br><span class="line"><span class="comment">void normalize(const InputArray src, OutputArray dst, double alpha=1,</span></span><br><span class="line"><span class="comment">double beta=0,</span></span><br><span class="line"><span class="comment">int normType=NORM_L2, int rtype=-1, InputArray mask=noArray())</span></span><br><span class="line"><span class="comment">当用于归一化时，normType应该为cv::NORM_MINMAX，alpha为归一化后的最大值，</span></span><br><span class="line"><span class="comment">beta为归一化后的最小值</span></span><br><span class="line"><span class="comment">http://www.cnblogs.com/mikewolf2002/archive/2012/10/24/2736504.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">normalize(hist, hist, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line"></span><br><span class="line">trackWindow = selection;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">只要鼠标选完区域松开后，且没有按键盘清0键'c'，则trackObject一直保持为1，</span></span><br><span class="line"><span class="comment">因此该if函数  if( trackObject &lt; 0 )  只能执行一次，除非重新选择跟踪区域。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">trackObject = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">与按下'c'键是一样的，这里的all(0)表示的是标量 全部清0  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">inline CvScalar cvScalarAll( double val0123 );</span></span><br><span class="line"><span class="comment">同时设定VAL0,1,2,3的值；</span></span><br><span class="line"><span class="comment">OpenCV里的Scalar：all的意思：</span></span><br><span class="line"><span class="comment">scalar所有元素设置为0，其实可以scalar::all(n)，就是原来的CvScalarAll(n)；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">histimg = Scalar::all(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">histing是一个200*300的矩阵，hsize应该是每一个bin的宽度，</span></span><br><span class="line"><span class="comment">也就是histing矩阵能分出几个bin出来</span></span><br><span class="line"><span class="comment">opencv直方图的bins中存储的是什么?</span></span><br><span class="line"><span class="comment">https://zhidao.baidu.com/question/337997654.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">假设 有数值 0,0,1,2,3,10,12，13 。</span></span><br><span class="line"><span class="comment">你分的bins为 0-6 为第一个bin，7-13 为一个bins。</span></span><br><span class="line"><span class="comment">那么bins[0] 即第一个bins 存储的数就是 4，</span></span><br><span class="line"><span class="comment">原因是 0,0,1,2,3在第一个bin的范围内，</span></span><br><span class="line"><span class="comment">bins[1] 存储的数为 3，原因是 10,12,13落在这个[7-13]这个bin内。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Line111 : hsize=16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> binW = histimg.cols / hsize; <span class="comment">//算出宽</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Mat::Mat(); //default  </span></span><br><span class="line"><span class="comment">Mat::Mat(int rows, int cols, int type);  </span></span><br><span class="line"><span class="comment">Mat::Mat(Size size, int type);  </span></span><br><span class="line"><span class="comment">Mat::Mat(int rows, int cols, int type, const Scalar&amp; s);  </span></span><br><span class="line"><span class="comment">参数说明：  </span></span><br><span class="line"><span class="comment">int rows：高  </span></span><br><span class="line"><span class="comment">int cols：宽  </span></span><br><span class="line"><span class="comment">int type：参见"Mat类型定义"  </span></span><br><span class="line"><span class="comment">Size size：矩阵尺寸，注意宽和高的顺序：Size(cols, rows)  </span></span><br><span class="line"><span class="comment">const Scalar&amp; s：用于初始化矩阵元素的数值  </span></span><br><span class="line"><span class="comment">const Mat&amp; m：拷贝m的矩阵头给新的Mat对象，</span></span><br><span class="line"><span class="comment">但是不复制数据！相当于创建了m的一个引用对象 </span></span><br><span class="line"><span class="comment">转自：http://blog.csdn.net/holybin/article/details/17751063</span></span><br><span class="line"><span class="comment">定义一个缓冲单bin矩阵。这里使用的是第二个 重载 函数。</span></span><br><span class="line"><span class="comment">重载函数：https://baike.baidu.com/item/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/3280477?fr=aladdin</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Mat <span class="title">buf</span><span class="params">(<span class="number">1</span>, hsize, CV_8UC3)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">saturate_cast函数为从一个初始类型准确变换到另一个初始类型  </span></span><br><span class="line"><span class="comment">saturate_cast&lt;uchar&gt;(int v)的作用 就是防止数据溢出，</span></span><br><span class="line"><span class="comment">具体的原理可以大致描述如下：</span></span><br><span class="line"><span class="comment">if(data&lt;0)</span></span><br><span class="line"><span class="comment">data=0;</span></span><br><span class="line"><span class="comment">if(data&gt;255)</span></span><br><span class="line"><span class="comment">data=255</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">转自:http://blog.csdn.net/wenhao_ir/article/details/51545330?locationNum=10&amp;fps=1</span></span><br><span class="line"><span class="comment">Vec3b为3个char值的向量 </span></span><br><span class="line"><span class="comment">CV_8UC3 表示使用8位的 unsigned char 型，每个像素由三个元素组成三通道,</span></span><br><span class="line"><span class="comment">初始化为（0，0，255） </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hsize; i++ )</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">互补色相差180度</span></span><br><span class="line"><span class="comment">颜色-&gt;hsv-&gt;hue(0,255)-&gt;roi-&gt;hist(0,255)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以这里只是，以i为输入，把直方图本来各个矩形的颜色算出来，放在buf里。</span></span><br><span class="line"><span class="comment">hsv三个值的取值范围: </span></span><br><span class="line"><span class="comment">h 0-180</span></span><br><span class="line"><span class="comment">s 0-255</span></span><br><span class="line"><span class="comment">v 0-255</span></span><br><span class="line"><span class="comment">http://blog.csdn.net/taily_duan/article/details/51506776</span></span><br><span class="line"><span class="comment">https://wenku.baidu.com/view/eb2d600dbb68a98271fefadc.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">buf.at&lt;Vec3b&gt;(i) = Vec3b(saturate_cast&lt;uchar&gt;(i*<span class="number">180.</span>/hsize), <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">cvtColor(buf, buf, CV_HSV2BGR);<span class="comment">//将hsv又转换成bgr，画矩形颜色的用BGR格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hsize; i++ )<span class="comment">//画直方图 </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at函数为返回一个指定数组元素的参考值</span></span><br><span class="line"><span class="comment">histimg.rows常量=200</span></span><br><span class="line"><span class="comment">val决定各个矩形的高度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> val = saturate_cast&lt;<span class="keyword">int</span>&gt;(hist.at&lt;<span class="keyword">float</span>&gt;(i)*histimg.rows/<span class="number">255</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++: void rectangle(Mat&amp; img, Rect rec, const Scalar&amp; color, int thickness=1, int lineType=8, int shift=0 )</span></span><br><span class="line"><span class="comment">参数介绍：</span></span><br><span class="line"><span class="comment">img 图像.</span></span><br><span class="line"><span class="comment">pt1 矩形的一个顶点。</span></span><br><span class="line"><span class="comment">pt2 矩形对角线上的另一个顶点</span></span><br><span class="line"><span class="comment">color 线条颜色 (RGB) 或亮度（灰度图像 ）(grayscale image）。</span></span><br><span class="line"><span class="comment">thickness 组成矩形的线条的粗细程度。取负值时（如 CV_FILLED）</span></span><br><span class="line"><span class="comment">函数绘制填充了色彩的矩形。</span></span><br><span class="line"><span class="comment">line_type 线条的类型。见cvLine的描述 </span></span><br><span class="line"><span class="comment">https://zhidao.baidu.com/question/427970238676959132.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">shift 坐标点的小数点位数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">histimg.rows是一个常量。histmig.rows=200</span></span><br><span class="line"><span class="comment">Scalar(buf.at&lt;Vec3b&gt;(i))  buf是颜色</span></span><br><span class="line"><span class="comment">计算机里，坐标在左上角，x轴朝右，y朝下</span></span><br><span class="line"><span class="comment">val决定各个矩形的高度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">rectangle( histimg, Point(i*binW,histimg.rows),    </span><br><span class="line">Point((i+<span class="number">1</span>)*binW,histimg.rows - val),  </span><br><span class="line">Scalar(buf.at&lt;Vec3b&gt;(i)), <span class="number">-1</span>, <span class="number">8</span> );  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反向投影 = = 吓蒙我</span></span><br><span class="line"><span class="comment">http://blog.csdn.net/qq_18343569/article/details/48028065</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">calcBackProject(&amp;hue, <span class="number">1</span>, <span class="number">0</span>, hist, backproj, &amp;phranges);</span><br><span class="line"><span class="comment">//相与??????这一句注释了也没事 = = ------加上的话，整体来说，噪音要少很多</span></span><br><span class="line">backproj &amp;= mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Camshift它是MeanShift算法(Mean Shift算法，又称为均值漂移算法)的改进，</span></span><br><span class="line"><span class="comment">称为连续自适应的MeanShift算法，</span></span><br><span class="line"><span class="comment">CamShift算法的全称是"Continuously Adaptive Mean-SHIFT"，</span></span><br><span class="line"><span class="comment">它的基本思想是视频图像的所有帧作MeanShift运算，并将上一帧的结果</span></span><br><span class="line"><span class="comment">（即Search Window的中心和大小）</span></span><br><span class="line"><span class="comment">作为下一帧MeanShift算法的Search Window的初始值，如此迭代下去。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于OPENCV中的CAMSHIFT例子，是通过计算目标HSV空间下的HUE分量直方图，</span></span><br><span class="line"><span class="comment">通过直方图反向投影得到目标像素的概率分布，</span></span><br><span class="line"><span class="comment">然后通过调用CV库中的CAMSHIFT算法，自动跟踪并调整目标窗口的中心位置与大小。</span></span><br><span class="line"><span class="comment">https://baike.baidu.com/item/Camshift/5302311?fr=aladdin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cvCamShift(IplImage* imgprob, CvRect windowIn, CvTermCriteria criteria,</span></span><br><span class="line"><span class="comment">CvConnectedComp* out, CvBox2D* box=0);</span></span><br><span class="line"><span class="comment">imgprob：色彩概率分布图像。</span></span><br><span class="line"><span class="comment">windowIn：Search Window的初始值。</span></span><br><span class="line"><span class="comment">Criteria：用来判断搜寻是否停止的一个标准。</span></span><br><span class="line"><span class="comment">out：保存运算结果,包括新的Search Window的位置和面积。</span></span><br><span class="line"><span class="comment">box：包含被跟踪物体的最小矩形。</span></span><br><span class="line"><span class="comment">http://blog.csdn.net/houdy/article/details/191828</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CV_INLINE  CvTermCriteria  cvTermCriteria( int type, int max_iter, </span></span><br><span class="line"><span class="comment">double epsilon )  </span></span><br><span class="line"><span class="comment">&#123;  </span></span><br><span class="line"><span class="comment">CvTermCriteria t;  </span></span><br><span class="line"><span class="comment">t.type = type;  </span></span><br><span class="line"><span class="comment">t.max_iter = max_iter;  </span></span><br><span class="line"><span class="comment">t.epsilon = (float)epsilon;    </span></span><br><span class="line"><span class="comment">return t;  </span></span><br><span class="line"><span class="comment">&#125;  </span></span><br><span class="line"><span class="comment">该函数是内联函数，返回的值为CvTermCriteria结构体。</span></span><br><span class="line"><span class="comment">看得出该函数还是c接口想使用c语言来模拟面向对象的结构，其中的参数为：</span></span><br><span class="line"><span class="comment">type：</span></span><br><span class="line"><span class="comment">- CV_TERMCRIT_ITER  在当算法迭代次数超过max_iter的时候终止。</span></span><br><span class="line"><span class="comment">- CV_TERMCRIT_EPS   在当算法得到的精度低于epsolon时终止；</span></span><br><span class="line"><span class="comment">-CV_TERMCRIT_ITER+CV_TERMCRIT_EPS  </span></span><br><span class="line"><span class="comment">当算法迭代超过max_iter或者当获得的精度低于epsilon的时候，哪个先满足就停止</span></span><br><span class="line"><span class="comment">max_iter：迭代的最大次数</span></span><br><span class="line"><span class="comment">epsilon：要求的精度</span></span><br><span class="line"><span class="comment">http://www.cnblogs.com/shouhuxianjian/p/4529174.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">L231 trackWindow = selection; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//trackWindow为鼠标选择的区域，TermCriteria为确定迭代终止的准则</span></span><br><span class="line">RotatedRect trackBox = CamShift(backproj, trackWindow,</span><br><span class="line"><span class="comment">//CV_TERMCRIT_EPS是通过forest_accuracy,CV_TERMCRIT_ITER 是通过max_num_of_trees_in_the_forest    </span></span><br><span class="line">TermCriteria( CV_TERMCRIT_EPS | CV_TERMCRIT_ITER, <span class="number">10</span>, <span class="number">1</span> ));</span><br><span class="line"><span class="keyword">if</span>( trackWindow.area() &lt;= <span class="number">1</span> )       <span class="comment">//如果trackWindow 找到解了？-----？？？</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">int</span> cols = backproj.cols, rows = backproj.rows, r = (MIN(cols, rows) + <span class="number">5</span>)/<span class="number">6</span>;  </span><br><span class="line">trackWindow = Rect(trackWindow.x - r, trackWindow.y - r,  </span><br><span class="line">trackWindow.x + r, trackWindow.y + r) &amp;    <span class="comment">//相与是什么意思？？？</span></span><br><span class="line"><span class="comment">//Rect函数为矩阵的偏移和大小，即第一二个参数为矩阵的左上角点坐标，</span></span><br><span class="line"><span class="comment">//第三四个参数为矩阵的宽和高  </span></span><br><span class="line">Rect(<span class="number">0</span>, <span class="number">0</span>, cols, rows);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( backprojMode )</span><br><span class="line"><span class="comment">//因此投影模式下显示的也是rgb图？</span></span><br><span class="line">cvtColor( backproj, image, COLOR_GRAY2BGR );</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void cvEllipse( CvArr* img, CvPoint center, CvSize axes, double angle,</span></span><br><span class="line"><span class="comment">                double start_angle, double end_angle, CvScalar color,</span></span><br><span class="line"><span class="comment">                int thickness=1, int line_type=8, int shift=0 );</span></span><br><span class="line"><span class="comment">img图像。</span></span><br><span class="line"><span class="comment">center椭圆圆心坐标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">axes轴的长度。</span></span><br><span class="line"><span class="comment">angle偏转的角度。</span></span><br><span class="line"><span class="comment">start_angle圆弧起始角的角度。</span></span><br><span class="line"><span class="comment">end_angle圆弧终结角的角度。</span></span><br><span class="line"><span class="comment">color线条的颜色。</span></span><br><span class="line"><span class="comment">thickness线条的粗细程度。</span></span><br><span class="line"><span class="comment">line_type线条的类型,见CVLINE的描述。</span></span><br><span class="line"><span class="comment">shift圆心坐标点和数轴的精度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lineType – 线型</span></span><br><span class="line"><span class="comment">Type of the line:</span></span><br><span class="line"><span class="comment">8 (or omitted) - 8-connected line.</span></span><br><span class="line"><span class="comment">4 - 4-connected line.</span></span><br><span class="line"><span class="comment">CV_AA - antialiased line. 抗锯齿线。</span></span><br><span class="line"><span class="comment">shift – 坐标点小数点位数.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">跟踪的时候以椭圆为代表目标  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ellipse( image, trackBox, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span>, CV_AA );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后面的代码是不管pause为真还是为假都要执行的  </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( trackObject &lt; <span class="number">0</span> )<span class="comment">//同时也是在按了暂停字母以后  </span></span><br><span class="line">paused = <span class="literal">false</span>;  </span><br><span class="line"><span class="comment">//---------------------???在这里有什么作用？只有L220 用到了roi--------------------????</span></span><br><span class="line"><span class="keyword">if</span>( selectObject &amp;&amp; selection.width &gt; <span class="number">0</span> &amp;&amp; selection.height &gt; <span class="number">0</span> )</span><br><span class="line">&#123;  </span><br><span class="line"><span class="function">Mat <span class="title">roi</span><span class="params">(image, selection)</span></span>;  </span><br><span class="line">bitwise_not(roi, roi);<span class="comment">//bitwise_not为将每一个bit位取反  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">imshow( <span class="string">"CamShift Demo"</span>, image );  </span><br><span class="line">imshow( <span class="string">"Histogram"</span>, histimg );  </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">waitKey(x);</span></span><br><span class="line"><span class="comment">第一个参数： 等待x ms，如果在此期间有按键按下，则立即结束并返回按下按键的</span></span><br><span class="line"><span class="comment">ASCII码，否则返回-1</span></span><br><span class="line"><span class="comment">如果x=0，那么无限等待下去，直到有按键按下</span></span><br><span class="line"><span class="comment">http://blog.sina.com.cn/s/blog_82a790120101jsp1.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)waitKey(<span class="number">10</span>);  </span><br><span class="line"><span class="keyword">if</span>( c == <span class="number">27</span> )              <span class="comment">//退出键  </span></span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">switch</span>(c)  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">case</span> <span class="string">'b'</span>:             <span class="comment">//反向投影模型  img/mask交替  </span></span><br><span class="line">backprojMode = !backprojMode;  </span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> <span class="string">'c'</span>:            <span class="comment">//清零跟踪目标对象  </span></span><br><span class="line">trackObject = <span class="number">0</span>;  </span><br><span class="line">histimg = Scalar::all(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>:          <span class="comment">//显示直方图交替  </span></span><br><span class="line">showHist = !showHist;  </span><br><span class="line"><span class="keyword">if</span>( !showHist )  </span><br><span class="line">destroyWindow( <span class="string">"Histogram"</span> );    <span class="comment">//好像并没有destroy 还是看不出来 = =</span></span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">namedWindow( <span class="string">"Histogram"</span>, <span class="number">1</span> );  </span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> <span class="string">'p'</span>:       <span class="comment">//暂停跟踪交替  </span></span><br><span class="line">paused = !paused;  </span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理_计算器_Flex、bison实现_（从零开始)</title>
      <link href="/tech/8c051d09.html"/>
      <url>/tech/8c051d09.html</url>
      
        <content type="html"><![CDATA[<p><strong>目标</strong>：参考范例程序, 用 Flex 和 Bison 实现一个功能更为强大的计算器，包含以下运算：<br>a) 加、减、乘、除运算<br>b) 乘方、开方运算<br>c) 位运算<br>– 与 &amp; 、或 |、非 ~…<br>d) 阶乘运算 !<br>e)sin cos tan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sin（SIN*pi/180.0）//把角度变成弧度即把180度变成π</span><br></pre></td></tr></table></figure><p>如果要写实验报告的话，请先看报告书的要求，一边截图一边编程，免得写报告的时候，浪费时间。</p><h2 id="p-s-这篇文章只能助你改程序-并不能让你从零独自编写出程序-附赠安装配置环境的教程-毕竟很多人卡在第一步嘛-▽">P.S. 这篇文章只能助你改程序，并不能让你从零独自编写出程序 附赠安装配置环境的教程（毕竟很多人卡在第一步嘛(￣▽￣)／）</h2><h2 id="一-环境配置：windows-ubuntu-flex-bison">一 环境配置：Windows/Ubuntu+flex、bison</h2><h3 id="1-使用windows-codeblocks-flex-bison的环境-有两种方式">\1 使用Windows+CodeBlocks+flex、bison的环境（有两种方式）</h3><h4 id="方式1-借助codeblcoks编译-运行">方式1 借助codeblcoks编译、运行。</h4><p><a href="https://pan.baidu.com/s/1psFYKwBpaPHhKSoTx6d2_w">flex_bison 下载</a>   百度云密码：usk6<br><a href="https://pan.baidu.com/s/1sQ1VtUIzmGq1zY3EFNeWRQ">flex_bison 备用下载链接</a><br>1）下载百度云里的flex和bison。放到windows环境下。<br><strong>2）<strong>把.l文件和.y文件复制到该文件下<br>3）在</strong>2）<strong>文件夹的地址栏（也就是下图画红圈的地方），输入</strong>cmd</strong><br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2017-10-16-1-19898.png" alt="1"><br>4）在cmd里输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex -ocalc.c calc.l</span><br><span class="line">bison -ocalc.tab.h calc.y  //注意-o后面没有空格</span><br></pre></td></tr></table></figure><p>这样，会生成两个文件，calc.tab.h 和 calc.c<br>然后，把生成的.c文件（calc.c），丢进 <strong>codeblocks</strong>里，编译，运行。</p><hr><h4 id="方式2-配置mingw直接在cmd下编译-运行">方式2 配置MinGW直接在cmd下编译、运行。</h4><p><a href="https://pan.baidu.com/s/1psFYKwBpaPHhKSoTx6d2_w">flex_bison 下载</a>   百度云密码：usk6<br><a href="https://pan.baidu.com/s/1sQ1VtUIzmGq1zY3EFNeWRQ">flex_bison 备用下载链接</a><br>1）下载百度云里的flex和bison。放到windows环境下。<br><strong>2）<strong>把.l文件和.y文件复制到该文件下<br>3）把%codeblocks%\MinGW\bin添加到 电脑\属性\高级系统设置\环境变量\PATH（即把codeblocks的编译器的路径放到环境变量PATH里）<br>4）在</strong>2）<strong>文件夹的地址栏（也就是下图画红圈的地方），输入</strong>cmd</strong><br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2017-10-16-2-19898.png" alt="2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex  calc.l</span><br><span class="line">bison -o calc.tab.h calc.y  //注意-o后面有没有空格都可以 ==</span><br><span class="line">gcc -o aa lex.yy.c calc.tab.h  //编译</span><br><span class="line">aa//运行aa.exe</span><br></pre></td></tr></table></figure><p>这种方式，会生成两个文件，calc.tab.h 、calc.tab.c 和 calc.c<br>这样，就直接在<strong>cmd</strong>界面，运行程序，而不要通过codeblocks。</p><h3 id="2-使用ubuntu-flex-bison的环境-来编译-运行">\2  使用Ubuntu+flex、bison的环境，来编译、运行。</h3><p><a href="http://blog.csdn.net/qq_35208390/article/details/78271743"> vm12+ubuntukylin16.04 虚拟机安装</a>ヾ(o◕∀◕)ﾉヾ   (❁´︶`❁)<br>然后，在ubuntu安装flex、bison并完成编译<br><font color="blue">老版本的ubuntu可能这样安装不了，这种情况，我只能说。。。。。重装一下ubuntu？（逃</font></p><p>ubuntu下打开终端，安装flex、bison：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flex bison//安装flex和bison</span><br><span class="line">flex -h</span><br><span class="line">bison -h//如果有提示信息表示安装成功</span><br></pre></td></tr></table></figure><p>编译和运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ........./calcSimple//移动到程序的当前目录</span><br><span class="line">bison -d calc.y</span><br><span class="line">flex calc.l</span><br><span class="line">/*</span><br><span class="line">-lm在提示pow未定义引用时添加。</span><br><span class="line">编译lex.yy.c calc.tab.c 用-o输出到calc</span><br><span class="line">*/</span><br><span class="line">gcc -o calc lex.yy.c calc.tab.c  -lm </span><br><span class="line">./calc//运行calc</span><br></pre></td></tr></table></figure><hr><p>如果有 <strong>正确的 Makefile文件</strong> 的话，直接输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br><span class="line">./calc</span><br></pre></td></tr></table></figure><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2017-10-16-3-19898.png" alt="3"></p><h2 id="二-一个简单的示例代码calcsimple下载">二 一个简单的示例代码calcSimple下载</h2><p>链接：<a href="http://pan.baidu.com/s/1slc9aPn">http://pan.baidu.com/s/1slc9aPn</a> 密码：uyyi</p><h3 id="calc-l"><strong>calc.l</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%option noyywrap</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">    /*</span><br><span class="line">     *  一个简单计算器的Lex词法文件</span><br><span class="line">     */</span><br><span class="line">void yyerror(char*);</span><br><span class="line">#include &quot;calc.tab.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">     /* a-z为变量 */   </span><br><span class="line">[a-z]&#123;</span><br><span class="line">            yylval = *yytext - &apos;a&apos;;</span><br><span class="line">            return VARIABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 整数 */</span><br><span class="line">[0-9]+&#123;</span><br><span class="line">            yylval = atoi(yytext);</span><br><span class="line">            return INTEGER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 运算符 */</span><br><span class="line">[-+()=/*\n]&#123;return *yytext;&#125;</span><br><span class="line"></span><br><span class="line">    /* 空白被忽略 */</span><br><span class="line">[ \t]    ;</span><br><span class="line"></span><br><span class="line">    /* 其他字符都是非法的 */</span><br><span class="line">.    yyerror(&quot;无效的输入字符&quot;);</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure><hr><p>###<strong>calc.y</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">%token    INTEGER VARIABLE</span><br><span class="line">%left    &apos;+&apos; &apos;-&apos;</span><br><span class="line">%left    &apos;*&apos; &apos;/&apos;</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">/*for Visual studio */</span><br><span class="line">/*#define  __STDC__   0   */   </span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">    void yyerror(char*);</span><br><span class="line">    int yylex(void);</span><br><span class="line"></span><br><span class="line">    int sym[26];</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">program:</span><br><span class="line">    program statement &apos;\n&apos;</span><br><span class="line">    |</span><br><span class="line">    ;</span><br><span class="line">statement:</span><br><span class="line">     expr    &#123;printf(&quot;%d\n&quot;, $1);&#125;</span><br><span class="line">     |VARIABLE &apos;=&apos; expr    &#123;sym[$1] = $3;&#125;</span><br><span class="line">     ;</span><br><span class="line">expr:</span><br><span class="line">    INTEGER</span><br><span class="line">    |VARIABLE&#123;$$ = sym[$1];&#125;</span><br><span class="line">    |expr &apos;+&apos; expr    &#123;$$ = $1 + $3;&#125;</span><br><span class="line">    |expr &apos;-&apos; expr    &#123;$$ = $1 - $3;&#125;</span><br><span class="line">    |expr &apos;*&apos; expr    &#123;$$ = $1 * $3;&#125;</span><br><span class="line">    |expr &apos;/&apos; expr    &#123;$$ = $1 / $3;&#125;</span><br><span class="line">    |&apos;(&apos;expr&apos;)&apos;    &#123;$$ = $2;&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">void yyerror(char* s)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s\n&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;A simple calculator.\n&quot;);</span><br><span class="line">    yyparse();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三-把-calcsimple-修改成-完整版的计算器-全攻略">三 把 calcSimple 修改成 完整版的计算器 全攻略</h2><p><font color="blue">此小节简略说明一下.l文件和.y文件，如果想更多的了解这个程序的意义，请看下文</font><br>在calcSimple的基础上，</p><p>在.l文件里添加:（注意中/英文的标点符号不一样）<br>/* 运算符 <em>/<br>[-+()=/</em><font color="blue">!</font>\n]   {return *yytext;}</p><p>在.y文件里添加文法部分:<br>|expr <font color="blue">‘!’</font>      {int i,s=1;for(int i=1;i&lt;=$2;i++)s*=i;$$=s;}<br>这里用到了c语言，所以要在.y程序第二部分即%｛｝%里面添加<code>#include&lt;stdio.h&gt;</code></p><p>然后在.y文件开头添加 %right <font color="blue">'!'</font><br>这里表示左/右结合性，以及运算符优先级，越是在下面优先级越高</p><p>仿照以下两个程序，把运算符都添加进去，就完成了基本完整的计算器。<br><a href="http://blog.csdn.net/xiaofeige567/article/details/28301877">http://blog.csdn.net/xiaofeige567/article/details/28301877</a><br><a href="http://blog.csdn.net/ly_624/article/details/51125482">http://blog.csdn.net/ly_624/article/details/51125482</a></p><h2 id="四-非常重要的-两个学长学姐的-示例程序">四 非常重要的 两个学长学姐的 示例程序。</h2><p>两个学长学姐，写的很清晰易懂，但不能直接使用，不清楚为什么，仅供参考。==<br>两个代码差别挺大的。<br><a href="http://blog.csdn.net/xiaofeige567/article/details/28301877">http://blog.csdn.net/xiaofeige567/article/details/28301877</a><br><a href="http://blog.csdn.net/ly_624/article/details/51125482">http://blog.csdn.net/ly_624/article/details/51125482</a></p><h2 id="五-理解-l-文件和-y-文件">五 理解 <code>.l</code> 文件和 <code>.y</code> 文件</h2><h3 id="1-查阅龙书-编译原理-中文第二版-p86和p170">\1 查阅龙书（编译原理）中文第二版(P86和P170 )</h3><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2017-10-16-4-19898.png" alt="4"><br>(lex和yacc是Unix的软件，而flex和bison是其在ubantu（linux下）的兼容版本)<br>P86   详细解释了flex（lex）软件的 代码。也就是calc.l文件的详细解释<br>P170 详细解释了bison（yacc）软件的 代码。也就是calc.y文件的详细解释</p><h3 id="2-老师课件-上的解释">\2 老师课件 上的解释</h3><p>链接: <a href="http://pan.baidu.com/s/1o8FV43C">老师课件</a><br><code>2-词法分析-RE-Lex.pptx</code><br><code>YACC.pptx</code><br><code>实验-补充-LEX.pdf</code></p><hr><h2 id="六-词法分析-语法分析">六 词法分析&amp;语法分析</h2><h4 id="1-词法分析">\1 词法分析</h4><p>首先来看flex的使用：<br>简单来说分为两步：<br>1 先定义一个flex的输入文件，描述词法。<br>2 用flex程序处理这个文件，生成对应的C语言源代码文件。<br>（一般flex的输入文件以.l文件结尾， 比如这个文件calc.l）</p><p>文件分成三个部分</p><pre><code>第一部分是从 %{ 到 }% 标记的部分。 这个部分会原封不动的复制到flex的生成代码中。文件开头定义了一个YYSTYPE宏。每个TOKEN可以有一个lval值属性，YYSTYPE定义类型就是token的lval的类型。_EasyTData是我们的web服务层和web页面层公用的通用数据结构。然后就是一些要include的头文件，第一部分就完了。lex的输入文件的第二部分，是从 % } 到 % % 之间的部分，这部分用正则表达式定义了一些数据类型。 比如int num string ignore_char identifier等。 注意这里使用的正则表达式的形式是ERE而不是BRE。 ERE与BRE比较明显的区别就是，ERE使用+表示字符重复一次以上，*表示字符重复0次以上。BRE使用{1,}这种方式表示字符重a文件的第三部分，是% % 到% % 的部分。这里定义了词法分析器在解析的处理动作。yytext是一个flex内部的标识符，表示匹配到的字符串。上文介绍了，lval也是一个内部标识符，表示TOKEN的值。json2tdata_是标识符的前缀, 在执行flex的时候，用-P指定。flex输入文件写完之后，使用下面这条命令，就可以把flex的输入文件转换为C语言的源代码了。flex calc.l//生成lex.yy.c</code></pre><hr><h4 id="2-语法分析">\2 语法分析</h4><p>语法分析是使用bison工具。<br>使用bison工具也是分为两步，<br>第一步写bison的输入文件，第二步用bison程序生成C语言源码。<br>（bison的输入文件一般用.y作为后缀名。）</p><p>和flex的词法分析输入文件类似，bison的输入文件也是分成3部分。</p><pre><code>第一部分% {和% }之间，是原封不动拷贝到输出的C语言源文件中的。 json2tdata_lex这个函数是flex生成的。 json2tdata_error是用来处理错误信息的函数。通过定义和实现这个函数你可以把错误信息写到任何地方。与flex类似，json2tdata也是自定义的前缀。第二部分是%token INT NUM STRING R_BRACKET COLON SEMICOLON COMMA IDENTIFIER TRUE FALSE NIL这一行，这一行的作用就是声明在flex中定义的那些TOKEN。第三部分是% % % %包围的部分。这部分就是语法的推导过程。  可以比较轻松的看出，这部分主要就是采用BNF对语法进行描述。比如Array， 它有两种形式。第一种是 L_BRACKET ELEMENTS R_BRACKET,第二种则是L_BRACKET R_BRACKET， 这表示一个空的Array。Bison能够完全支持LR(1)文法。 这种文法的特点是只要多向前看一个TOKEN，就能够决定如何解析。因此如果bison告诉你语法ambiguous的时候，可以想一想如何把自己的文法改成LR(1)型文法。另外，每一条规则的后面可以用{}来定义解析的动作bison用$$表示规则左边的对象，用$1 $2 $3 等依次表示规则右边的对象。</code></pre><h2 id="七-编译-运行的时候-常见错误以及对策">七 编译、运行的时候，常见错误以及对策</h2><h3 id="1-shift-reduce-conflict">1）  …shift/reduce conflict…</h3><pre><code>最常见的情况是：在.l 和.y文件中没有添加相应 符号，或者没有写优先级</code></pre><h3 id="2-在原来的只能用整数的示例程序里添加-小数-的功能">2）  在原来的只能用整数的示例程序里添加 <strong>小数</strong> 的功能</h3><pre><code>  在 .l 和 .y 文件里添加 #define YYSTYPE double  在.l文件里 atoi（yytext）改为 atof（yytext）//一般会有错误提示，按照错误提示一个个改就好了。  为所有用到整数型的地方，添加强制类型转换 (int) </code></pre><h3 id="3-pow的未定义引用">3）  pow的未定义引用</h3><pre><code>两种可能  .y文件里没有添加math.h头文件  gcc -o calc lex.yy.c calc.tab.c -lm //没有添加-lm</code></pre><p>转自：<br><a href="http://blog.csdn.net/li740207611/article/details/51072111">http://blog.csdn.net/li740207611/article/details/51072111</a></p><pre><code>原因：Linux下用math.h库的pow()函数，gcc编译的时候报错返回：对‘pow’未定义的引用 查了下资料，需要在gcc编译的时候加上-lm参数才能正常编译。 这是为什么呢？再查了下资料： 使用math.h中声明的库函数还有一点特殊之处，gcc命令行必须加-lm选项，因为数学函数位于libm.so库文件中（这些库文件通常位于/lib目录下），-lm选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如printf）位于libc.so库文件中，使用libc.so中的库函数在编译时不需要加-lc选项，当然加了也不算错，因为这个选项是gcc的默认选项。</code></pre><p>以上，如有疏漏，敬请指正。</p><h2 id="八-源代码">八 源代码</h2><p>a.l文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    /*</span><br><span class="line">     *  一个简单计算器的Lex词法文件</span><br><span class="line">     */</span><br><span class="line">int yywrap();</span><br><span class="line">    #define YYSTYPE double</span><br><span class="line">void yyerror(char*);</span><br><span class="line">#include &quot;a.tab.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">     /* a-z为变量 */   </span><br><span class="line">[a-z]&#123;</span><br><span class="line">            yylval = *yytext - &apos;a&apos;;</span><br><span class="line">            return VARIABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    /*16进制数*/</span><br><span class="line">0x\.?[a-f0-9]+|0x[a-f0-9]+\.[a-f0-9]* &#123;</span><br><span class="line">        yylval=atof(yytext);</span><br><span class="line">    return HEXADECIMAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /* 整数或者小数 */</span><br><span class="line">\.?[0-9]+|[0-9]+\.[0-9]*&#123;</span><br><span class="line">            yylval = atof(yytext);</span><br><span class="line">            return INTEGER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 运算符 */</span><br><span class="line">[-+()=/*&amp;|~!^@\n]&#123;return *yytext;&#125;</span><br><span class="line"></span><br><span class="line">    /* 三角函数 */</span><br><span class="line">sin &#123;</span><br><span class="line">return SIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cos &#123;</span><br><span class="line">return COS;</span><br><span class="line">    &#125;</span><br><span class="line">tan &#123;</span><br><span class="line">return TAN;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 空白被忽略 */</span><br><span class="line">[ \t]    ;</span><br><span class="line"></span><br><span class="line">    /* 其他字符都是非法的 */</span><br><span class="line">.    yyerror(&quot;无效的输入字符&quot;);</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">int yywrap()</span><br><span class="line">&#123;return 1;&#125;</span><br></pre></td></tr></table></figure><hr><p>a.y文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">%token   HEXADECIMAL INTEGER VARIABLE SIN COS TAN</span><br><span class="line">%left    &apos;+&apos; &apos;-&apos;</span><br><span class="line">%left    &apos;*&apos; &apos;/&apos;</span><br><span class="line">%left    &apos;&amp;&apos;</span><br><span class="line">%left    &apos;|&apos;</span><br><span class="line">%left    &apos;^&apos;</span><br><span class="line">%right   &apos;@&apos;&apos;~&apos;</span><br><span class="line">%left    &apos;!&apos;</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">/*for Visual studio */</span><br><span class="line">/*#define  __STDC__   0   */   </span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">    #include &lt;math.h&gt;</span><br><span class="line">    #define YYSTYPE double</span><br><span class="line">    #define pi 3.1415926 </span><br><span class="line">void yyerror(char*);</span><br><span class="line">    int yylex(void);</span><br><span class="line"></span><br><span class="line">    double sym[26];</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">program:</span><br><span class="line">    program statement &apos;\n&apos;</span><br><span class="line">    |</span><br><span class="line">    ;</span><br><span class="line">statement:</span><br><span class="line">     expr    &#123;printf(&quot;%lf\n&quot;, $1);&#125;</span><br><span class="line">     |VARIABLE &apos;=&apos; expr    &#123;sym[(int)$1] = $3;&#125;</span><br><span class="line">     ;</span><br><span class="line">expr:</span><br><span class="line">    INTEGER</span><br><span class="line">|HEXADECIMAL</span><br><span class="line">    |VARIABLE&#123;$$ = sym[(int)$1];&#125;</span><br><span class="line">    |expr &apos;+&apos; expr    &#123;$$ = $1 + $3;&#125;</span><br><span class="line">    |expr &apos;-&apos; expr    &#123;$$ = $1 - $3;&#125;</span><br><span class="line">    |expr &apos;*&apos; expr    &#123;$$ = $1 * $3;&#125;</span><br><span class="line">    |expr &apos;/&apos; expr    &#123;$$ = $1 / $3;&#125;</span><br><span class="line">    |expr &apos;&amp;&apos; expr    &#123;$$ = (int)$1 &amp; (int)$3;&#125;</span><br><span class="line">    |expr &apos;|&apos; expr    &#123;$$ = (int)$1 | (int)$3;&#125;</span><br><span class="line">    |&apos;~&apos; expr         &#123;$$ = ~(int)$2;&#125;</span><br><span class="line">    |&apos;@&apos; expr         &#123;$$ = sqrt($2);&#125;</span><br><span class="line">    |expr &apos;@&apos; expr    &#123;$$ = $1*sqrt($3);&#125;</span><br><span class="line">    |expr &apos;!&apos;         &#123;int i=1,s=1;for(;i&lt;=$2;i++)s*=i;$$=s;&#125;</span><br><span class="line">    |expr &apos;^&apos; expr    &#123;$$=pow($1,$3);&#125;</span><br><span class="line">    |&apos;(&apos;expr&apos;)&apos;       &#123;$$ = $2;&#125;</span><br><span class="line">    |SIN&apos;(&apos;expr&apos;)&apos;       &#123;$$ = sin($3*pi/180.0);&#125;</span><br><span class="line">    |COS&apos;(&apos;expr&apos;)&apos;       &#123;$$ = cos($3*pi/180.0);&#125;</span><br><span class="line">    |TAN&apos;(&apos;expr&apos;)&apos;       &#123;$$ = tan($3*pi/180.0);&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">void yyerror(char* s)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s\n&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;A simple calculator.\n可以用的运算符：+-*/&amp;|~!^@ \n要注意的是三角函数使用时要加括号。 例：sin(60)\n&quot;);</span><br><span class="line">    yyparse();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Makefile文件（只在linux下可用，注意文件名得是Makefile，大小写敏感）</p><ul><li>Makefile 文件最基础教程：<br><a href="https://blog.csdn.net/qq_35208390/article/details/78488099">https://blog.csdn.net/qq_35208390/article/details/78488099</a></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: prog clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">prog:1a.l 1a.y</span></span><br><span class="line">flex 1a.l</span><br><span class="line">bison -d 1a.y</span><br><span class="line">gcc -o a lex.yy.c 1a.tab.c -lm</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm lex.yy.c 1a.tab.c 1a.tab.h</span><br></pre></td></tr></table></figure><p>emmm…补充一下 =。= 用记事本写的 xxx.l 和xxx.y文件， flex.exe和bison.exe 只是在运行的时候使用.</p>]]></content>
      
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
