<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>石灰粉</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tanghao.fun/"/>
  <updated>2020-05-07T18:58:36.285Z</updated>
  <id>http://tanghao.fun/</id>
  
  <author>
    <name>97年的顽石</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://tanghao.fun/%E7%A7%91%E6%8A%80/0.html"/>
    <id>http://tanghao.fun/科技/0.html</id>
    <published>2020-05-07T18:58:36.285Z</published>
    <updated>2020-05-07T18:58:36.285Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title: Test</span><br><span class="line">name: 97年的顽石</span><br><span class="line">avatar: https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/husky.png</span><br><span class="line">home: &apos;https://tanghao.fun/&apos;</span><br><span class="line">authorDesc: 一条咸鱼罢了</span><br><span class="line">categories: 科技</span><br><span class="line">tags:</span><br><span class="line">  - typora</span><br><span class="line">description: Typora快捷键</span><br><span class="line">photos: https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/husky.png</span><br><span class="line">abbrlink: </span><br><span class="line">date: 2019-09-12 14:48:24</span><br><span class="line">toc: true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Sample</title>
    <link href="http://tanghao.fun/tech/f6a773f5.html"/>
    <id>http://tanghao.fun/tech/f6a773f5.html</id>
    <published>2020-05-07T18:58:36.285Z</published>
    <updated>2020-05-07T18:58:36.285Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keywords:       #简单总结几个标签，方便搜索引擎收录</span><br><span class="line">description:    #一句话介绍，方便搜索引擎收录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 当务之急 : 学完java核心内容(魔乐科技)、再系统学springcloud和python语法</span><br><span class="line">之前这种零碎的学，明显太浪费时间，还不怎么有效果</span><br><span class="line">1.1 线程剩下的</span><br><span class="line">1.2 红黑树原理简析</span><br><span class="line">1.3 开发支持类库</span><br><span class="line">1.4 其他 简介</span><br><span class="line">2.1 开始Springcloud学习， 既然大佬也开始学习了</span><br><span class="line"></span><br><span class="line">不必要:</span><br><span class="line">1 twitter图标什么的一下注释掉</span><br><span class="line">3 SEO</span><br><span class="line">4 闲来无事网页右侧滚动条?</span><br><span class="line">5 站内地址  https://tanghao.fun/post/abbrlink</span><br><span class="line"></span><br><span class="line">只有自己写的博客, 的图片, 才上传到github, 那么, 未来三五年都够用</span><br></pre></td></tr></table></figure><script>    if("8264"==prompt("请输入文档密码"))    {        alert("密码正确");    }    else    {        alert("密码错误返回主页");        location="/";    }</script><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">02</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">03</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">04</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">05</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">06</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">07</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">08</td><td style="text-align:center"></td><td style="text-align:center">普通</td><td style="text-align:left"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="main" scheme="http://tanghao.fun/tags/main/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="http://tanghao.fun/tech/784dd132.html"/>
    <id>http://tanghao.fun/tech/784dd132.html</id>
    <published>2019-09-12T05:20:52.000Z</published>
    <updated>2020-05-07T18:58:36.284Z</updated>
    
    <content type="html"><![CDATA[<p>1 先兔后龟</p><p>2 一般一个领域一个领域的刷比较好，先从简单、数组 开始刷。</p><p><a href="https://www.zhihu.com/question/30737325/answer/177097618">路线规划</a>（刷 leetcode 需要哪些基础？toraoh hdu）</p><p><img src="https://pic3.zhimg.com/80/v2-87ec17ec6e2270c8ab7852d6ece3cab2_hd.png" alt="img"></p><p><a href="https://www.zhihu.com/question/39594307/answer/82117096">方法论</a>（国内应届生是不是把Leetcode刷的滚瓜烂熟就能进google了？匿名用户搬运一篇陈皓 <a href="https://www.zhihu.com/people/ed1bff9f8d1dd80f45c88aa150795078">陈皓</a> 写的关于leetcode的文章，觉得写的很中肯。）</p>]]></content>
    
    <summary type="html">
    
      LeetCode-刷题路线
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="LeetCode" scheme="http://tanghao.fun/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>爬虫基础 Req+res</title>
    <link href="http://tanghao.fun/tech/ae11d132.html"/>
    <id>http://tanghao.fun/tech/ae11d132.html</id>
    <published>2019-05-23T09:58:09.000Z</published>
    <updated>2020-05-07T18:58:36.284Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-http">一. http:</h3><p>1 当用户在地址输入入了网址发送网络请求的过程是什么<br>2 http的请求方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get请求  </span><br><span class="line">优点: 比较便捷</span><br><span class="line">缺点: 不安全 → 明文</span><br><span class="line">参数的长度有限制</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">post请求</span><br><span class="line">⑴比较安全</span><br><span class="line">(2)数据整体没有限制</span><br><span class="line">⑶上传文件</span><br><span class="line">put(不完全的)</span><br><span class="line">delete(删除一些馆息)</span><br><span class="line">发送网络请求(需要带一定的数据给服务器,不带数据也可以) </span><br><span class="line">请求头里面requestheader </span><br><span class="line">返回数据:response</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">head(请求头)</span><br><span class="line">(1)Accept:文本的格式</span><br><span class="line">(2)Accept-Encoding:编码格式</span><br><span class="line">(3)Connection:长链接短链接</span><br><span class="line">(4&#125;Cookie:证明身份用的</span><br><span class="line">(5)Host:域名</span><br><span class="line">(6)Referer:标志从哪个页面跳转过来的</span><br><span class="line">⑺User-Agent:浏览器和用户的信息</span><br></pre></td></tr></table></figure><h3 id="二-爬虫入门">二. 爬虫入门:</h3><p>使用代码模拟用户批量的发送网络请求, 批量的获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 爬虫的价值;</span><br><span class="line">(1)买卖数据(萵镝的领域价格特别贵)</span><br><span class="line">(2)数据分析:出分析报告</span><br><span class="line">(3)流量</span><br><span class="line">(4)指数阿里指数.百度指数</span><br><span class="line">2 合法性:灰色产业</span><br><span class="line">政府没有法律现定爬虫是违法的,也没有法律现定爬虫是合法的 公司概念:公司让你爬数据库(窃取商业机密)贾任在公司</span><br><span class="line">3 爬虫可以爬取所有东西?(不是)爬虫只能爬取用户能访问到的数据 爱奇艺的视頻(vip/非vip)</span><br><span class="line">(1)普通用户,只能看非vip.  爬取非vip的的视频</span><br><span class="line">(2)vip爬取vip的视頻</span><br><span class="line">(3)普通用户想要爬取vip视频(黑客)</span><br></pre></td></tr></table></figure><h3 id="三-爬虫的分类">三. 爬虫的分类:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 通用爬虫</span><br><span class="line">(1) 使用捜索引擎:百度、谷歌、360、雅虎、搜狗</span><br><span class="line">优势:开放性、速度快</span><br><span class="line">劣势:目标不明确</span><br><span class="line">返回内容:基本上％90是用户不需要的</span><br><span class="line">不満楚用户的需求在娜里</span><br><span class="line">2. 聚焦爬虫(学习)</span><br><span class="line">1.目标明确</span><br><span class="line">2.对用户的需求非常准</span><br><span class="line">3.返回的内容固定</span><br><span class="line">增量式: 翻页(从第一页请求到最后一页)</span><br><span class="line">Deep深度爬虫:  静态数据:html css</span><br><span class="line">动态数据:  js代码.加密的js</span><br><span class="line">robots:是否允许其他爬虫(通用爬虫)爬取某些内容</span><br><span class="line">聚焦爬虫不遵守robots</span><br><span class="line">爬虫和反扒做斗争: 资源对等(人、技术)的情况下, 胜利的永远是爬虫</span><br></pre></td></tr></table></figure><h3 id="四-爬虫的工作原理">四. 爬虫的工作原理;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.确定你抓取的目标url是哪一个(找)</span><br><span class="line">2.使用python代码发送请求获取数据(java Go)</span><br><span class="line">3.解析获取到的数据(精确数据)</span><br><span class="line">找到新的目标(url)回到第一步(自动化(重点))</span><br><span class="line">4.数据持久化</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      全是图片
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="爬虫" scheme="http://tanghao.fun/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Cli安装</title>
    <link href="http://tanghao.fun/tech/5961223a.html"/>
    <id>http://tanghao.fun/tech/5961223a.html</id>
    <published>2019-05-14T03:32:00.000Z</published>
    <updated>2020-05-07T18:58:36.283Z</updated>
    
    <content type="html"><![CDATA[<p>1 安装nodejs(自带npm) 官网下载<br>2 npm 安装 cnpm  (打开管理员模式 的 cmd/powershell)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 或使用如下语句解决 npm 速度慢的问题</span><br><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g </span><br><span class="line"><span class="meta">#</span> 查看是否安装成功</span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>2 cnpm 安装 vue-cli</p><blockquote><p><strong>尽量不要用cnpm, 但是npm装不上就用它</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br><span class="line"><span class="meta">#</span> 查看是否安装成功</span><br><span class="line">vue -V   </span><br><span class="line">vue list</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      nodejs → npm → cnpm → vue-cli 安装
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="vue" scheme="http://tanghao.fun/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Win-Mysql 查看并修改编码</title>
    <link href="http://tanghao.fun/tech/4e5011d8.html"/>
    <id>http://tanghao.fun/tech/4e5011d8.html</id>
    <published>2019-05-12T04:47:26.000Z</published>
    <updated>2020-05-07T18:58:36.283Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>(linux + docker + mysql的话,可以无视以下)</p><p>(linux + docker + mysql的话,可以无视以下)</p><p>(linux + docker + mysql的话,可以无视以下)</p></blockquote><h3 id="一-win-mysql-查看并修改编码">一. win-mysql 查看并修改编码</h3><p><code>SHOW VARIABLES LIKE 'char%'</code>  查看编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">character_set_client      |  utf-8</span><br><span class="line">character_set_connection  |  utf-8    -&gt; mysql把我们客户端传递的数据都当成是utf8! 一是给它传递utf8, 二是如果我们传递的是gbk, 那么需要修改这个变量为gbk</span><br><span class="line">character_set_database    |  utf-8mb4 </span><br><span class="line">character_set_results     |  utf-8    -&gt; mysql发送给库换段的数据都是utf8的. 一是客户端用utf8编码, 二是如果客户端使用gbk来编码, 那么需要修改这个变量为gbk</span><br><span class="line">character_set_server      |  utf-8mb4</span><br><span class="line">character_set_system      |  utf-8</span><br></pre></td></tr></table></figure><blockquote><p>MySQL在5.5.3之后增加了这个utf8mb4的编码，<br>mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。<br>好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。<br>当然，为了节省空间，一般情况下使用utf8也就够了。</p></blockquote><h4 id="1-character-set-client-utf-8-无论客户端发送的是什么编码的数据-mysql都当成是utf8的数据">1 character_set_client=utf-8 ,无论客户端发送的是什么编码的数据, mysql都当成是utf8的数据</h4><blockquote><ul><li>若服务器发送的是GBK</li><li>服务器会当成utf8对待</li><li>总结: 必然乱码</li></ul></blockquote><p>处理问题的手段有两种:</p><blockquote><ul><li>1 让客户端发送utf8的数据(行不通)(win7改不了,win10估计也改不了)</li><li>2 把character_set_client修改为gbk  --&gt;  只在当前窗口内有效, 也就是说,关闭床口(小黑屏)后, 再打开, 又回到了utf8了.</li></ul></blockquote><h4 id="2-character-set-results-utf8-把数据用什么编码发送给客户端">2 character_set_results=utf8 , 把数据用什么编码发送给客户端!</h4><blockquote><ul><li>若服务发送给客户端的是utf8的数据</li><li>客户端会把它当成gbk, 因为我们的小黑屏, 只能显示gbk</li><li>总结: 必然乱码</li></ul></blockquote><p>处理问题的手段有两种:</p><blockquote><ul><li>让服务器发送gbk的数据: character_set_results=gbk</li><li>让小黑屏使用utf8来解读 (行不通)</li></ul></blockquote><h4 id="3-my-ini">3 my.ini</h4><p>在总配置文件中进行配置, 可以一劳永逸<br>mysql/mysql server 5.5/my.ini/</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">    port=3306</span><br><span class="line">[mysql]</span><br><span class="line">default-character_set=gbk <span class="comment">/*它可以一劳永逸! 它可以修改三个变量: client、result、connection*/</span></span><br></pre></td></tr></table></figure><p>然后cmd, 重启mysql, 让配置信息生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><h4 id="p-s-sqllog-会自动设置-utf-8-因为-sqllog-里面打出来的就是utf-8">P.S. SQLlog 会自动设置 utf-8, 因为 SQLlog 里面打出来的就是utf-8</h4><h3 id="end-来源-阿里云大学-java-黑马程序员-https-edu-aliyun-com-lesson-1707-13774">End. 来源: 阿里云大学/java/黑马程序员(<a href="https://edu.aliyun.com/lesson_1707_13774">https://edu.aliyun.com/lesson_1707_13774</a>)</h3>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="mysql" scheme="http://tanghao.fun/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型详解</title>
    <link href="http://tanghao.fun/tech/469ee31c.html"/>
    <id>http://tanghao.fun/tech/469ee31c.html</id>
    <published>2019-05-11T14:32:01.000Z</published>
    <updated>2020-05-07T18:58:36.282Z</updated>
    
    <content type="html"><![CDATA[<h1>java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</h1><p>作者：VieLei<br>来源：CSDN</p><p>2016年12月30日 11:44:29 <a href="https://me.csdn.net/s10461">VieLei</a> 阅读数：247414</p><blockquote><p>对java的泛型特性的了解仅限于表面的浅浅一层，直到在学习设计模式时发现有不了解的用法，才想起详细的记录一下。</p><p>本文参考<a href="http://www.cnblogs.com/sunwei2012/archive/2010/10/08/1845938.html">java 泛型详解</a>、<a href="http://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html">Java中的泛型方法</a>、 <a href="http://blog.csdn.net/caihuangshi/article/details/51278793">java泛型详解</a></p></blockquote><h1>1. 概述</h1><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p><p>什么是泛型？为什么要使用泛型？</p><blockquote><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p><p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><h1>2. 一个栗子</h1><p>一个被举了无数次的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String1</span><br></pre></td></tr></table></figure><p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错123</span></span><br></pre></td></tr></table></figure><h1>3. 特性</h1><p>泛型只在编译阶段有效。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>D/泛型测试: 类型相同</code>。</p><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h1>4. 泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p><h2 id="4-3-泛型类">4.3 泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个最普通的泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericString.getKey());<span class="number">12345678</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is <span class="number">123456</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is key_vlaue12</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p>看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());<span class="number">123456789</span></span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is false1234</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><ol><li>泛型的类型参数只能是类类型，不能是简单类型。</li></ol></li><li><ol><li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&gt;      &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ul></blockquote><h2 id="4-4-泛型接口">4.4 泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，未传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-泛型通配符">4.5 泛型通配符</h2><p>我们知道<code>Ingeter</code>是<code>Number</code>的一个子类，同时在特性章节中我们也验证过<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上是相同的一种基本类型。那么问题来了，在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，能否使用<code>Generic&lt;Ingeter&gt;</code>的实例传入呢？在逻辑上类似于<code>Generic&lt;Number&gt;</code>和<code>Generic&lt;Ingeter&gt;</code>是否可以看成具有父子关系的泛型类型呢？</p><p>为了弄清楚这个问题，我们使用<code>Generic&lt;T&gt;</code>这个泛型类继续看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;<span class="number">123</span></span><br><span class="line">Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> Generic&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </span></span><br><span class="line"><span class="comment">// cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br><span class="line"><span class="comment">// showKeyValue(gInteger);12345678</span></span><br></pre></td></tr></table></figure><p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为``Generic<Number>`的子类。由此可以看出:<strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong>。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理<code>Generic&lt;Integer&gt;</code>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示<strong>同时</strong>是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用？代替具体的类型实参，注意了，<strong>此处’？’是类型实参，而不是类型形参</strong> 。重要说三遍！<strong>此处’？’是类型实参，而不是类型形参</strong> ！ <strong>此处’？’是类型实参，而不是类型形参</strong> ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是 <strong>?</strong>  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><h2 id="4-6-泛型方法">4.6 泛型方法</h2><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p><blockquote><p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p></blockquote><p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></figure><h3 id="4-6-1-泛型方法的基本用法">4.6.1 泛型方法的基本用法</h3><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-2-类中的泛型方法">4.6.2 类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-3-泛型方法与可变参数">4.6.3 泛型方法与可变参数</h3><p>再看一个泛型方法和可变参数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4-6-4-静态方法与泛型">4.6.4 静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p><p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-5-泛型方法总结">4.6.5 泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p><blockquote><p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p></blockquote><h2 id="4-6-泛型上下边界">4.6 泛型上下边界</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><ul><li><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p><blockquote></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;<span class="number">123</span></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);</span><br><span class="line">Generic&lt;Integer&gt; generic2 = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">2222</span>);</span><br><span class="line">Generic&lt;Float&gt; generic3 = <span class="keyword">new</span> Generic&lt;Float&gt;(<span class="number">2.4f</span>);</span><br><span class="line">Generic&lt;Double&gt; generic4 = <span class="keyword">new</span> Generic&lt;Double&gt;(<span class="number">2.56</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span></span><br><span class="line"><span class="comment">//showKeyValue1(generic1);</span></span><br><span class="line"></span><br><span class="line">showKeyValue1(generic2);</span><br><span class="line">showKeyValue1(generic3);</span><br><span class="line">showKeyValue1(generic4);<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>如果我们把泛型类的定义也改一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这一行代码也会报错，因为String不是Number的子类</span></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);<span class="number">12</span></span><br></pre></td></tr></table></figure><p>再来一个泛型方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的两个例子可以看出：<strong>泛型的上下边界添加，必须与泛型的声明在一起</strong> 。</p><h2 id="4-7-关于泛型数组要提一下">4.7 关于泛型数组要提一下</h2><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是**”不能创建一个确切的泛型类型的数组”**的。</p><p>也就是说下面的这个例子是不可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];<span class="number">1</span></span><br></pre></td></tr></table></figure><p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">的一篇文档</a>的一个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.1234567</span></span><br></pre></td></tr></table></figure><blockquote><p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p><p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p></blockquote><p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK 1234567</span></span><br></pre></td></tr></table></figure><h1>5. 最后</h1><p>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。</p><hr><p>作者：VieLei<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/s10461/article/details/53941091">https://blog.csdn.net/s10461/article/details/53941091</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      ava 泛型详解-绝对是对泛型方法讲解最详细的，没有之一.作者：VieLei 来源：CSDN
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="java" scheme="http://tanghao.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Idea便捷注释-liveTemplate</title>
    <link href="http://tanghao.fun/tech/4948cd9f.html"/>
    <id>http://tanghao.fun/tech/4948cd9f.html</id>
    <published>2019-05-11T06:59:08.000Z</published>
    <updated>2020-05-07T18:58:36.282Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="最简化配置介绍">最简化配置介绍</h2><p>方法注释：打开file-&gt;setting-&gt;Editor-&gt;LiveTemplate  →  +号  →  Template Group  →  testTemplate  →  OK<br>→  选中testTemplate  →  +号  →  LiveTemplate  →  Abbreviation: *  ,  Desciption: add class comment  →  (如果要想要在方法内使用,必要条件: 1 Abbreviation: * 、2 Option→Expand with→Enter 、3 Template text中的【开头】【严格】按照如下格式(即以<code>*</code>第一行置顶开头) , 4 然后手打 <code>/**</code> 再按 <code>Enter</code>键)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * Description: $END$ </span><br><span class="line"> *</span><br><span class="line">$param$</span><br><span class="line">$return$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>至于为什么, 不知道, 不加live template的话, 直接输入<code>/**</code> 再回车 能且仅能获得 param<br>如有疏漏或者理解偏差, 敬请斧正</p><p>→  Edit variables   →  所有(variables)变量都要填一个表达式(Expretion) 【常用的如下】【本文最下方,有官方解释(在模板变量中使用的预定义函数)】</p><p>params参数的Expretion内容</p><blockquote><p>groovyScript(“if(”${_1}&quot;.length() == 2) {return ‘’;} else {def result=’’; def params=&quot;${_1}&quot;.replaceAll(’[\\[|\\]|\\s]’, ‘’).split(’,’).toList();for(i = 0; i &lt; params.size(); i++) {if(i&lt;(params.size()-1)){result+=’ * @param ’ + params[i] + ’ : ’ + ‘\n’}else{result+=’ * @param ’ + params[i] + ’ : '}}; return result;}&quot;, methodParameters());</p></blockquote><p>return参数的Expretion内容</p><blockquote><p>groovyScript(“def returnType = “${_1}”; def result = ’ * @return : ’ + returnType; return result;”, methodReturnType());</p></blockquote><p>Expretion:<br>user()<br>date()<br>time()<br>className()</p><blockquote><p><code>$END$</code> 表示光标最后的停留位置</p></blockquote><h2 id="关于intellij-idea中的live-templates实践">关于Intellij IDEA中的Live Templates实践</h2><h3 id="一-四-转自-https-my-oschina-net-angerbaby-blog-867090">一~四 转自:<a href="https://my.oschina.net/angerbaby/blog/867090">https://my.oschina.net/angerbaby/blog/867090</a></h3><p>[IntelliJ IDEA]</p><p>[面试：你懂什么是分布式系统吗？Redis分布式锁都不会 ]</p><h3 id="一-前言">一. 前言</h3><p>关于idea，相信已经是炙手可热的一款IDE了。越来越多的Java开发人员更倾向于选择idea。今天笔者聊一下关于idea中的Live Templates功能，Live Templates允许用户自定义功能丰富的代码模板，通过快捷键的方式可以迅速生成一段代码模板，然后只需要微调一下即可。比如我们常用的foreach代码块、if代码块等等，当然Live Templates的强大远不止于此，其内置的功能函数以及支持Groovy脚本语言的特性，允许你做一些“更疯狂”的事情，只要你想去做。</p><p>在本文中，笔者结合自己的实践经历，简单介绍一些关于Live Templates的应用场景，希望起到一种入门引导的作用。</p><h3 id="二-live-templates实现方法注释">二. Live Templates实现方法注释</h3><p>习惯使用Eclipse的用户，相信会依赖其自动生成类和方法注释的功能，其中包含了必要的javadoc注解，比如@param、@return、@author等。在Eclipse中用户还可以定制自动生成注释的行为。</p><p>那么如何在idea中自动生成类和方法注释（注释中需要对应的javadoc注解）呢？</p><h4 id="idea中的方法注释">idea中的方法注释</h4><p>idea中并不是不支持生成方法注释，在方法定义上面输入&quot;/**&quot;+回车，idea会根据当前方法中的参数和返回值，生成方法注释，其中会有@param和@return。</p><p>但是如果想修改一下自动生成方法注释中的内容，目前笔者没有找到任何办法。比如想在自动生成的方法注释中添加@author内容、添加日期信息，&quot;/**&quot;+回车的方式是不可行的。</p><p>按照自定义idea中方法注释的思路去网上搜索，会发现更多的建议是应用Live Templates来自定义满足自身需要的方法注释。</p><h4 id="idea中的类注释">idea中的类注释</h4><p>这里穿插一段关于idea类注释的说明。其实在idea中每新建一个java类，类文件头部会自动生成一段类注释。</p><p>idea允许用户自定义类注释的内容，但是相信很多人受自定义方法注释的影响，第一反应就是去Live Templates中查找idea使用的默认类注释模板。</p><p>其实笔者想在这里强调的是，自定义idea中的类注释模板，不在Live Templates中，不要冤枉它。正确的位置在下图所示的地方。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-1.png" alt="1"></p><h4 id="自定义方法注释">自定义方法注释</h4><p>上面提到了如果想自定义idea中的方法注释，需要用到Live Templates。先贴出一张截图，里面包含了笔者已经创建好的模板，用于生成笔者需要的方法注释。<br><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-2.png" alt="2"></p><ul><li>新建一个group，命名为“self”，表明这个组里面的模板是自定义的，可能仅适用于自己的工作场景。</li><li>在组里新建一个模板，快捷键定义为“mc”，确认方式选择“Enter”，即在应用模板的地方，输出“mc”+回车，即可生成模板内容。</li><li>观察图中的模板内容，$param$表示一个自定义的变量，用于枚举方法中的参数，即@param的内容。但是这里有个问题，就是如何循环生成方法的多个参数并且换行显示呢？虽然Live Templates中提供了一个功能函数-methodParameters()，但这个函数可以理解为只是“一串”参数，怎么拆分显示呢？这里用到了Groovy脚本语言，将$param$这个变量对应的表达式写为执行Groovy脚本，即拆分methodParameters()返回的“一串”参数，并在每个参数前面添加@param并换行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\n\\b&apos; : &apos;&apos;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-3.png" alt="3"></p><ul><li>$date$也是一个自定义变量，对应的表达式使用内置的date()函数，表示输出当前的日期。</li><li>$END$是内置的一个变量，表示模板内容生成后，光标停留的位置。生成方法注释后，可能需要填写方法的描述内容，自定义光标停留的位置可以方便后续操作。</li><li>生成的自定义模板内容后，光标默认会依次停留在自定义变量的位置，需要用户手动回车确定，直至无自定义变量为止。这个默认行为有时可能是不需要的，所以编辑自定义变量时，选中“skip if defined”即可。</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-4.png" alt="4"></p><p>OK，模板定义完了，来试一下效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int add(int p1, int p2) &#123;</span><br><span class="line">  // mc + 回车 生成方法注释</span><br><span class="line">  /**</span><br><span class="line">   *</span><br><span class="line">   * @param p1</span><br><span class="line">   * @param p2</span><br><span class="line">   * @return</span><br><span class="line">   *</span><br><span class="line">   * @author chenx</span><br><span class="line">   * @date 2017/03/25</span><br><span class="line">   */  </span><br><span class="line">  return p1 + p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没有看错！这种自定义的方法注释，需要在方法内使用快捷键才能枚举出方法参数！因为内置的methodParameters()只有在方法内的作用域才起作用！好吧，笔者也觉着这点十分不爽，还是没能达到理想的效果。不过这也算是笔者目前发现的最省事的方法注释生成方式了。</p><p>其实可以发现使用Live Templates实现方法注释生成，最大阻碍是循环枚举方法参数。如果你的注释习惯允许你可以不枚举方法参数，那么恭喜你，你可以在方法外部直接使用“mc” + 回车即可。</p><p>笔者期望idea可以提供修改&quot;/**&quot;+回车自动生成方法注释的办法。或者有知道的朋友，请不吝赐教。</p><h3 id="三-自定义常用的live-templates">三. 自定义常用的Live Templates</h3><p>上面描述了如何使用Live Templates实现生成方法注释，但最终效果笔者自认为有些牵强，不算完美。 接下来展示一些常用的代码模板定义。</p><h4 id="依赖注入私有属性">依赖注入私有属性</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-5.png" alt="5"></p><h4 id="logger实例">Logger实例</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-6.png" alt="6"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-7.png" alt="7"></p><h4 id="依赖注入属性资源">依赖注入属性资源</h4><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-8.png" alt="8"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-05-11-liveTemplate-9.png" alt="9"></p><p>这里可以发现，内容中定义的两个变量，没有指定表达式，表示需要用户手动输入对应的内容。模板内容生成后，光标会依次停留在变量的位置等待用户输入内容。</p><h3 id="四-总结">四. 总结</h3><p>本文介绍了Live Templates功能的简单应用，关于更复杂，更强悍的功能实现，需要不断地学习了解Live Templates的特性。养成良好的工作习惯，将自己熟悉常用的代码片段进行提炼，生成模板，相信对你的工作一定会起到事半功倍的效果。</p><p>关于idea中如何自定义生成方法注释，如果有更好的实现或建议，请多多指教~</p><h3 id="五-在模板变量中使用的预定义函数-注释-表达式-expression">五. 在模板变量中使用的预定义函数(注释 表达式 Expression)</h3><h4 id="文件模板变量">文件模板变量<a href="https://www.jetbrains.com/help/idea/file-template-variables.html#file_template_variables.xml">＃</a></h4><p>一个 <a href="https://www.jetbrains.com/help/idea/using-file-and-code-templates.html">文件模板</a>可以包含变量，这是他们的值替代应用模板时。变量是一个以美元符号（<code>$</code>）后跟变量名称开头的字符串。变量名称可以选择用大括号括起来。例如：<code>$MyVariable</code>并且 <code>${MyVariable}</code>是同一变量的不同符号。</p><h4 id="预定义的模板变量">预定义的模板变量<a href="https://www.jetbrains.com/help/idea/file-template-variables.html#predefined_template_variables">＃</a></h4><p>可以在<em>文件模板中</em>使用以下预定义变量：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>${DATE}</code></td><td style="text-align:left">当前系统日期</td></tr><tr><td style="text-align:left"><code>${DAY}</code></td><td style="text-align:left">当月的当天</td></tr><tr><td style="text-align:left"><code>${DS}</code></td><td style="text-align:left">美元符号（<code>$</code>）。此变量用于转义美元字符，因此不会将其视为模板变量的前缀。</td></tr><tr><td style="text-align:left"><code>${END}</code></td><td style="text-align:left">完成编辑变量后的插入位置</td></tr><tr><td style="text-align:left"><code>${FILE_NAME}</code></td><td style="text-align:left">新PHP文件的名称（如果启用了<a href="https://plugins.jetbrains.com/plugin/6610-php">PHP插件</a>）</td></tr><tr><td style="text-align:left"><code>${HOUR}</code></td><td style="text-align:left">当前时间</td></tr><tr><td style="text-align:left"><code>${MINUTE}</code></td><td style="text-align:left">当前分钟</td></tr><tr><td style="text-align:left"><code>${MONTH}</code></td><td style="text-align:left">这个月</td></tr><tr><td style="text-align:left"><code>${MONTH_NAME_FULL}</code></td><td style="text-align:left">当月的全名（1月，2月等）</td></tr><tr><td style="text-align:left"><code>${MONTH_NAME_SHORT}</code></td><td style="text-align:left">当前月份名称的前三个字母（Jan，Feb等）</td></tr><tr><td style="text-align:left"><code>${NAME}</code></td><td style="text-align:left">新实体的名称（文件，类，接口等）</td></tr><tr><td style="text-align:left"><code>${PACKAGE_NAME}</code></td><td style="text-align:left">创建新类或接口文件的目标包的名称</td></tr><tr><td style="text-align:left"><code>${PRODUCT_NAME}</code></td><td style="text-align:left">IDE的名称（例如，IntelliJ IDEA）</td></tr><tr><td style="text-align:left"><code>${PROJECT_NAME}</code></td><td style="text-align:left">当前项目的名称</td></tr><tr><td style="text-align:left"><code>${TIME}</code></td><td style="text-align:left">当前系统时间</td></tr><tr><td style="text-align:left"><code>${USER}</code></td><td style="text-align:left">当前用户的登录名</td></tr><tr><td style="text-align:left"><code>${YEAR}</code></td><td style="text-align:left">今年</td></tr></tbody></table><p>IntelliJ IDEA为<a href="https://www.jetbrains.com/help/idea/settings-file-and-code-templates.html#tabsIncludes">PHP包含模板</a>提供了一组附加变量，用于定义<a href="https://www.jetbrains.com/help/idea/parse-directive.html">可重用的代码片段</a>，例如文件头和<a href="https://www.jetbrains.com/help/idea/phpdoc-comments.html">PHPDoc注释</a>。</p><p><em>PHP包含模板中</em>可以使用以下附加预定义变量：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>${CARET}</code></td><td style="text-align:left">完成编辑变量后的插入位置。仅在文件创建期间生成并插入PHPDoc注释时应用。当通过Code |创建PHPDoc注释时 生成| PHPDoc块，可以选择多种功能或方法。可以为多个类，函数，方法或字段创建此案例中的文档注释，因此将<code>${CARET}</code>忽略该变量。</td></tr><tr><td style="text-align:left"><code>${CLASS_NAME}</code></td><td style="text-align:left">定义了生成PHPDoc注释的字段或方法的类的名称</td></tr><tr><td style="text-align:left"><code>${NAME}</code></td><td style="text-align:left">将为其生成PHPDoc注释的类，字段或函数（方法）的名称</td></tr><tr><td style="text-align:left"><code>${NAMESPACE}</code></td><td style="text-align:left">类或字段命名空间的完全限定名称（不带前导斜杠）</td></tr><tr><td style="text-align:left"><code>${PARAM_DOC}</code></td><td style="text-align:left">参数的文档注释。评估一组<code>@param type name</code>行。如果生成注释的函数不包含任何参数，则求值为空字符串。</td></tr><tr><td style="text-align:left"><code>${STATIC}</code></td><td style="text-align:left"><code>static</code>如果生成PHPDoc注释的函数（方法）或字段是静态的，则 替换为关键字。否则计算为空字符串。</td></tr><tr><td style="text-align:left"><code>${THROWS_DOC}</code></td><td style="text-align:left">文档注释异常。评估一组<code>@throws type</code>行。如果生成注释的函数不抛出任何异常，则求值为空字符串。</td></tr><tr><td style="text-align:left"><code>${TYPE_HINT}</code></td><td style="text-align:left">返回函数（方法）的值以生成PHPDoc注释。如果通过函数（方法）的静态分析无法检测返回类型，则求值为<code>void</code>。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      idea-可以在方法外使用的便捷注释-liveTemplate
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="idea" scheme="http://tanghao.fun/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Idea+maven私服-配置Nexus</title>
    <link href="http://tanghao.fun/tech/4a61bfde.html"/>
    <id>http://tanghao.fun/tech/4a61bfde.html</id>
    <published>2019-05-08T04:50:34.000Z</published>
    <updated>2020-05-07T18:58:36.281Z</updated>
    
    <content type="html"><![CDATA[<p>mirror和repository的区别 概念在文章 → Maven：mirror和repository 区别 - bcombetter - 博客园(已剪藏)</p><hr><p>[TOC]</p><h1><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-maven-%E7%A7%81%E6%9C%8D">#</a> 在项目中使用 Maven 私服**(Nexus)**</h1><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><h2 id="配置认证信息-镜像-maven-conf-setting-xml"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF">#</a> 配置认证信息+镜像(Maven/conf/setting.xml)</h2><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><p>效果就是Maven的所有请求必须经过镜像站点(Nexus);当Nexus出现问题后，那么Maven将强制不可用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>mirror-redirect2nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 此处配置所有的构建均从私有仓库中下载，*代表所有，也可以写成central --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mirrorOf&gt;nexus&lt;/mirrorOf&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus osc<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="snapshots-与-releases-的区别"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#snapshots-%E4%B8%8E-releases-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a> Snapshots 与 Releases 的区别</h3><ul><li>nexus-releases: 用于发布 Release 版本</li><li>nexus-snapshots: 用于发布 Snapshot 版本（快照版）</li></ul><p>Release 版本与 Snapshot 定义如下：</p><p>Release: 1.0.0/1.0.0-RELEASE</p><p>Snapshot: 1.0.0-SNAPSHOT</p><ul><li>在项目 pom.xml 中设置的版本号添加 SNAPSHOT 标识的都会发布为 SNAPSHOT 版本，没有 SNAPSHOT 标识的都会发布为 RELEASE 版本。</li><li>SNAPSHOT 版本会自动加一个时间作为标识，如：1.0.0-SNAPSHOT 发布后为变成 1.0.0-SNAPSHOT-20180522.123456-1.jar</li></ul><h2 id="配置自动化部署-idea-pom-xml部分"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2">#</a> 配置自动化部署(<strong>IDEA pom.xml部分</strong>)</h2><p>在(IDEA)pom.xml 中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>ID 名称必须要与 settings.xml 中 Servers 配置的 ID 名称保持一致。</li><li>项目版本号中有 SNAPSHOT 标识的，会发布到 Nexus Snapshots Repository, 否则发布到 Nexus Release Repository，并根据 ID 去匹配授权账号。</li></ul><h2 id="部署到仓库"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BB%93%E5%BA%93">#</a> 部署到仓库</h2><p>mvn deploy</p><h2 id="上传第三方-jar-包"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E4%B8%8A%E4%BC%A0%E7%AC%AC%E4%B8%89%E6%96%B9-jar-%E5%8C%85">#</a> 上传第三方 JAR 包</h2><p>Nexus 3.0 不支持页面上传，可使用 maven 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 如第三方JAR包：aliyun-sdk-oss-2.2.3.jar</span><br><span class="line"></span><br><span class="line">mvn deploy:deploy-file</span><br><span class="line"></span><br><span class="line">  -DgroupId=com.aliyun.oss</span><br><span class="line"></span><br><span class="line">  -DartifactId=aliyun-sdk-oss</span><br><span class="line"></span><br><span class="line">  -Dversion=2.2.3</span><br><span class="line"></span><br><span class="line">  -Dpackaging=jar</span><br><span class="line"></span><br><span class="line">  -Dfile=D:\aliyun-sdk-oss-2.2.3.jar</span><br><span class="line"></span><br><span class="line">  -Durl=http://127.0.0.1:8081/repository/maven-3rd/</span><br><span class="line"></span><br><span class="line">  -DrepositoryId=nexus-releases</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>建议在上传第三方 JAR 包时，创建单独的第三方 JAR 包管理仓库，便于管理有维护。（maven-3rd）</li><li>-DrepositoryId=nexus-releases 对应的是 settings.xml 中 Servers 配置的 ID 名称。（授权）</li></ul><h2 id="配置代理仓库-idea-pom-xml部分"><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%BB%93%E5%BA%93">#</a> 配置代理仓库**(<strong><strong>IDEA pom.xml部分</strong></strong>)**</h2><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Plugin Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.213.135:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.funtl.com/zh/nexus/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Maven-%E7%A7%81%E6%9C%8D.html#%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E4%BB%93%E5%BA%93">#</a> <strong>Nexus添加阿里云仓库(</strong><a href="http://192.168.213.135:8081/">http://192.168.213.135:8081</a>  <strong>登陆并设置</strong>**)：**</p><p><strong>(使用时把aliyun配置在nexus里,pom.xml和setting.xml只留私服)</strong></p><pre><code>    把一下都配上,并设置maven-public 调整到 maven-release/public/centrol 之前.(范例在代码最下方)</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">setting.xml</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>ibiblio<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mirrors.ibiblio.org/pub/mirrors/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss-public-repository-group<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Public Repository Group<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.org/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 中央仓库在中国的镜像 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven.net.cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>oneof the central mirrors in china<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pom.xml</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>范例:  如下图，点击  Repositories → Create repository → maven2 proxy</p><p>取名: aliyun-repository</p><p>URL：<code>http://maven.aliyun.com/nexus/content/groups/public/</code>，其他默认值即可。</p><p>2 配置public-repository：</p><p>将aliyun的repository排到最上面</p>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="nexus" scheme="http://tanghao.fun/tags/nexus/"/>
    
  </entry>
  
  <entry>
    <title>Idea-技巧</title>
    <link href="http://tanghao.fun/tech/205cf4f6.html"/>
    <id>http://tanghao.fun/tech/205cf4f6.html</id>
    <published>2019-04-28T12:39:05.000Z</published>
    <updated>2020-05-07T18:58:36.280Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-idea常用快捷键">1. IDEA常用快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F在当前文件进行文本查找 （必备）</span><br><span class="line">Ctrl + R在当前文件进行文本替换 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Y删除光标所在行 或 删除选中的行 （必备）</span><br><span class="line">Ctrl + D复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + P    方法参数提示显示 （必备）</span><br><span class="line">Ctrl + Space基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl + E  显示最近打开的文件记录列表 （必备）</span><br><span class="line">Ctrl + N  根据输入的 类名 查找类文件 （必备）</span><br><span class="line">Alt  + Enter  自动导入没导入的包</span><br></pre></td></tr></table></figure><h4 id="2-修改默认新项目maven配置">2. 修改默认新项目Maven配置</h4><p>file → Other Setting → Setting for New Projects… → Build… → Maven</p><h4 id="n-小技巧-杂乱">n. 小技巧-杂乱</h4><p>1 改文件名</p><p>右键 → refacter</p><p>2 修改(基础代码补全)快捷键</p><p>file → setting → keyboard → Main menu → Code → Completion → basic 修改为Ctrl,(逗号)</p><p>还需, 搜狗输入法 → 右键 → 输入法管理 → 去掉勾选√设置搜狗输入法为默认中文输入法【为了保险: 修改搜狗输入法快捷键为Ctrl+F12】</p><p>3 注意.yml文件只可以照着修改不可把备份的yml直接黏贴过去</p>]]></content>
    
    <summary type="html">
    
      技巧,常用快捷键
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="idea" scheme="http://tanghao.fun/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Idea-技巧+常用快捷键</title>
    <link href="http://tanghao.fun/tech/205cf4f6.html"/>
    <id>http://tanghao.fun/tech/205cf4f6.html</id>
    <published>2019-04-28T12:39:05.000Z</published>
    <updated>2020-05-07T18:58:36.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-idea常用快捷键">1. IDEA常用快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">注释：</span><br><span class="line">Ctrl + /   使用及取消 单行注释</span><br><span class="line">Ctrl + Shift + /  使用及取消 多行注释</span><br><span class="line"></span><br><span class="line">编程快捷键：</span><br><span class="line">Ctrl + Shift + Enter 跳出括号并且补全分号</span><br><span class="line"></span><br><span class="line">Ctrl + Enter 跳到新的一行</span><br><span class="line"></span><br><span class="line">导包：</span><br><span class="line">Alt  + Enter      自动导包(鼠标停在其中一个的句尾，再0.5s按一次)</span><br><span class="line">Ctrl + ，(逗号)    手动导包</span><br><span class="line"></span><br><span class="line">杂项：</span><br><span class="line">Alt  + Enter     万能快捷键： 自动导包、equals的翻转、异常捕获、、、</span><br><span class="line"></span><br><span class="line">Ctrl + F在当前文件进行文本查找 （必备）</span><br><span class="line">Ctrl + R在当前文件进行文本替换 （必备）</span><br><span class="line">Ctrl + Shift + F全局进行文本查找 （必备）</span><br><span class="line">Ctrl + Shift + R全局进行文本查找 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + Y删除光标所在行 或 删除选中的行 （必备）</span><br><span class="line">Ctrl + D复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</span><br><span class="line"></span><br><span class="line">Ctrl + E  显示最近打开的文件记录列表 （必备）</span><br><span class="line">Ctrl + N  根据输入的 类名 查找类文件 （必备）</span><br><span class="line">Ctrl + Space基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</span><br><span class="line">Ctrl + P    方法参数提示显示 （必备）</span><br></pre></td></tr></table></figure><h4 id="2-修改默认新项目maven配置">2. 修改默认新项目Maven配置</h4><p>file → Other Setting → Setting for New Projects… → Build… → Maven</p><h4 id="n-小技巧-杂乱">n. 小技巧-杂乱</h4><p>1 改文件名</p><p>右键 → refacter</p><p>2 修改(基础代码补全)快捷键</p><p>file → setting → keyboard → Main menu → Code → Completion → basic 修改为Ctrl,(逗号)</p><p>还需, 搜狗输入法 → 右键 → 输入法管理 → 去掉勾选√设置搜狗输入法为默认中文输入法【为了保险: 修改搜狗输入法快捷键为Ctrl+F12】</p><p>3 注意.yml文件只可以照着修改不可把备份的yml直接黏贴过去</p><p>4 复制错误提示</p><p>鼠标悬停在错误代码上，待出现错误提示后，按住Alt键，鼠标左键3连击选中/鼠标框选，Ctrl+C复制，然后baidu/Google</p>]]></content>
    
    <summary type="html">
    
      技巧,常用快捷键
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="idea" scheme="http://tanghao.fun/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>(Java高级编程)类集-Java10</title>
    <link href="http://tanghao.fun/tech/b9eded0.html"/>
    <id>http://tanghao.fun/tech/b9eded0.html</id>
    <published>2019-04-24T03:52:44.000Z</published>
    <updated>2020-05-07T18:58:36.279Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一-类集框架简介">一、类集框架简介</h3><h4 id="1-类集框架简介">1. 类集框架简介</h4><p>​从JDK1.2开始，Java引入了类集开发框架，所谓的类集指的就是一套动态对象数组的实现方案，在实际的开发之中，没有任何一项的开发可以离开十足，但是传统的数组实现起来非常的繁琐。而且长度是其致命伤。正是因为长度的问题，所以传统的数组是不可能大范围使用的，但是我们的开发又不可能离开数组，所以最初就只能依靠一些数据结构来实现动态的数组处理，而其中最为重要的两个结构: 链表、树，但是面对这些数据结构的实现又不得不面对如下的一些困哪:</p><ul><li>数据结构的代码实现困难，对于一般的开发者是无法进行使用的;</li><li>对于链表或二叉树当进行更新处理的时候的维护是非常麻烦的;</li><li>对于链表或二叉树还需要尽可能保证其操作的性能。</li></ul><p>正是因为这样的原因，所以从JDK1.2开始Java引入了类集，主要就是对常见的数据结构进行完整的实现包装，并且提供有一系列的接口与实现子类来帮助用户减少数据结构所带来的的开发困难，</p><blockquote><p>这个就是类集的产生意义所在。以后数据结构不要自己来写了，但是你千万要记住一个过程: 对于现阶段开发里面，类集有它一些固定的使用方法，但是我们在进行子类选择的时候，我们一定要知道它的各个子类的实现算法是怎么回事，这样才能确保我们的程序高效。</p><blockquote><p>举个例子来讲，如果在正常的设计选择过程当中，我发现我存的数据是固定长度或者说绝对不会超过某些长度，应该是用数据来操作是最简单的吧，因为什么? 因为数组是一个线性结构，时间复杂度为1。</p><p>也就是说，正常情况来讲，类集里面它也要区分子类的不同而有所不同。</p></blockquote></blockquote><p>​但是最初的类集实现由于Java本身的技术所限，所以对于数据的控制并不严格，全部采用了Object类型进行数据接收，而在JDK1.5之后由于泛型技术的推广，所以类集本身也得到了良好的改进，可以直接利用泛型来保存相同类型的数据，并且随着数据量的不断增加，从JDK1.8开始类集中的实现算法也得到了良好的性能提升。</p><blockquote><p>但是你们在学习之中应该清楚的知道类集之中所采用的性能提高的方式是什么，这个必须自己能够说出来</p></blockquote><p>在整个类集框架里面提供有如下的几个核心接口: Collection、List、Set、Map、Iterator、Enumeration、Queue、ListIterator。</p><h4 id="2-collection接口简介">2. Collection接口简介</h4><p>java.util.Collection是单值集合操作的最大的父接口，在该接口之中定义有所有的单值数据的处理操作。这个接口之中定义有如下的核心操作方法:</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center"><font color=red> 01</font></td><td style="text-align:center"><font color=red>public boolean add(E e)</font></td><td style="text-align:center"><font color=red> 普通</font></td><td style="text-align:left"><font color=red>向集合保存数据</font></td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public boolean addAll(Collection&lt;? extends E&gt; e)</td><td style="text-align:center">普通</td><td style="text-align:left">追加一组数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public void clear()</td><td style="text-align:center">普通</td><td style="text-align:left">清空集合，让根节点为空，同时执行GC处理</td></tr><tr><td style="text-align:center">04</td><td style="text-align:center">public boolean contains(Object o)</td><td style="text-align:center">普通</td><td style="text-align:left">查询数据是否存在，需要equals()方法支持</td></tr><tr><td style="text-align:center">05</td><td style="text-align:center">public boolean remove(Object o)</td><td style="text-align:center">普通</td><td style="text-align:left">数据删除，需要equals()方法支持</td></tr><tr><td style="text-align:center">06</td><td style="text-align:center">public int size()</td><td style="text-align:center">普通</td><td style="text-align:left">获取数据长度</td></tr><tr><td style="text-align:center">07</td><td style="text-align:center">public Object[] toArray()</td><td style="text-align:center">普通</td><td style="text-align:left">将集合变为对象数组返回</td></tr><tr><td style="text-align:center"><font color=red>08</font></td><td style="text-align:center"><font color=red>public Iterator&lt;E&gt; iterator()</font></td><td style="text-align:center"><font color=red>普通</font></td><td style="text-align:left"><font color=red>将集合变为Iterator接口</font></td></tr></tbody></table><p>​在进行集合操作的时候有两个方法最为常用:【增加】add()、【输出】iterator()，在JDK1.5版本以前，Collection只是一个独立的接口，但是从JDK1.5之后提供有了Iterable父接口，并且在JDK1.8的之后针对于Iterable接口也得到了一些扩充。</p><p>​另外在JDK1.2~JDK1.4的时代如果要进行集合的使用往往会直接操作Collection的接口，但是从JDK1.5时代开始更多的情况下选择的都是Collection的两个子接口: 允许重复的List子接口、不允许重复的Set子接口;</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-1-8220.png" alt="1"></p><blockquote><p>现阶段的开发不要再去用Collection了，这个主要是 微软的Sun的 战争引起的。</p></blockquote><h3 id="二-list集合">二、List集合</h3><h4 id="1-list接口简介">1. List接口简介</h4><p>List是Collection的子接口，其最大的特点是允许保存有重复元素数据，该接口的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是需要清楚的是List子接口对于Collection接口进行了方法扩充。</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center"><font color=red>01</font></td><td style="text-align:center"><font color=red>public E get(int index)</font></td><td style="text-align:center"><font color=red>普通</font></td><td style="text-align:left"><font color=red>获取指定索引上的数据</font></td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public E set(int index,E element)</td><td style="text-align:center">普通</td><td style="text-align:left">修改指定索引数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public ListIterator<E> listIterator()</td><td style="text-align:center">普通</td><td style="text-align:left">返回ListIterator接口对象</td></tr></tbody></table><p>​但是List本身依然属于一个接口，那么对于接口要想使用则一定要使用子类来完成定义，在List子接口中有三个常用子类: ArrayList、LinkedList、Vector。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-2-8220.png" alt="2"></p><p>​从JDK1.9开始，List子接口里面追加有一些static方法，以方便用户的处理。</p><p><strong>范例:</strong> 观察List中的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = List.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"你好"</span>,<span class="string">"NGP"</span>,<span class="string">"饿了么?"</span>);</span><br><span class="line">Object result [] = all.toArray();</span><br><span class="line"><span class="keyword">for</span>(Object temp : result) &#123;</span><br><span class="line">System.out.print(temp + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这些操作方法并不是List传统用法，是在新版本之后添加的新功能。</p><blockquote><p>在开发当中，因为JDK9或JDK10没有广泛开来，所以大家最好用原始的方式开发</p></blockquote><h4 id="2-arraylist子类">2. ArrayList子类</h4><p>​ArrayList是 List子接口使用最多的一个子类，但是这个子类在使用的时候也是有前提要求的，所以本次来对这个类的相关定义以及源代码组成进行分析，在 Java 里面ArrayList类的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​ArrayList子类的继承结构</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-3-8220.png" alt="3"></p><p><strong>范例:</strong> 使用ArrayList实例化List父接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过本程序可以发现List存储的特征:</p><ul><li>保存的顺序就是其存储顺序;</li><li>List集合里面允许存在有重复数据。</li></ul><p>在以上的程序里面虽然实现了集合的输出，但是这种输出的操作是直接利用了每一个类提供的toString()方法实现的，为了方便的进行处理，在JDK1.8之后Iterable父接口之中定义有一个forEach()方法，方法定义如下:</p><ul><li>输出支持: default void forEach(Consumer&lt;? super T&gt; action)</li></ul><p><strong>范例:</strong> 利用forEach()方法输出(不是标准输出)</p><blockquote><p>只是在使用java的时候方便一些，正常开发是不可能用它来完成的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.forEach((str)-&gt;&#123;</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​需要注意的是，此种输出并不是在正常开发情况下要考虑的操作形式。</p><p><strong>范例:</strong> 观察List集合的其他操作方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">System.out.println(<span class="string">"集合是否为空?"</span> + all.isEmpty() + <span class="string">"、集合元素个数: "</span> + all.size());</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>);  <span class="comment">//重复数据</span></span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.remove(<span class="string">"Hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"集合是否为空?"</span> + all.isEmpty() + <span class="string">"、集合元素个数: "</span> + all.size());</span><br><span class="line">all.forEach((str)-&gt;&#123;</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果以方法的功能为例，那么ArrayList里面操作支持与之前编写的链表形式是非常相似的，但是它并不是使用链表来实现的，通过类名称实际上就已经可以清楚的发现了，ArrayList应该封装的是一个数组。</p><table><thead><tr><th>ArrayList构造:<br/>public ArrayList()</th><th>public ArrayList() {<br/>  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br/>}<br/>--------------------------------<br/>public</th></tr></thead><tbody><tr><td></td><td>private static final Object[] EMPTY_ELEMENTDATA = {};</td></tr><tr><td>ArrayList构造:<br/>public ArrayList(int initialCapacity)</td><td>public ArrayList(int initialCapacity) {<br/>  if (initialCapacity &gt; 0) {<br/>    this.elementData = new Object[initialCapacity];<br/>  } else if (initialCapacity == 0) {<br/>    this.elementData = EMPTY_ELEMENTDATA;<br/>  } else {<br/>    throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);<br/>  }<br/>}</td></tr><tr><td></td><td>transient Object[] elementData;// non-private to simplify nested class access</td></tr></tbody></table><p>​通过有参构造方法可以发现，在ArrayList里面所包含的数据实际上就是一个对象数组。如果现在在进行数据追加的时候发现ArrayList集合里面保存的对象数组的长度不够的时候，会进行新的数组开辟，同时将原始的旧数组内容拷贝到新数组之中，而后数组的开辟操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>) ? newCapacity: hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果在实例化ArrayList类对象的时候并没有传递初始化的长度，则默认情况下会使用一个空数组，但是如果在进行数据增加的时候发现数组容量不够了。则会判断当前的增长的容量与默认的容量的大小，使用较大的一个数据进行新的数组开辟，所以可以得出一个结论:</p><table><thead><tr><th>JDK1.9之后:</th><th>ArrayList默认的构造只会使用默认的空数组，使用的时候才会开辟数组，默认的开辟长度为10;</th></tr></thead><tbody><tr><td>JDK1.9之前</td><td>ArrayList默认的构造实际上就会默认开辟大小为10的数组。</td></tr></tbody></table><p>​当ArrayList之中保存的容量不足的时候会采用成倍的方式进行增长，原始长度为10，那么下次的增长就是20，依此类推。</p><p>​在使用ArrayList子类的时候一定要估算出你的数据量会有多少，如果超过了10个，那么使用有参构造方法进行创建，以避免垃圾数组的空间产生。</p><h4 id="3-arraylist保存自定义类对象">3. ArrayList保存自定义类对象</h4><p>通过之前的分析已经清楚了ArrayList子类的实现原理以及List核心操作，但是在测试的时候使用的是系统提供的String类，这是一个设计非常完善的类，而对于类集而言也可以实现自定义类对象的保存。</p><p><strong>范例:</strong> 实现自定义类对象的保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == obj) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person per = (Person) obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.equals(per.name) &amp;&amp; <span class="keyword">this</span>.age == per.age;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//setter、getter、构造略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;Person&gt; all = <span class="keyword">new</span> ArrayList&lt;Person&gt; ();</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">30</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">16</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>));</span><br><span class="line">System.out.println(all.contains(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>)));</span><br><span class="line">all.remove(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>));</span><br><span class="line">all.forEach(System.out::println); <span class="comment">//方法引用代替了消费型的接口，不是标准做法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在使用List保存自定义类对象的时候如果需要使用到contains()、remove()方法进行查询与删除处理的时候，一定要保证类之中已经成功覆写了equals()方法。</p><h4 id="4-linkedlist子类">4. LinkedList子类</h4><p>​在List接口里面还有另外一个比较常用的子类: LinkedList,这个类通过名称就已经可以发现其特点了: 基于链表的实现，那么我们首先来观察一下LinkedList子类的定义:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-4-8220.png" alt="4"></p><p>范例: 使用LinkedList实现集合操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> LinkedList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>); <span class="comment">//重复数据</span></span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果说现在只是观察程序的功能你会发现和ArrayList使用是完全一样的，但是其内部的实现机制是完全不同的，首先观察LinkedList构造方法里面并没有提供有像ArrayList那样的初始化大小的方法，而只是提供有无参构造处理:  “public LinkedList()” 随后观察add()方法的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在之前编写自定义链表的时候，是判断了传入数据是否为null，如果为null则不进行保存，但是在LinkedList里面并没有做这样的处理，而是所有的数据都可以保存，而后此方法调用了linkLast()方法 (在最后一个节点进行追加)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在LinedList类里面保存的数据都是利用Node节点进行的封装处理，同时为了提高程序执行性能，每一次都会保存上一个追加的节点(最后一个节点)，这样就可以在增加数据的时候避免递归处理，在增加数据的时候要进行数据保存个数的追加。</p></blockquote><p>​通过一系列的分析之后可以发现，LinkedList封装的就是一个链表实现。</p><p><strong>面试题:</strong> 请问ArrayList与LinkedList有何区别?</p><ul><li>ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作。</li><li>在使用List集合中的get()方法根据索引取数据时，ArrayList的时间复杂度为&quot;O(1)&quot;，而LinkedList时间复杂度为&quot;O(n)&quot;(n为集合的长度)</li><li>ArrayList在使用的时候，默认的初始化对象数组的大小长度为10，如果空间不足则会采用2倍的形式进行容量的扩充，如果保存大数据量的时候有可能会造成垃圾的产生以及性能的下降，但是这个时候可以使用LinkedList子类保存。</li></ul><h4 id="5-vector子类">5. Vector子类</h4><p>​Vector是一个原始古老的程序类，这个类是在JDK1.0的时候就提供的，而后到了JDK1.2的时候由于许多的开发者已经习惯于使用Vector，并且许多的系统类也是基于Vector实现的，考虑到其使用的广泛性，所以类集框架将其保存了下来，并且让其多实现了一个List接口，观察Vector定义结构:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​继承结构与ArrayList是相同的，所以来讲这个类继承结构如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-5-8220.png" alt="5"></p><p><strong>范例:</strong> Vector类的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> Vector&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"Hello"</span>); <span class="comment">//重复数据</span></span><br><span class="line">all.add(<span class="string">"World"</span>); </span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">all.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面可以进一步的观察Vector类实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Vector类如果使用的是无参构造方法，则一定会默认开辟一个10个长度的数组，而后其余的实现操作与ArrayList是相同的，通过源代码的分析可以发现Vector类之中的操作方法采用的都是synchronized同步处理，而ArrayList并没有进行同步处理，所以Vector类之中的方法在多线程访问的时候属于线程安全的，但是性能不如ArrayList高。</p></blockquote><h3 id="三-set集合">三、Set集合</h3><h4 id="1-set接口简介">1. Set接口简介</h4><p>​Set集合最大的特点就是不允许保存重复元素，其也是Collection子接口。</p><p>​在JDK1.9以前Set集合与Collection集合的定义并无差别，Set继续使用了Collection接口中提供的方法进行操作，但是从JDK1.9之后，Set集合也像List集合一样扩充了一些static方法，Set集合的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​需要注意的是Set集合并不像List集合那样扩充了许多的新方法，所以无法使用List集合中提供的get()犯法，也就是说，它无法实现指定索引数据的获取，Set接口的继承关系如下。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-6-8220.png" alt="6"></p><p>​从JDK1.9之后，Set集合也提供像List集合之中类似的of()的静态方法。下面就使用此方法进行Set集合特点的验证。</p><p><strong>范例:</strong> 验证Set集合特征</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;String&gt; all = Set.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>,<span class="string">"Hello"</span>,<span class="string">"World"</span>);</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果: <code>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: duplicate element: Hello</code></p><p>​当使用of()这个新方法的时候如果发现集合之中存在有重复元素则会直接抛出异常。这与传统的Set集合不保存重复元素的特点相一致，只不过自己抛出了异常而已。</p><p>​Set集合的常规使用形式一定是依靠子类进行实例化的，所以Set接口之中有两个常用子类: HashSet、TreeSet。</p><h4 id="2-hashset子类">2. HashSet子类</h4><p>​HashSet是Set接口里面使用最多的一个子类，其最大的特点就是保存的数据是无序的，而HashSet子类的继承关系如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​这种继承的形式和之前的ArrayList是非常相似的，那么现在来观察一下类的继承结构。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-7-8220.png" alt="7"></p><p><strong>范例:</strong> 观察HashSet子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;() ;</span><br><span class="line">all.add(<span class="string">"DDDD"</span>);</span><br><span class="line">all.add(<span class="string">"DDDD"</span>); <span class="comment">//重复元素</span></span><br><span class="line">all.add(<span class="string">"CCC"</span>);</span><br><span class="line">all.add(<span class="string">"BB"</span>);</span><br><span class="line">all.add(<span class="string">"A"</span>);</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过执行结果就可以发现HashSet子类的操作特点: 不允许保存重复元素(Set接口定义的)，另外一点HashSet之中保存的数据是无序的。</p><h4 id="3-treeset子类">3. TreeSet子类</h4><p>​Set接口的另外一个子类就是TreeSet，与HashSet最大的区别在于TreeSet集合里面所保存的数据是有序的，首先来观察一下TressSet类的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​在这个子类里面依然继承了AbstractSet父抽象类，同时又实现了一个NavigableSet父接口。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-8-8220.png" alt="8"></p><p><strong>范例:</strong> 使用TreeSet子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> TreeSet&lt;String&gt;() ;</span><br><span class="line">all.add(<span class="string">"DDDD"</span>);</span><br><span class="line">all.add(<span class="string">"DDDD"</span>); <span class="comment">//重复元素</span></span><br><span class="line">all.add(<span class="string">"CCC"</span>);</span><br><span class="line">all.add(<span class="string">"BB"</span>);</span><br><span class="line">all.add(<span class="string">"A"</span>);</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当利用TreeSet保存的数据的时候所有的数据都将按照数据的升序进行自动排序处理。</p><h4 id="4-treeset子类排序操作">4. TreeSet子类排序操作</h4><p>​经过分析之后TreeSet子类之中爆粗你的数据是允许排序的，但是这个类必须实现Comparable接口，因为只有实现了此接口才能够确认出对象的大小关系。</p><blockquote><p>提示: TreeSet本质上是利用TreeMap子类实现的集合数据的存储，而TreeMap(树) 就需要根据Comparable来确定大小关系。</p></blockquote><p>​那么下面就使用一个自定义的类来实现排序的处理操作。</p><p><strong>范例:</strong> 实现自定义类排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;<span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line"><span class="comment">//return this.age - per.age ;//因为只判断年龄，所以李四没存进去</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; per.age) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; per.age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(per.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;Person&gt; all = <span class="keyword">new</span> TreeSet&lt;Person&gt;() ;</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">19</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));<span class="comment">//年龄相同，但是姓名不同</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">78</span>));</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在使用自定义类对象进行比较处理的时候一定要将该类之中的所有属性都依次进行大小关系的匹配，否则如果某一个或某几个属性相同的时候，它也会认为是重复数据，所以TreeSet是利用了Comparable接口来确认重复数据的。</p><p>​由于TreeSet在操作过程之中需要将类中的所有属性进行比对，这样的实现难度太高了，那么在实际的开发之中应该首选HashSet子类进行存储。</p><h4 id="5-分析重复元素消除">5. 分析重复元素消除</h4><p>​TreeSet子类是利用了Comparable接口来实现了重复元素的判断，但是Set集合的整体特征就是不允许保存重复元素。但是HashSet判断重复元素的方式并不是利用Comparable接口完成的，它利用的是Object类中提供的方法实现的:</p><ul><li><strong>对象编码:</strong> public int hashCode()</li><li><strong>对象比较:</strong> public boolean equals(Object obj)</li></ul><p>在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果改编码不存在则表示数据不存在，证明没有重复，如果该编码存在了，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。如果使用的是Eclipse开发工具，则可以帮助开发者自动创建hashCode()与equals()方法。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-9-8220.png" alt="9"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-10-8220.png" alt="9"></p><p><strong>范例:</strong> 实现重复元素处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;<span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">result = prime * result + age;</span><br><span class="line">result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Person other = (Person) obj;</span><br><span class="line"><span class="keyword">if</span> (age != other.age)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">Set&lt;Person&gt; all = <span class="keyword">new</span> HashSet&lt;Person&gt;() ;</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">19</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));<span class="comment">//年龄相同，但是姓名不同</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));<span class="comment">//数据重复</span></span><br><span class="line">all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">78</span>));</span><br><span class="line">all.forEach(System.out::println);<span class="comment">//直接输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在Java程序之中真正的重复元素的判断处理利用的就是hashCode()与equals()两个方法共同作用完成的，而只有在排序要求的情况下(TreeSet)才会利用Comparable接口来实现。</p><h3 id="四-集合输出">四、集合输出</h3><p>​集合输出实际上从JDK1.8开始就在Iterable接口之中提供有一个forEach()方法，但是这种方法的迭代输出并不是传统意义上的集合输出形式，并且也很难在实际的开发之中出现，对于集合操作而言，一共有四种输出形式: Iterator迭代输出(95%)、ListIterator双向迭代输出(0.1%)、Enumeration枚举输出(4.9%)、foreach输出(与Iterator相当)。</p><h4 id="1-iterator迭代输出">1. Iterator迭代输出</h4><p>​通过Collection接口的继承关系可以发现，从JDK1.5开始其多继承了一个Iterable父接口，并且在这个接口里面定义有一个Iterator()操作方法，通过此方法可以获取Iterator接口对象(在JDK1.5之前，这一方法直接定义在Collection接口之中)。</p><ul><li>获取Iterator接口对象: public Iterator<T> iterator()</li></ul><p>在Iterator接口里面定义有如下的方法:</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">boolean hasNext()</td><td style="text-align:center">普通</td><td style="text-align:left">判断是否有数据</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public E next()</td><td style="text-align:center">普通</td><td style="text-align:left">取出当前数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public default void remove()</td><td style="text-align:center">普通</td><td style="text-align:left">删除</td></tr></tbody></table><p>​在之前使用的java.util.Scanner类就是Iterator接口的子类，所以此时类的继承关系如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-11-8220.png" alt="11"></p><p><strong>范例:</strong> 使用Iterator输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; all = Set.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = all.iterator() ; <span class="comment">//实例化Iterator接口对象</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String str = iter.next() ;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​但是对于Iterator接口中的remove()方法的使用需要特别注意一下(如果不是必须不要使用)。实际上在Collection接口里面定义有数据的删除操作方法，但是在进行迭代输出的过程里面如果你使用了Collection中的remove方法会导致迭代失败。</p><p><strong>范例:</strong> 采用Collection集合中的remove()方法删除</p><blockquote><p>?为什么我自己写代码的时候，只是有的会显示错误信息捏 =。=? 例如: 下面的代码改为删除World的话 =。=</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = all.iterator() ; <span class="comment">//实例化Iterator接口对象</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String str = iter.next() ;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"World"</span>.equals(str)) &#123;</span><br><span class="line">all.remove(<span class="string">"World"</span>);<span class="comment">//删除当前的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"*** "</span> + all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">程序运行结果: Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><p>​此时无法进行数据的删除处理操作，那么此时就只能够利用Iterator接口中的remove()方法删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = all.iterator() ; <span class="comment">//实例化Iterator接口对象</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">String str = iter.next() ;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"Hello"</span>.equals(str)) &#123;</span><br><span class="line">iter.remove();<span class="comment">//删除当前的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"*** "</span> + all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​此时程序执行之后没有出现任何的错误，并且可以成功的删除原始集合中的数据。</p><p><strong>面试题:</strong> 请解释Collection.remove() 与 Iterator.remove() 的区别?</p><ul><li>在进行迭代输出的时候如果使用了Collection.remove()则会造成并发更新的异常，导致程序删除出错，而此时只能利用Iterator.remove()方法实现正常的删除处理。</li></ul><h4 id="2-listiterator双向迭代输出">2. ListIterator双向迭代输出</h4><p>​使用Iterator进行的迭代输出操作有一个特点: 只允许由前向后实现输出，而如果说你现在需要进行双向迭代处理，那么就必须依靠Iterator的子接口: ListIterator接口来实现了。需要注意的是如果要想获取ListIterator接口对象Collection并没有定义相关的处理方法，但是List子接口有，也就是说这个输出接口是专门为List集合准备的。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-12-8220.png" alt="12">在ListIterator接口里面定义有如下的操作方法:</p><ul><li><p>判断是否有前一个元素: public boolean hasPrevious()</p></li><li><p>获取当前元素: public E previous()</p></li></ul><p><strong>范例:</strong> 实现双向迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = all.listIterator();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"由前向后输出: "</span> );</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">System.out.print(iter.next() + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">"右后向前输出: "</span>);</span><br><span class="line"><span class="keyword">while</span>(iter.hasPrevious()) &#123;</span><br><span class="line">System.out.print(iter.previous() + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果要想实现右后向前的遍历，那么首先要实现的是由前向后实现遍历处理。</p><blockquote><p>例如: 把上面代码的由前向后输出部分注释掉，右后向前则没有输出了。</p></blockquote><h4 id="3-enumeration枚举输出">3. Enumeration枚举输出</h4><p>​Enumeration是在JDK1.0的时候就使用的输出接口，这个输出接口主要是为了Vector类提供输出服务的，一直到后续的JDK的发展，Enumeration依然只为Vector一个类服务，如果要想获取Enumeration接口对象，就必须依靠Vector类提供的方法:</p><ul><li>获取Enumeration: public Enumeration<E> elements()</li></ul><p>在Enumeration接口之中定义有两个操作方法:</p><ul><li>判断是否有下一个元素: public boolean hasMoreElements()</li><li>获取当前元素: public E nextElement()</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-13-8220.png" alt="13"></p><p><strong>范例:</strong> 使用Enumeration实现输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Vector&lt;String&gt; all = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line">Enumeration&lt;String&gt; enu = all.elements() ;</span><br><span class="line"><span class="keyword">while</span> (enu.hasMoreElements()) &#123;</span><br><span class="line">String str = enu.nextElement();</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​由于该接口出现的时间比较长了，所以在一些比较早的开发过程之中，也有部分的方法只支持Enumeration的输出操作，但是随着类方法的不断完善，大部分的操作都直接利用Iterator实现了。</p><h4 id="4-foreach输出">4. foreach输出</h4><p>​除了使用迭代接口实现输出之外，从JDK1.5开始加强型for循环也可以实现集合的输出了。这种输出的形式与数组的输出操作形式类似。</p><p><strong>范例:</strong> 使用foreach输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"Hello"</span>);</span><br><span class="line">all.add(<span class="string">"World"</span>);</span><br><span class="line">all.add(<span class="string">"NGP"</span>);</span><br><span class="line"><span class="keyword">for</span> (String str : all) &#123;</span><br><span class="line">System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这种输出最初出现的时候很多人并不建议使用，因为标准的集合操作还是应该以Iterator为主，但是毕竟JDK1.5都已经推出十多年了，很多的语法也开始被大部分人所习惯。</p><h3 id="五-map集合">五、Map集合</h3><p>​在之前已经学习了Collection接口以及其对应的子接口，可以发现在Collection接口之中所保存的数据全部都只是单个对象，在数结构里面除了可以进行单个对象的保存之外，实际上也可以进行二元偶对象的保存(key=value)的形式来存储，而存储二元偶对象的核心意义在于，需要通过key获取对应的value。</p><p><strong><font color=red>在开发里面：Collection集合保存数据的目的是为了输出，Map集合保存数据的目的是为了进行key的查找。</font></strong></p><h4 id="1-map接口简介">1. Map接口简介</h4><p>​Map接口是进行二元偶对象保存的最大父接口，该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​该接口为一个独立的父接口，并且在进行接口对象实例化的时候需要设置Key与Value的类型，也就是说在整体操作的时候需要保存两个内容，在Map接口里面定义有许多的操作方法，但是需要记住以下的核心操作方法：</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">public V put(K key,V value)</td><td style="text-align:center">普通</td><td style="text-align:left">向集合之中保存数据</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public V get(Object key)</td><td style="text-align:center">普通</td><td style="text-align:left">根据key查询数据</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td style="text-align:center">普通</td><td style="text-align:left">将Map集合转为Set集合</td></tr><tr><td style="text-align:center">04</td><td style="text-align:center">public boolean containsKey(Object key)</td><td style="text-align:center">普通</td><td style="text-align:left">查询指定的key是否存在</td></tr><tr><td style="text-align:center">05</td><td style="text-align:center">public Set<K> keySet()</td><td style="text-align:center">普通</td><td style="text-align:left">将Map集合中的key转为Set集合</td></tr><tr><td style="text-align:center">06</td><td style="text-align:center">public V remove(Object key)</td><td style="text-align:center">普通</td><td style="text-align:left">根据key删除掉指定的数据</td></tr></tbody></table><p>​从JDK1.9之后Map接口里面也扩充了一些静态方法供用户使用。</p><p><strong>范例：</strong> 观察Map集合的特点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = Map.of(<span class="string">"one"</span>,<span class="number">1</span>,<span class="string">"two"</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在Map集合之中数据的保存就是按照 “key=value” 的形式存储的，并且使用of()方法操作的时候，里面的数据是不允许重复的，如果重复则会出现 “IllegalArgumentException” 异常，如果设置的内容为null，则会出现&quot;NullPointerException&quot;异常。</p><p>​对于现在见到的of()方法严格意义上来讲并不是Map集合的标准用法，因为正常的开发之中需要通过Map接口的子类来进行接口对象的实例化，而常用的子类：HashMap、Hashtable、TreeMap、LinkedHashMap。</p><h4 id="2-hashmap子类">2. HashMap子类</h4><p>​HashMap是Map接口之中最为常见的一个子类，该类的主要特点是 <font color=red>无序存储</font>，通过java文档首先来观察一下HashMap子类的定义形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>​该类的定义继承形式符合之前的集合定形式，依然提供有抽象类，并且依然需要重复实现Map接口。</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-14-8220.png" alt="14"></p><p><strong>范例：</strong> 观察Map集合的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">101</span>);<span class="comment">//key重复</span></span><br><span class="line">map.put(<span class="keyword">null</span>, <span class="number">111</span>);<span class="comment">//key为null</span></span><br><span class="line">map.put(<span class="string">"zero"</span>, <span class="keyword">null</span>);  <span class="comment">//value为null</span></span><br><span class="line">System.out.println(map.get(<span class="string">"one"</span>));<span class="comment">//key存在</span></span><br><span class="line">System.out.println(map.get(<span class="keyword">null</span>));<span class="comment">//key存在</span></span><br><span class="line">System.out.println(map.get(<span class="string">"ten"</span>)); <span class="comment">//key不存在</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以上的操作形式为Map集合使用的最标准的处理形式，通过代码可以发现，通过HashMap实例化的Map接口可以针对key或value保存null的数据，同时也可以发现及时保存数据的key重复，那么也不会出现错误，而是出现内容的替换。</p><p>​但是对于Map接口中提供的put()方法本身是提供有返回值的，那么这个返回值指的是在重复key的情况下返回key的value</p><p><strong>范例：</strong> 观察put()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">System.out.println(map.put(<span class="string">"one"</span>,<span class="number">1</span>)); <span class="comment">//key不重复,返回null</span></span><br><span class="line">System.out.println(map.put(<span class="string">"one"</span>,<span class="number">101</span>)); <span class="comment">//key重复,返回旧数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在设置了相同的key的内容的时候put()方法会返回原始的数据内容.</p><p>​清楚了HashMap的基本功能之后, 下面就需要来研究一下HashMap之中给出的源代码. HashMap之中肯定要需要存储大量的数据, 那么对于数据的存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当使用无参构造的时候会出现有一个loadFactor属性, 并且该属性默认的内容为 “0.75” (<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在使用put()方法进行数据保存的时候会调用一个putVal()方法,同时会将key进行hash处理(生成一个hash码), 而对于putValue方法里面会发现依然会提供有一个Node节点类进行数据的保存, 而在使用putValue()方法操作的过程之中会调用有一个resize()的方法可以进行容量的扩充.</p></blockquote><p><strong>面试题:</strong> 在进行HashMap的put()操作的时候,如何实现容量扩充的?</p><ul><li>在HashMap类里面提供有一个 “DEFAULT_INITIAL_CAPACITY” 常量,作为初始化的容量配置,而后这个常量的默认大小为16个元素, 也就是说默认可以保存的最大内容是16;</li><li>当保存的内容的容量超过了一个阈值 (DEFAULT_LOAD_FACTOR = 0.75f), 相当于 “容量*阈值=12” 保存12个元素的时候就会进行容量的扩充;</li><li>在进行扩充的时候HashMap采用的是成倍的扩充模式, 即: 每一次都扩充2倍的容量</li></ul><p><strong>面试题:</strong> 请解释HashMap的工作原理(JDK1.8之后开始的)</p><ul><li>在HashMap之中进行数据存储的依然是利用了Node类完成的, 那么这种情况下就证明可以使用的数据结构只有两种: 链表(时间复杂度&quot;O(n)&quot;)、二叉树(时间复杂度&quot;O(logn)&quot;);</li><li>从JDK1.8开始, HashMap的实现出现了改变, 因为其要适应于大数据时代的海量数据问题,所以对于其存储发生了变化, 并且在HashMap类的内部提供有一个重要的常量: “static final int UNTREEIFY_THRESHOLD = 6;”, 在使用HashMap进行数据保存的时候,如果保存的数据个数没有超过阈值8(UNTREEIFY_THRESHOLD), 那么会按照链表的形式进行存储, 而如果超过了这个阈值, 则会将链表转为<strong>红黑树</strong>以实现树的平衡, 并且利用左旋与右旋保证数据的查询性能.</li></ul><h4 id="3-linkedhashmap子类">3. LinkedHashMap子类</h4><p>​HashMap虽然是Map集合最为常用的一个子类, 但是其本身所保存的数据都是无序的(有序与否对Map没有影响), 如果现在希望Map集合之中保存的顺序为其增加顺序, 则就可以更换子类为LinkedHashMap(基于链表实现的), 观察LinkedHashMap类的定义形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​既然是链表保存, 所以一般在使用LinkedHashMap类的时候往往数据量都不要特别大, 因为会造成时间复杂度攀升. 通过继承结构可以发现LinkedHashMap是HashMap子类,继承关系如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-15-8220.png" alt="15"></p><p><strong>范例:</strong> 使用LinkedHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">101</span>);<span class="comment">//key重复</span></span><br><span class="line">map.put(<span class="keyword">null</span>, <span class="number">111</span>);<span class="comment">//key为null</span></span><br><span class="line">map.put(<span class="string">"zero"</span>, <span class="keyword">null</span>);  <span class="comment">//value为null</span></span><br><span class="line">System.out.println(map);<span class="comment">//key存在</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过此事的程序执行可以发现当使用LinkedHashMap进行存储之后所有数据的保存顺序为我们的添加顺序.</p><h4 id="4-hashtable子类">4. Hashtable子类</h4><p>​Hashtable类是从JDK1.0的时候提供的, 与Vector、Enumeration属于最早的一批动态数组的实现类,后来为了将其继续保存下来所以让其多现实现了一个Map接口, Hashtable类的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-16-8220.png" alt="16"></p><p><strong>范例:</strong> 观察Hashtable子类的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">101</span>);<span class="comment">//key重复</span></span><br><span class="line">System.out.println(map);<span class="comment">//key存在</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过观察可以发现在Hashtable里面进行数据存储的时候设置的key或value都不允许为null, 否则会出现NullPointerException异常.</p><p><strong>面试题:</strong> 请解释HashMap与Hashtable的区别?</p><ul><li>HashMap中的方法都属于异步操作,(非线程安全), HashMap允许保存有null数据</li><li>Hashtable中的方法都属于同步方法(线程安全), Hashtable不允许保存null, 否则会出现NullPointerException.</li></ul><h4 id="5-map-entry接口">5. Map.Entry接口</h4><p>​虽然已经清楚了整个的Map集合的基本操作形式, 但是依然需要有一个核心的问题要解决, Map集合里面是如何进行数据存储的? 对于List而言(LinkedList子类) 依靠的是链表的形式实现的数据存储, 那么在进行数据存储的时候一定要将数据保存在一个Node节点之中, 虽然在HashMap里面也可以见到Node类型定义, 通过源代码定义可以发现, HashMap类中的Node内部类本身实现了Map.Entry接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>​所以可以得出结论: 所有的key和value的诗句都被封装在Map.Entry接口之中, 而此接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并且在这个内部接口里面提供有两个重要的操作方法:</p><ul><li>获取key:   public K getKey()</li><li>获取value: public V getValue()</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-17-8220.png" alt="17"></p><p>​在JDK1.9以前的开发版本之中, 使用者基本上都不会去考虑创建Map.Entry的对象, 实际上在正常的开发过程之中使用者也不需要关心Map.Entry对象的创建, 可是从 JDK1.9之后, Map接口里面追加有一个新的方法</p><ul><li>创建Map.Entry对象: public static &lt;K,V&gt; Map.Entry&lt;K,V&gt; entry(K k, V v)</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-18-8220.png" alt="18"></p><p><strong>范例:</strong> 创建Map.Entry对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map.Entry&lt;String, Integer&gt; entry = Map.entry(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"获取key: "</span> + entry.getKey());</span><br><span class="line">System.out.println(<span class="string">"获取value: "</span> + entry.getValue());</span><br><span class="line">System.out.println(entry.getClass().getName()); <span class="comment">//观察使用的子类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过分析可以发现在整个Map集合里面, Map.Entry的主要作用就是作为一个Key和Value的包装类型使用, 而大部分情况下在进行数据存储的时候都会将key和value包装为一个Map.Entry对象进行使用.</p><h4 id="6-利用iterator输出map集合">6. 利用Iterator输出Map集合</h4><p>​对于集合的输出而言, 最标准的做法就是利用Iterator接口来完成, 但是需要明确一点的是在Map集合里面并没有一个方法可以直接返回Iterator接口对象, 所以这种情况下就必须分析不直接提供Iterator接口实例化的方法的原因, 下面对Collection与Map集合的存储结构进行一个比较处理.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-19-8220.png" alt="19"></p><p>​发现在Map集合里面保存的实际上是一组Map.Entry接口对象(里面包装的是Key与Value), 所以整个来讲Map依然实现的是单值的保存, 这样在Map集合里面提供有一个方法 “public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()”, 将全部的Map集合转为Set集合.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-20-8220.png" alt="20"></p><p>经过分析可以发现如果要想使用Iterator实现Map集合的输出则必须按照如下步骤处理:</p><ul><li>利用Map接口中提供的entrySet()方法将Map集合转为Set集合</li><li>利用Set接口中的iterator()方法将Set集合转为Iterator接口实例;</li><li>利用Iterator进行迭代输出获取每一组的Map.Entry对象, 随后通过getKey()与getValue()获取数据</li></ul><p><strong>范例:</strong> 利用Iterator输出Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>) ;</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>) ;</span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet() ;<span class="comment">//将Map集合变为Set集合</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = set.iterator() ;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;String, Integer&gt; me = iter.next() ;</span><br><span class="line">System.out.println(me.getKey() + <span class="string">" = "</span> + me.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然Map集合本身支持有迭代输出的支持, 但是如果从实际的开发来讲, Map集合最主要的用法在于实现数据的Key查找操作, 另外需要提醒的是, 如果现在不使用Iterator而使用foreach语法输出则也需要将Map集合转为Set集合.</p><p><strong>范例:</strong> 使用foreach输出Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">"one"</span>, <span class="number">1</span>) ;</span><br><span class="line">map.put(<span class="string">"two"</span>, <span class="number">2</span>) ;</span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet() ;<span class="comment">//将Map集合变为Set集合</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : set) &#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于map迭代输出的情况相对较少, 所以对于此类的语法应该深入理解一下, 并且一定要灵活掌握.</p><blockquote><p>因为在实际开发之中, 这些集合互相倒来倒去的情况是非常常见的</p></blockquote><h4 id="7-自定义map的key类型">7. 自定义Map的key类型</h4><p>​在使用Map集合的时候可以发现对于Key和Value的类型实际上都可以由使用者任意决定, 那么也就意味着现在依然可以使用自定义的类来进行key类型的设置. 对于自定义Key类型所在的类中一定要覆写hashCode()与equals()方法, 否则无法查找到.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进行数据保存的时候发现会自动使用传入的key的数据生成一个hash码, 也就是说存储的时候是这个Hash数值.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在根据key获取数据的时候依然要将传入的key通过hash()方法爱获取其对应的hash码, 那么也就证明, 查询的过程之中首先要利用我们的hashCode()来进行数据查询, 当使用getNode()方法查询的时候还需要使用到euqals()方法.</p></blockquote><p><strong>范例:</strong> 使用自定义类作为Key类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name ;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">result = prime * result + age;</span><br><span class="line">result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Person other = (Person) obj;</span><br><span class="line"><span class="keyword">if</span> (age != other.age)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"周瑜"</span>,<span class="number">28</span>), <span class="string">"字公瑾"</span>);<span class="comment">//使用自定义类作为Key</span></span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">"周瑜"</span>,<span class="number">28</span>)));<span class="comment">//通过key找到Value</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然允许你使用是定义的类作为key的类型, 但是也需要注意一点, 在实际的开发之中对于Map集合的Key常用的类型就是三种: String、Long、Integer, 尽量使用系统类.</p><p><strong>面试题:</strong> 如果在进行HashMap进行数据操作的时候出现了Hash冲突(Hash码相同), HashMap是如何解决的?</p><p>​当出现了Hash冲突之后为了保证程序的正常执行, 会在冲突的位置上将所有Hash冲突的内容转为链表保存.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-21-8220.png" alt="21"></p><h3 id="六-集合工具类">六、集合工具类</h3><h4 id="1-stack栈">1. Stack栈</h4><p>​栈是一种先进后出的数据结构. 例如: 在文本编辑器上都有撤销功能, 那么每次使用的时候你会发现, 最后一次的编辑操作永远是最先撤销, 那么这个功能就是利用栈来实现的, 栈的及基本操作形式如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-22-8220.png" alt="22"></p><p>​在Java程序里面使用Stack来描述栈的操作, 这个类定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现Stack是Vector子类, 但是它使用的并不是Vector类之中所提供的方法, 而是采用如下的两个方法:</p><ul><li>入栈: public E push(E item)</li><li>出栈: public E pop()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Stack&lt;String&gt; all = <span class="keyword">new</span> Stack&lt;String&gt; ();</span><br><span class="line">all.push(<span class="string">"A"</span>) ;</span><br><span class="line">all.push(<span class="string">"B"</span>) ;</span><br><span class="line">all.push(<span class="string">"C"</span>) ;</span><br><span class="line">System.out.println(all.pop());</span><br><span class="line">System.out.println(all.pop());</span><br><span class="line">System.out.println(all.pop());</span><br><span class="line">System.out.println(all.pop());<span class="comment">//无数据、EmptyStackException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过此时的数据可以发现, 所有的数据保存之后将按照倒序的形式进行弹出, 如果栈已经空了, 则会抛出空栈异常.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-23-8220.png" alt="23"></p><h4 id="2-queue队列">2. Queue队列</h4><p>​Queue描述的是一个队列, 而队列的主要特点是实现先进先出的操作形式. 其基本的操作形式如下:</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-24-8220.png" alt="24"></p><p>​如果将队列引用在多线程的 “生产者与消费者” 的模型处理上, 那么对于生产者过快生产过快的情况下,就没有必要等待消费者获取数据了, 可以将所有的内容直接保存在队列之中, 队列的实现可以使用LinkedList子类来完.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-25-8220.png" alt="25"></p><p>队列的使用主要依靠Queue接口之中提供的方法来处理. 提供有如下方法:</p><ul><li>向队列之中追加数据: public boolean offer(E e), 可以直接使用add()方法</li><li>通过队列获取数据: public E poll(), 弹出后删除数据</li></ul><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-26-8220.png" alt="26"></p><p><strong>范例:</strong> 实现队列操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt; () ;</span><br><span class="line">queue.offer(<span class="string">"X"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"A"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"Z"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、X</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、A</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、Z</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​除了LinkedList子类之外, 还有一个优先级的概念, 可以使用PriorityQueue实现优先级队列(比较功能),</p><p><strong>范例:</strong> 使用优先级队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;String&gt; () ;</span><br><span class="line">queue.offer(<span class="string">"X"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"A"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">queue.offer(<span class="string">"Z"</span>);<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、X</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、A</span></span><br><span class="line">System.err.println(queue.poll());<span class="comment">//弹出数据 、Z</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​对于队列的选用原则也是需要根据实际的项目环境来决定的.</p><h4 id="3-properties属性操作">3. Properties属性操作</h4><p>​在之前讲解国际化程序的时候讲解过资源文件(*.properties), 那么这类文件的存储结构是按照 “key=value” 的, 而这种结构的保存形式与Map集合很相似, 但是唯一的区别在于其所保存的内容只能够是字符串, 所以为了可以方便的描述属性的定义, java.util包里面提供有Properties类型, 此类是Hashtable的子类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​可以发现在继承Hashtable的时候为Hashtable中定义的泛型为Object, Properties是不需要操作泛型的, 因为它可以操作类型只能是String类型. 在Properties之中如果要想实现属性的操作可以采用如下的方法来实现:</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">方法名称</th><th style="text-align:center">类型</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">public Object setProperty(String key, String value)</td><td style="text-align:center">普通</td><td style="text-align:left">设置属性</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">public String getProperty(String key)</td><td style="text-align:center">普通</td><td style="text-align:left">取得属性, key不存在返回null</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">public String getProperty(String key, String defaultValue)</td><td style="text-align:center">普通</td><td style="text-align:left">取得属性, key不存在返回默认值</td></tr><tr><td style="text-align:center">04</td><td style="text-align:center">public void store(OutputStream out, String comments) throws IOException</td><td style="text-align:center">普通</td><td style="text-align:left">输出属性内容</td></tr><tr><td style="text-align:center">05</td><td style="text-align:center">public void load(InputStream inStream) throws IOException</td><td style="text-align:center">普通</td><td style="text-align:left">通过输入流读取属性内容</td></tr></tbody></table><p>范例: 观察属性的设置与取得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line"><span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"ngp"</span>));</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"sina"</span>,<span class="string">"Nofound"</span>));</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"sina"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过代码可以发现Properties里面可以像Map结婚那样进行内容的设置与获取, 但是唯一的差别是它只能够操作String类型, 另外需要注意的是, 之所以会提供有Properties类还有一个最重要的功能是它可以通过输出流输出属性, 也可以使用输入流读取属性内容.</p><p>范例: 将属性内容保存在文件之中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line"><span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"BeiJing"</span>,<span class="string">"北京"</span>);</span><br><span class="line">prop.store(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"info.properties"</span>)), <span class="string">"中文的注释看不见-english"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过程序的执行可以发现, 的确可以实现资源文件的输入处理, 但是如果输出的是中文则自动帮助用户进行转码处理.</p><p><strong>范例:</strong> 读取资源文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line"><span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"BeiJing"</span>,<span class="string">"北京"</span>);</span><br><span class="line">prop.load(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"info.properties"</span>)));</span><br><span class="line">System.out.println(prop.getProperty(<span class="string">"ngp"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​使用Properties类型的最大特点是可以进行资源内容的输入与输出的处理操作, 但是在实际的开发之中Properties往往用于读取配置资源的信息, 这一点主要是在标准设计之中做程序初始化准备的时候使用.</p><h4 id="4-collections工具类">4. Collections工具类</h4><p>​Collection是java提供的一组集合数据的操作工具类, 也就是说利用它可以实现各个集合的操作.</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-27-8220.png" alt="27"></p><p><strong>范例:</strong> 使用Collection操作List集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong> 数据的反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">Collections.reverse(all);</span><br><span class="line">System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong>  使用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">Collections.sort(all);<span class="comment">// 先进行排序处理</span></span><br><span class="line">System.out.println(all);</span><br><span class="line">System.out.println(Collections.binarySearch(all,<span class="string">"NGP"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分情况下对于集合的使用可能没有这么多复杂要求, 更多的情况下就是利用集合保存数据, 要么进行输出要么进行查询.</p><p>面试题: 请解释Collection与Collections的区别?</p><ul><li>Collection是集合接口, 允许保存单值对象;</li><li>Collection是集合操作的工具类.</li></ul>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="java" scheme="http://tanghao.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Win10桌面文件删除不掉的解决方案</title>
    <link href="http://tanghao.fun/tech/e340017d.html"/>
    <id>http://tanghao.fun/tech/e340017d.html</id>
    <published>2019-04-23T15:10:28.000Z</published>
    <updated>2020-05-07T18:58:36.278Z</updated>
    
    <content type="html"><![CDATA[<h3 id="win10桌面文件删除不掉的解决方案">Win10桌面文件删除不掉的解决方案</h3><p>在桌面新建一个txt文件，其中的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEL /F /A /Q \\?\%1</span><br><span class="line"></span><br><span class="line">RD /S /Q \\?\%1</span><br></pre></td></tr></table></figure><p>将txt文件改名为xxx.bat</p><p>将要删除的文件拖动到该bat文件中则删除成功</p>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="win10" scheme="http://tanghao.fun/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>Springboot-学习中的错误解决</title>
    <link href="http://tanghao.fun/tech/fb16a47d.html"/>
    <id>http://tanghao.fun/tech/fb16a47d.html</id>
    <published>2019-04-20T09:51:29.000Z</published>
    <updated>2020-05-07T18:58:36.278Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-error-could-not-open-c-programfiles-java-jre1-8-0-201-lib-amd64-jvm-cfg">1.Error: could not open `C:\ProgramFiles\Java\jre1.8.0_201\lib\amd64\jvm.cfg’</h4><p>将％JAVA_HOME％\ bin放在PATH的开头。</p><h4 id="2-error-8-2-java-找不到符号-符号-类-springbootapplication">2.Error:(8, 2) java: 找不到符号 符号: 类 SpringBootApplication</h4><p>导入一下 红字 SpringBootApplication 即可</p><p>or file → Invalidate Caches/Restart</p><h4 id="3">3.</h4>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="springboot" scheme="http://tanghao.fun/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Maven-常用命令-镜像</title>
    <link href="http://tanghao.fun/tech/8034adc7.html"/>
    <id>http://tanghao.fun/tech/8034adc7.html</id>
    <published>2019-04-17T05:48:11.000Z</published>
    <updated>2020-05-07T18:58:36.277Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="1-常用maven命令">1.常用maven命令</h4><p>①注意: 执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录。</p><p>与构建过程相关: 编译、测试、打包、…</p><p>②常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn clean              //清理</span><br><span class="line">mvn compile            //编译主程序</span><br><span class="line">mvn test-compole       //编译测试程序</span><br><span class="line">mvn test               //执行测试</span><br><span class="line">mvn package            //打包</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn install     //自己开发的Maven工程，用install安装进仓库</span><br><span class="line">mvn site        //生成站点</span><br></pre></td></tr></table></figure><h4 id="2-关于联网问题">2.关于联网问题</h4><p>①Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。</p><p>②当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。</p><p>③本地仓库的默认位置: [系统中当前用户的家目录]\.m2\repository</p><p><code>C:\Users\[系统中当前用户的家目录]\.m2\repository</code></p><p>④Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。(可设置aliyun镜像加速)</p><p>在 maven-3.X…/conf/setting.xml中的<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>中，添加以下代码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>ibiblio<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mirrors.ibiblio.org/pub/mirrors/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss-public-repository-group<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Public Repository Group<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.org/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 中央仓库在中国的镜像 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven.net.cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>oneof the central mirrors in china<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>⑤如果此时无法连接外网，则构建失败</p><p>⑥修改迷人本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件</p><blockquote><p>[1]找到Maven解压目录\conf\setting.xml</p><p>[2]在setting.xml文件中找到<code>LocalRepository标签</code></p><p>[3]将<code>&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code>从注释中取出</p><p>[4]将标签体内容修改为已经准备好的Maven仓库目录</p><p><code>&lt;localRepository&gt;D:\DevInstall\RepMaven&lt;/localRepository&gt;</code></p></blockquote><h4 id="3-pom">3.POM</h4><p>①含义: Project Object Model 项目对象模型</p><blockquote><p>DOM Document Object Model 文档对象模型</p></blockquote><p>②pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都是在这个文件中进行配置。</p><blockquote><p>重要程度相当于web.xml对于动态Web工程</p></blockquote><h4 id="4-坐标">4.坐标</h4><p>①数学中的坐标:</p><blockquote><p>[1]在平面上，使用X、Y两个向量可以唯一的定位平面中的任何一个点</p><p>[2]在空间中，使用X、Y、Z三个向量可以唯一的定位空间中的任何一个点’</p></blockquote><p>②Maven的坐标(GAV):</p><blockquote><p>使用下面三个向量在仓库中唯一定位一个Maven工程</p><p>[1]groupid: 公司或组织域名倒序+项目名</p><p><code>&lt;groupId&gt;com.ngp.maven&lt;/groupId&gt;</code></p><p>[2]artifactid: 模块名</p><p><code>&lt;artifactId&gt;Hello&lt;/artifactId&gt;</code></p><p>[3]version: 版本</p><p><code>&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</code></p></blockquote><p>③Maven工程的坐标与仓库中路径的对应关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar</span><br></pre></td></tr></table></figure><h4 id="5-仓库">5.仓库</h4><p>①仓库的分类</p><blockquote><p>[1]本地仓库: 当前电脑行部署的仓库目录，为当前电脑上所有的Maven工程服务</p><p>[2]远程仓库:</p><blockquote><p>(1)私服: 搭建在局域网环境中，为局域网范围内的所有Maven工程服务</p><p>(2)中央仓库: 假设在Internet上，为全世界所有Maven工程服务</p><p>(3)中央仓库镜像: 为了分担中央仓库的流量，提升用户访问速度</p></blockquote></blockquote><p>②仓库中的保存的内容: Maven工程</p><blockquote><p>[1]Maven自身所需要的插件</p><p>[2]第三方框架或工具的jar包</p><p>[3]我们自己开发的Maven工程</p></blockquote><h4 id="6-依赖-初步">6.依赖[初步]</h4><p>①Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。</p><blockquote><p>对于我们自己开发的Maven工程，使用install命令安装后就可以进入仓库。</p></blockquote><p>②依赖的范围</p><blockquote><p>[1]compile范围依赖</p><ul><li>对主程序是否有效:   有效</li><li>对测试程序是否有效: 有效</li><li>是否参与打包:       参与</li><li>是否参与部署:       参与</li><li>典型例子:    spring-core</li></ul><p>[2]test范围依赖</p><ul><li>对主程序是否有效:   无效</li><li>对测试程序是否有效: 有效</li><li>是否参与打包:       不参与</li><li>是否参与部署:       不参与</li><li>典型例子: junit</li></ul><p>[3]provided范围依赖(通常在web里面)</p><ul><li>对主程序是否有效:   有效</li><li>对测试程序是否有效: 有效</li><li>是否参与打包:       不参与</li><li>是否参与部署:       不参与</li><li>典型例子: servelet-api.jar</li></ul></blockquote><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-1-321.png" alt="1"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-2-321.png" alt="2"></p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-3-321.png" alt="3"></p><p>— 26节 ----</p><h4 id="7-依赖-高级">7.依赖[高级]</h4><p>①依赖的传递性</p><blockquote><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-4-321.png" alt="4"></p><p>[1]好处: 可以传递的依赖不必在每个模块工程中都重复声明，在 “最下面” 的工程中依赖一次即可。</p><p>[2]注意: 非compiled范围的依赖不能传递。(在这指的就是test、provided)所以在各个工程模块中，如果有需要就得重复声明依赖。</p></blockquote><p>②依赖的排除</p><blockquote><p>[1]需要设置依赖排除的场合</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-5-321.png" alt="5"></p><p>[2]依赖排除的设置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>③依赖的原则</p><blockquote><p>[1]作用: 解决模块工程质检的jar包冲突问题</p><p>[2]情景设定1: 验证路径最短者优先原则</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-6-321.png" alt="6"></p><p>[3]情景设定2: 验证路径相同时先声明者优先</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-7-321.png" alt="7"></p><p>先声明指的是dependency标签的声明顺序</p></blockquote><p>④统一管理依赖版本</p><blockquote><p>[1]情景举例</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-8-321.png" alt="8"></p><p>这里对Spring各个jar包的依赖版本都是4.0.0</p><p>如果需要同一升级为4.1.1，怎么办? 手动逐一修改不可靠。</p><p>[2]建议配置方式</p><blockquote><p>i. 使用properties标签内使用自定义标签统一声明版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt; &gt; <span class="tag">&lt;<span class="name">ngp.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">ngp.spring.version</span>&gt;</span></span><br><span class="line">&gt; &gt; <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>ii.在需要同一版本的位置，使用${自定义标签名}引用声明的版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;ngp.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p>[3]其实properties标签配合自定义标签声明数据的配置并不是只能用于声明依赖的版本号。(还可以配置UTF-8等)凡事需要统一声明后在引用的场合都可以使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">ngp.spring.version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">ngp.spring.version</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h4 id="8-继承">8.继承</h4><p>①现状</p><blockquote><p>Hello依赖的junit: 4.0</p><p>HelloFriend依赖的junit: 4.0</p><p>MakeFriends依赖的junit: 4.9</p><p>由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致</p></blockquote><p>②需求: 同一管理各个模块工程中对junit依赖的版本</p><p>③解决思路: 将junit依赖统一提取到 “父” 工程中，在子工程中声明junit依赖时不指定版本，以父工程中同一设定的为准。同时也便于修改。</p><p>④操作步骤</p><blockquote><p>[1]创建一个Maven工程作为父工程。注意: 打包的方式pom</p><p>[2]在子工程中声明对父工程的引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">&lt;!-- 子工程中声明对父工程的引用 --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ngp.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">verison</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">verison</span>&gt;</span></span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="comment">&lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路劲 --&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>[3]将子工程的坐标中与父工程左边中重复的内容删除</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-9-321.png" alt="9"></p><p>[4]在父工程中统一junit的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>[5]在子工程中删除junit依赖的版本号部分</p><p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-17-10-321.png" alt="10"></p></blockquote><p>⑤注意: 配置继承后，执行安装命令时要先安装父工程。</p><h4 id="9-聚合">9.聚合</h4><p>①作用: 一键安装各个模块工程</p><p>②配置方式: 在一个 “总的聚合工程” 中配置各个参与聚合的模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置聚合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定各个子工程的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../HelloFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../MakeFriends<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③使用方式: 在聚合工程的pom.xml上点右键 → run as → maven install</p><p>从26节起，运行index.jsp的时候就运行不下去了、、没有 choose a … apache6.0的选项。。。之后的都是纯笔记，没有实操</p>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="maven" scheme="http://tanghao.fun/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse-for-Springmvc</title>
    <link href="http://tanghao.fun/tech/83478471.html"/>
    <id>http://tanghao.fun/tech/83478471.html</id>
    <published>2019-04-16T04:55:02.000Z</published>
    <updated>2020-05-07T18:58:36.277Z</updated>
    
    <content type="html"><![CDATA[<p>一. 安装Java EE开发插件(即web插件，能添加Dynamic Web Project那种)</p><p>Help → Install New Software → Work With : <code>2018-12 - http://download.eclipse.org/releases/2018-12</code></p><blockquote><p>p.s. 因为我的Eclipse IDE的版本是2018-12</p></blockquote><p>展开 “Web, XML, Java EE and OSGi Enterprise Development” 选项，并且将下面三个选项打上勾：</p><ul><li><p>Eclipse Java EE Developer Tools</p></li><li><p>Eclipse Java Web Developer Tools</p></li><li><p>Eclipse Web Developer Tools</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\木有 =。= Eclipse XML Editors and Tools</span><br></pre></td></tr></table></figure><p>依次点击“Next ”知道你看到 “ Review licences”的窗口。在这个窗口选择 “I accept the terms of the licence agreement” 并且点击“Finish”。</p><p>二. 安装 apache tomcat6.0</p><p>1 window → preferences → Server → Runtime Environments → add → 里面没有apache</p><p>Help → Eclipse MarketPlace → 搜索JST Server → 安装</p><p>2 此部分转自: <a href="https://blog.csdn.net/jessysong/article/details/69364337">eclipse中配置Tomcat并启动服务器发布项目</a></p><blockquote><p>2.1 tomcat配置：</p><p>服务器 tomcat 6.0</p><p>下载apache-tomcat-6.0.43.tar.gz</p><p>直接解压即可使用，不用安装，解压到目录D:\</p><p>环境变量的配置与JDK一样，在环境变量中添加tomcat路径就好：</p><p>CATALINA_BASE=D:\apache-tomcat-6.0.43<br>CATALINA_HOME=D:\apache-tomcat-6.0.43</p><p>接下来在eclipse中配置tomcat:</p><p>添加新的Server运行时配置。点击Eclipse菜单，【Window】/【Preferences】，展开【Server】/【Runtime Environments】，</p><p>这样，tomcat就配置好了。</p><p>2.2 项目发布与tomcat启动</p><p>在开发和调试阶段Tomcat大多是在eclipse中以插件的形式运行的。eclipse中配置Tomcat过程如下;</p><p>step1:window → preferences → Server → Runtime Environments → add → apache 选择对应的版本</p><p>step2:点击Next，此时若电脑上已经安装了Tomcat，则选择安装路径即可；没有安装，则点击安装按钮</p><p>安装完毕后可以通过Window&gt;show view&gt;servers来显示服务器窗口，在这里就可以(在控制台右侧)看到刚才配置好的Tomcat服务器。</p><p>右键&gt;Start，在Console中可以看到Tomcat的启动信息，启动完毕，打开浏览器访问当前的项目，进入项目页面，配置完成。</p><p>tips：在eclipse中，Tomcat服务器可以同时发布多个项目：</p><p>选中服务器，右键 → Add and Remove 在弹出的对话框中，将需要同时启动的项目移至右面，点击确定就可以同时发布多个项目。</p></blockquote>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="eclipse" scheme="http://tanghao.fun/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud 笔记</title>
    <link href="http://tanghao.fun/tech/e91c9195.html"/>
    <id>http://tanghao.fun/tech/e91c9195.html</id>
    <published>2019-04-13T13:45:23.000Z</published>
    <updated>2020-05-07T18:58:36.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-基本知识点">一. 基本知识点:</h3><h5 id="1-微服务简介">1. 微服务简介</h5><p>微服务提倡将单一应用程序划分为一组微服务，每个服务运行在其自己独立的 <strong>进程</strong> 中。</p><h5 id="2-springcloud-与-dubbo">2. springcloud 与 dubbo</h5><p>springcloud 是基于RESTful</p><p>dubbo 是基于RPC</p><h5 id="3-微服务-与-微服务框架-与-springcloud-不是同一个东西">3. 微服务 与 微服务框架 与 springcloud 不是同一个东西</h5><blockquote><p>微服务:</p><p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看做Eclipse里面的一个个微服务工程/或者Module</p></blockquote><blockquote><p>微服务架构:</p><p><strong>微服务架构</strong>是一种架构模式，它提倡将单一应用程序划分为一组小的服务，服务之间互相协调、相互配合，为用户提供最终价值。每个服务运行在其<strong>独立的进程中</strong>，服务与服务间采用轻量级的通信机制相互协作(通常是基于HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，<strong>应当尽量避免统一的、集中式的服务管理机制</strong>，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p></blockquote><h5 id="4-springcloud和springboot是什么关系">4. SpringCloud和SpringBoot是什么关系</h5><p>SpringBoot专注于快速方便的开发当个个体微服务。</p><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p><p>SpringBoot可以离开SpringCloud独立使用开发项目，<strong>但是SpringCloud离不开SpringBoot</strong>，属于依赖的关系。</p><p><strong>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</strong></p><h5 id="5-书籍-以及-官方教程-在-视频13-3-50处">5. 书籍 以及 官方教程 在 视频13 3:50处</h5><h5 id="6">6.</h5><h5 id="n">n.</h5>]]></content>
    
    <summary type="html">
    
      暂无概述
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="springcloud" scheme="http://tanghao.fun/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>Everything 不显示UAC(用户账户控制)</title>
    <link href="http://tanghao.fun/tech/bbf32a8e.html"/>
    <id>http://tanghao.fun/tech/bbf32a8e.html</id>
    <published>2019-04-08T02:57:53.000Z</published>
    <updated>2020-05-07T18:58:36.275Z</updated>
    
    <content type="html"><![CDATA[<p>控制面板(Ctrl+Q输入control)  →   管理工具  →   任务计划程序  →   创建任务  →</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名称: Everything</span><br><span class="line">√ 使用最高权限</span><br></pre></td></tr></table></figure><p>操作  →   新建  →   浏览  →   找到本地Everything.exe  →   确定</p><p>条件  →   去掉 × 电源-只有在计算机使用交流电时才启动此任务</p><p>桌面  →   右键  →   新建  →   快捷方式  →</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /run /tn Everything    // ← Everything位置填你新建的任务名称</span><br></pre></td></tr></table></figure><p>…</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      单独设置不显示Everything的UAC(用户账户控制)，通过Win10的程序计划任务，原理是:.→通过计划任务启动
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="everything" scheme="http://tanghao.fun/tags/everything/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Google-SEO优化</title>
    <link href="http://tanghao.fun/tech/99e58dd9.html"/>
    <id>http://tanghao.fun/tech/99e58dd9.html</id>
    <published>2019-04-07T11:35:06.000Z</published>
    <updated>2020-05-07T18:58:36.275Z</updated>
    
    <content type="html"><![CDATA[<p>人搭建的博客在搜索引擎被收录的可能很小，SEO可以提高被搜到的几率</p><h3 id="一-生成-sitemap-文件">一. 生成 sitemap 文件</h3><p>需要先安装两个 hexo 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>打开配置文件<code>_config.yml</code>添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p>再重启 hexo，在本地访问 <a href="localhost:4000/sitemap.xml">localhost:4000/sitemap.xml</a>和 <a href="localhost:4000/baidusitemap.xml">localhost:4000/baidusitemap.xml</a> 就能正确的展示出两个sitemap 文件了。</p><h3 id="二-推送到-谷歌-和-百度">二. 推送到 谷歌 和 百度</h3><h4 id="1-百度-添加个人网站">1. 百度 → <a href="https://ziyuan.baidu.com/site/siteadd?siteurl=">添加个人网站</a></h4><p>添加文件方式不可行，hexo会处理html文件</p><p>所以选择，在 head.ejs 里添加 html 标签</p><p>1.1 <a href="https://ziyuan.baidu.com/linksubmit/index">手动提交baidusitemap.xml</a>(里面也有自动提交的代码)</p><p>1.2 可以用&quot;抓取诊断&quot;，手动-百度抓取</p><p>1.3 Robots → 检测并更新</p><p>诶 =。= 是比google方便诶</p><h4 id="2-谷歌-添加个人网站">2. 谷歌 → <a href="https://search.google.com/search-console/welcome">添加个人网站</a></h4><p>类似百度 ，也是在 head.ejs 里添加 html 标签</p><blockquote><p>验证通过就好，过两天左右 百度和谷歌就能收录你的站点</p><p>测试方式: (分别在 google 和 baidu 搜索)</p><p>site: tanghao.fun</p></blockquote><h5 id="2-1-手动提交sitemap-甚至是单个网站">2.1 手动提交sitemap，甚至是单个网站</h5><h5 id="googlesearchconsole-站点地图-输入sitemap-xml-提交"><a href="https://search.google.com/search-console">GoogleSearchConsole</a> → 站点地图 → 输入sitemap.xml → 提交</h5><h5 id="2-2-robots配置">2.2 robots配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /home/</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /about/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: http://yourname.github.io/sitemap.xml</span><br><span class="line">Sitemap: http://yourname.github.io/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>Allow表示允许被访问的，Disallow是不允许的意思。注意后面两个Sitemap就是网站地图了。而网站地图前面说了是给爬虫用的。这里配置在robots中。</p><h5 id="2-3-测试">2.3 测试</h5><p>旧版 GoogleSearchConsole 测试 robots.txt  是否配置好</p><p>新版 GoogleSearchConsole 测试 sitemap.xml 是否配置好</p><h3 id="三-定期清除死链接">三. 定期清除死链接</h3><p><a href="https://www.google.com/webmasters/tools/removals">https://www.google.com/webmasters/tools/removals</a></p><h3 id="参考">参考</h3><p><a href="http://www.dajipai.cc/archives/ec8af0f7.html">http://www.dajipai.cc/archives/ec8af0f7.html</a></p>]]></content>
    
    <summary type="html">
    
      生成sitemap，提交谷歌+百度?，robots配置，定期清除死链接
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="hexo" scheme="http://tanghao.fun/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>$jsimple(Hexo) 经验</title>
    <link href="http://tanghao.fun/tech/7cf41acb.html"/>
    <id>http://tanghao.fun/tech/7cf41acb.html</id>
    <published>2019-04-07T07:40:54.000Z</published>
    <updated>2020-05-07T18:58:36.273Z</updated>
    
    <content type="html"><![CDATA[<p>常用 正则 替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ^#  →  ##</span><br><span class="line">2 D:\hexo\source\images\   →  https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/   //网络图片都是反斜杠&quot;/&quot;</span><br></pre></td></tr></table></figure><h3 id="error">error</h3><ol><li><p>‘hexo’ 不是内部或外部命令，也不是可运行的程序</p><p>把 <code>%hexo%\node_modules\.bin</code> 添加到环境变量path即(%hexo%替换为绝对路径)</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      常用正则替换,快捷键,等等
    
    </summary>
    
      <category term="科技" scheme="http://tanghao.fun/categories/tech/"/>
    
    
      <category term="jsimple" scheme="http://tanghao.fun/tags/jsimple/"/>
    
  </entry>
  
</feed>
