<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://tanghao.fun/warn.html">
<![endif]-->
<meta charset="utf-8">
<meta http-equiv="X-DNS-Prefetch-Control" content="on">
<link rel="dns-prefetch" href="http://tanghao.fun">
<link rel="dns-prefetch" href="//www.google-analytics.com">
<link rel="prefetch" href="http://tanghao.fun">
<link rel="prefetch" href="//www.google-analytics.com">


<link rel="prerender" href="http://tanghao.fun">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://tanghao.fun">
<meta name="author" content="97年的顽石">

<link rel="stylesheet" href="/css/JSimple.css">
<link rel="stylesheet" href="/css/gitalk_without_markdown_style.css">

<link rel="shortcut icon" href="/images/husky.png">


<title>(java高级编程)类集-java10 - 石灰粉</title>

<meta name="keywords" content>

<meta name="description " content="暂无概述">

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                processEscapes: true
            }
        });
    </script>


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC" rel="stylesheet">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #00ffff; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #ff00bf, 0 0 10px #ff00bf; 
    }
    .pace .pace-activity {
        border-top-color: gray;     
        border-left-color: gray;    
    }
</style>
<meta name="baidu-site-verification" content="EEIBPMlFvg">
<meta name="google-site-verification" content="N3Fal_bR6YET3abXuRx_xPNBWUVA0d6D3x17MGZStSs">

    

    
    
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="//www.googletagmanager.com/gtag/js?id=UA-137195466-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-137195466-1');
        </script>
    
    <!-- put your likes here. -->


</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="永">永</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>Home</span></a>
        <a href="/archives" title="Archives"><i class="fa fa-archives"></i><span>Archives</span></a>
        <a href="/tags" title="Tags"><i class="fa fa-tags"></i><span>Tags</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">NGP</h1>
        <h3 class="cover-siteTitle">Is life always this hard or is it just when you&#39;re a kid</h3>
        <p class="cover-siteDesc">当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。</p>
        <div class="cover-sns">
            
    &nbsp;&nbsp;<div class="btn btn-telegram">
        <a href target="_blank" title="telegram" ref="friend">
            <i class="fa fa-telegram"></i>
        </a>
    </div>

    &nbsp;&nbsp;<div class="btn btn-instagram">
        <a href target="_blank" title="instagram" ref="friend">
            <i class="fa fa-instagram"></i>
        </a>
    </div>

    &nbsp;&nbsp;<div class="btn btn-twitter">
        <a href target="_blank" title="twitter" ref="friend">
            <i class="fa fa-twitter"></i>
        </a>
    </div>

    &nbsp;&nbsp;<div class="btn btn-github">
        <a href="https://github.com/ngp320" target="_blank" title="github" ref="friend">
            <i class="fa fa-github"></i>
        </a>
    </div>


        </div>
    </div>
</div>

            <div class="page-title">
    <ul>
        <li><a href="/">Recent Posts</a></li>
        
            
                <li class="active">
                    <a href="/categories/tech" data-name="科技">科技</a>
                </li>
            
                <li class>
                    <a href="/categories/arts" data-name="人文">人文</a>
                </li>
            
                <li class>
                    <a href="/categories/others" data-name="其他">其他</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <input type="text" readonly="readonly" id="local-search-input-tip" placeholder="click to search...">
        <button type="button" disabled="disabled" class="search-form-submit"><i class="fa fa-search"></i></button>
    </form>
</li>

    </ul>
</div>



<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="https://tanghao.fun/" target="_blank">
                    <img width="48" src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/husky.png" alt="avatar">
                </a>
                <p><span class="label">Author</span>
                    <a href="https://tanghao.fun/" target="_blank">97年的顽石</a>
                    <span title="Last edited at&nbsp;2019-04-24">2019-04-24</span>
                </p>
                <p>一条咸鱼罢了</p>
            </div>
            <h2 class="post-title">(Java高级编程)类集-Java10</h2>
			
			<!--Table of Contents begin-->
			
				<div id="toc" class="toc-article">
					<strong class="toc-title">目录</strong>
					<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一-类集框架简介"><span class="toc-text">一、类集框架简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-类集框架简介"><span class="toc-text">1. 类集框架简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-collection接口简介"><span class="toc-text">2. Collection接口简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二-list集合"><span class="toc-text">二、List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-list接口简介"><span class="toc-text">1. List接口简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-arraylist子类"><span class="toc-text">2. ArrayList子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-arraylist保存自定义类对象"><span class="toc-text">3. ArrayList保存自定义类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-linkedlist子类"><span class="toc-text">4. LinkedList子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-vector子类"><span class="toc-text">5. Vector子类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三-set集合"><span class="toc-text">三、Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-set接口简介"><span class="toc-text">1. Set接口简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashset子类"><span class="toc-text">2. HashSet子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-treeset子类"><span class="toc-text">3. TreeSet子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-treeset子类排序操作"><span class="toc-text">4. TreeSet子类排序操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-分析重复元素消除"><span class="toc-text">5. 分析重复元素消除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四-集合输出"><span class="toc-text">四、集合输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-iterator迭代输出"><span class="toc-text">1. Iterator迭代输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-listiterator双向迭代输出"><span class="toc-text">2. ListIterator双向迭代输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-enumeration枚举输出"><span class="toc-text">3. Enumeration枚举输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-foreach输出"><span class="toc-text">4. foreach输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五-map集合"><span class="toc-text">五、Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-map接口简介"><span class="toc-text">1. Map接口简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashmap子类"><span class="toc-text">2. HashMap子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-linkedhashmap子类"><span class="toc-text">3. LinkedHashMap子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-hashtable子类"><span class="toc-text">4. Hashtable子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-map-entry接口"><span class="toc-text">5. Map.Entry接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-利用iterator输出map集合"><span class="toc-text">6. 利用Iterator输出Map集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-自定义map的key类型"><span class="toc-text">7. 自定义Map的key类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六-集合工具类"><span class="toc-text">六、集合工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-stack栈"><span class="toc-text">1. Stack栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-queue队列"><span class="toc-text">2. Queue队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-properties属性操作"><span class="toc-text">3. Properties属性操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-collections工具类"><span class="toc-text">4. Collections工具类</span></a></li></ol></li></ol>
				</div>
			
			<!--Table of Contents end -->
			
            <div class="post-meta">
                emm... 39133 words in the article |
                you are the&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>th friend who reading now
            </div>
        </div>
        <div class="post-content markdown-body">
            <p>[TOC]</p>
<h3 id="一-类集框架简介">一、类集框架简介</h3>
<h4 id="1-类集框架简介">1. 类集框架简介</h4>
<p>​	从JDK1.2开始，Java引入了类集开发框架，所谓的类集指的就是一套动态对象数组的实现方案，在实际的开发之中，没有任何一项的开发可以离开十足，但是传统的数组实现起来非常的繁琐。而且长度是其致命伤。正是因为长度的问题，所以传统的数组是不可能大范围使用的，但是我们的开发又不可能离开数组，所以最初就只能依靠一些数据结构来实现动态的数组处理，而其中最为重要的两个结构: 链表、树，但是面对这些数据结构的实现又不得不面对如下的一些困哪:</p>
<ul>
<li>数据结构的代码实现困难，对于一般的开发者是无法进行使用的;</li>
<li>对于链表或二叉树当进行更新处理的时候的维护是非常麻烦的;</li>
<li>对于链表或二叉树还需要尽可能保证其操作的性能。</li>
</ul>
<p>正是因为这样的原因，所以从JDK1.2开始Java引入了类集，主要就是对常见的数据结构进行完整的实现包装，并且提供有一系列的接口与实现子类来帮助用户减少数据结构所带来的的开发困难，</p>
<blockquote>
<p>这个就是类集的产生意义所在。以后数据结构不要自己来写了，但是你千万要记住一个过程: 对于现阶段开发里面，类集有它一些固定的使用方法，但是我们在进行子类选择的时候，我们一定要知道它的各个子类的实现算法是怎么回事，这样才能确保我们的程序高效。</p>
<blockquote>
<p>举个例子来讲，如果在正常的设计选择过程当中，我发现我存的数据是固定长度或者说绝对不会超过某些长度，应该是用数据来操作是最简单的吧，因为什么? 因为数组是一个线性结构，时间复杂度为1。</p>
<p>也就是说，正常情况来讲，类集里面它也要区分子类的不同而有所不同。</p>
</blockquote>
</blockquote>
<p>​	但是最初的类集实现由于Java本身的技术所限，所以对于数据的控制并不严格，全部采用了Object类型进行数据接收，而在JDK1.5之后由于泛型技术的推广，所以类集本身也得到了良好的改进，可以直接利用泛型来保存相同类型的数据，并且随着数据量的不断增加，从JDK1.8开始类集中的实现算法也得到了良好的性能提升。</p>
<blockquote>
<p>但是你们在学习之中应该清楚的知道类集之中所采用的性能提高的方式是什么，这个必须自己能够说出来</p>
</blockquote>
<p>在整个类集框架里面提供有如下的几个核心接口: Collection、List、Set、Map、Iterator、Enumeration、Queue、ListIterator。</p>
<h4 id="2-collection接口简介">2. Collection接口简介</h4>
<p>java.util.Collection是单值集合操作的最大的父接口，在该接口之中定义有所有的单值数据的处理操作。这个接口之中定义有如下的核心操作方法:</p>
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><font color="red"> 01</font></td>
<td style="text-align:center"><font color="red">public boolean add(E e)</font></td>
<td style="text-align:center"><font color="red"> 普通</font></td>
<td style="text-align:left"><font color="red">向集合保存数据</font></td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">public boolean addAll(Collection&lt;? extends E&gt; e)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">追加一组数据</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">public void clear()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">清空集合，让根节点为空，同时执行GC处理</td>
</tr>
<tr>
<td style="text-align:center">04</td>
<td style="text-align:center">public boolean contains(Object o)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">查询数据是否存在，需要equals()方法支持</td>
</tr>
<tr>
<td style="text-align:center">05</td>
<td style="text-align:center">public boolean remove(Object o)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">数据删除，需要equals()方法支持</td>
</tr>
<tr>
<td style="text-align:center">06</td>
<td style="text-align:center">public int size()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">获取数据长度</td>
</tr>
<tr>
<td style="text-align:center">07</td>
<td style="text-align:center">public Object[] toArray()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">将集合变为对象数组返回</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">08</font></td>
<td style="text-align:center"><font color="red">public Iterator&lt;E&gt; iterator()</font></td>
<td style="text-align:center"><font color="red">普通</font></td>
<td style="text-align:left"><font color="red">将集合变为Iterator接口</font></td>
</tr>
</tbody>
</table>
<p>​	在进行集合操作的时候有两个方法最为常用:【增加】add()、【输出】iterator()，在JDK1.5版本以前，Collection只是一个独立的接口，但是从JDK1.5之后提供有了Iterable父接口，并且在JDK1.8的之后针对于Iterable接口也得到了一些扩充。</p>
<p>​	另外在JDK1.2~JDK1.4的时代如果要进行集合的使用往往会直接操作Collection的接口，但是从JDK1.5时代开始更多的情况下选择的都是Collection的两个子接口: 允许重复的List子接口、不允许重复的Set子接口;</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-1-8220.png" alt="1"></p>
<blockquote>
<p>现阶段的开发不要再去用Collection了，这个主要是 微软的Sun的 战争引起的。</p>
</blockquote>
<h3 id="二-list集合">二、List集合</h3>
<h4 id="1-list接口简介">1. List接口简介</h4>
<p>List是Collection的子接口，其最大的特点是允许保存有重复元素数据，该接口的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是需要清楚的是List子接口对于Collection接口进行了方法扩充。</p>
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><font color="red">01</font></td>
<td style="text-align:center"><font color="red">public E get(int index)</font></td>
<td style="text-align:center"><font color="red">普通</font></td>
<td style="text-align:left"><font color="red">获取指定索引上的数据</font></td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">public E set(int index,E element)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">修改指定索引数据</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">public ListIterator<e> listIterator()</e></td>
<td style="text-align:center">普通</td>
<td style="text-align:left">返回ListIterator接口对象</td>
</tr>
</tbody>
</table>
<p>​	但是List本身依然属于一个接口，那么对于接口要想使用则一定要使用子类来完成定义，在List子接口中有三个常用子类: ArrayList、LinkedList、Vector。</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-2-8220.png" alt="2"></p>
<p>​	从JDK1.9开始，List子接口里面追加有一些static方法，以方便用户的处理。</p>
<p><strong>范例:</strong> 观察List中的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = List.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"你好"</span>,<span class="string">"NGP"</span>,<span class="string">"饿了么?"</span>);</span><br><span class="line">		Object result [] = all.toArray();</span><br><span class="line">		<span class="keyword">for</span>(Object temp : result) &#123;</span><br><span class="line">			System.out.print(temp + <span class="string">"、"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	这些操作方法并不是List传统用法，是在新版本之后添加的新功能。</p>
<blockquote>
<p>在开发当中，因为JDK9或JDK10没有广泛开来，所以大家最好用原始的方式开发</p>
</blockquote>
<h4 id="2-arraylist子类">2. ArrayList子类</h4>
<p>​	ArrayList是 List子接口使用最多的一个子类，但是这个子类在使用的时候也是有前提要求的，所以本次来对这个类的相关定义以及源代码组成进行分析，在 Java 里面ArrayList类的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>​	ArrayList子类的继承结构</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-3-8220.png" alt="3"></p>
<p><strong>范例:</strong> 使用ArrayList实例化List父接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		System.out.println(all);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过本程序可以发现List存储的特征:</p>
<ul>
<li>保存的顺序就是其存储顺序;</li>
<li>List集合里面允许存在有重复数据。</li>
</ul>
<p>在以上的程序里面虽然实现了集合的输出，但是这种输出的操作是直接利用了每一个类提供的toString()方法实现的，为了方便的进行处理，在JDK1.8之后Iterable父接口之中定义有一个forEach()方法，方法定义如下:</p>
<ul>
<li>输出支持: default void forEach(Consumer&lt;? super T&gt; action)</li>
</ul>
<p><strong>范例:</strong> 利用forEach()方法输出(不是标准输出)</p>
<blockquote>
<p>只是在使用java的时候方便一些，正常开发是不可能用它来完成的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		all.forEach((str)-&gt;&#123;</span><br><span class="line">			System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	需要注意的是，此种输出并不是在正常开发情况下要考虑的操作形式。</p>
<p><strong>范例:</strong> 观察List集合的其他操作方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">		System.out.println(<span class="string">"集合是否为空?"</span> + all.isEmpty() + <span class="string">"、集合元素个数: "</span> + all.size());</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);  <span class="comment">//重复数据</span></span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		all.remove(<span class="string">"Hello"</span>);</span><br><span class="line">		System.out.println(<span class="string">"集合是否为空?"</span> + all.isEmpty() + <span class="string">"、集合元素个数: "</span> + all.size());</span><br><span class="line">		all.forEach((str)-&gt;&#123;</span><br><span class="line">			System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	如果以方法的功能为例，那么ArrayList里面操作支持与之前编写的链表形式是非常相似的，但是它并不是使用链表来实现的，通过类名称实际上就已经可以清楚的发现了，ArrayList应该封装的是一个数组。</p>
<table>
<thead>
<tr>
<th>ArrayList构造:<br>public ArrayList()</th>
<th>public ArrayList() {<br>  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br>--------------------------------<br>public</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>private static final Object[] EMPTY_ELEMENTDATA = {};</td>
</tr>
<tr>
<td>ArrayList构造:<br>public ArrayList(int initialCapacity)</td>
<td>public ArrayList(int initialCapacity) {<br>  if (initialCapacity &gt; 0) {<br>    this.elementData = new Object[initialCapacity];<br>  } else if (initialCapacity == 0) {<br>    this.elementData = EMPTY_ELEMENTDATA;<br>  } else {<br>    throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);<br>  }<br>}</td>
</tr>
<tr>
<td></td>
<td>transient Object[] elementData;// non-private to simplify nested class access</td>
</tr>
</tbody>
</table>
<p>​	通过有参构造方法可以发现，在ArrayList里面所包含的数据实际上就是一个对象数组。如果现在在进行数据追加的时候发现ArrayList集合里面保存的对象数组的长度不够的时候，会进行新的数组开辟，同时将原始的旧数组内容拷贝到新数组之中，而后数组的开辟操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>) ? newCapacity: hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	如果在实例化ArrayList类对象的时候并没有传递初始化的长度，则默认情况下会使用一个空数组，但是如果在进行数据增加的时候发现数组容量不够了。则会判断当前的增长的容量与默认的容量的大小，使用较大的一个数据进行新的数组开辟，所以可以得出一个结论:</p>
<table>
<thead>
<tr>
<th>JDK1.9之后:</th>
<th>ArrayList默认的构造只会使用默认的空数组，使用的时候才会开辟数组，默认的开辟长度为10;</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK1.9之前</td>
<td>ArrayList默认的构造实际上就会默认开辟大小为10的数组。</td>
</tr>
</tbody>
</table>
<p>​	当ArrayList之中保存的容量不足的时候会采用成倍的方式进行增长，原始长度为10，那么下次的增长就是20，依此类推。</p>
<p>​	在使用ArrayList子类的时候一定要估算出你的数据量会有多少，如果超过了10个，那么使用有参构造方法进行创建，以避免垃圾数组的空间产生。</p>
<h4 id="3-arraylist保存自定义类对象">3. ArrayList保存自定义类对象</h4>
<p>通过之前的分析已经清楚了ArrayList子类的实现原理以及List核心操作，但是在测试的时候使用的是系统提供的String类，这是一个设计非常完善的类，而对于类集而言也可以实现自定义类对象的保存。</p>
<p><strong>范例:</strong> 实现自定义类对象的保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Person per = (Person) obj;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(per.name) &amp;&amp; <span class="keyword">this</span>.age == per.age;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//setter、getter、构造略</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;Person&gt; all = <span class="keyword">new</span> ArrayList&lt;Person&gt; ();</span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">30</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">16</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>));</span><br><span class="line">		System.out.println(all.contains(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>)));</span><br><span class="line">		all.remove(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">18</span>));</span><br><span class="line">		all.forEach(System.out::println); <span class="comment">//方法引用代替了消费型的接口，不是标准做法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	在使用List保存自定义类对象的时候如果需要使用到contains()、remove()方法进行查询与删除处理的时候，一定要保证类之中已经成功覆写了equals()方法。</p>
<h4 id="4-linkedlist子类">4. LinkedList子类</h4>
<p>​	在List接口里面还有另外一个比较常用的子类: LinkedList,这个类通过名称就已经可以发现其特点了: 基于链表的实现，那么我们首先来观察一下LinkedList子类的定义:</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-4-8220.png" alt="4"></p>
<p>范例: 使用LinkedList实现集合操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> LinkedList&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"Hello"</span>); <span class="comment">//重复数据</span></span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		all.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	如果说现在只是观察程序的功能你会发现和ArrayList使用是完全一样的，但是其内部的实现机制是完全不同的，首先观察LinkedList构造方法里面并没有提供有像ArrayList那样的初始化大小的方法，而只是提供有无参构造处理:  “public LinkedList()” 随后观察add()方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在之前编写自定义链表的时候，是判断了传入数据是否为null，如果为null则不进行保存，但是在LinkedList里面并没有做这样的处理，而是所有的数据都可以保存，而后此方法调用了linkLast()方法 (在最后一个节点进行追加)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  last = newNode;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在LinedList类里面保存的数据都是利用Node节点进行的封装处理，同时为了提高程序执行性能，每一次都会保存上一个追加的节点(最后一个节点)，这样就可以在增加数据的时候避免递归处理，在增加数据的时候要进行数据保存个数的追加。</p>
</blockquote>
<p>​	通过一系列的分析之后可以发现，LinkedList封装的就是一个链表实现。</p>
<p><strong>面试题:</strong> 请问ArrayList与LinkedList有何区别?</p>
<ul>
<li>ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作。</li>
<li>在使用List集合中的get()方法根据索引取数据时，ArrayList的时间复杂度为&quot;O(1)&quot;，而LinkedList时间复杂度为&quot;O(n)&quot;(n为集合的长度)</li>
<li>ArrayList在使用的时候，默认的初始化对象数组的大小长度为10，如果空间不足则会采用2倍的形式进行容量的扩充，如果保存大数据量的时候有可能会造成垃圾的产生以及性能的下降，但是这个时候可以使用LinkedList子类保存。</li>
</ul>
<h4 id="5-vector子类">5. Vector子类</h4>
<p>​	Vector是一个原始古老的程序类，这个类是在JDK1.0的时候就提供的，而后到了JDK1.2的时候由于许多的开发者已经习惯于使用Vector，并且许多的系统类也是基于Vector实现的，考虑到其使用的广泛性，所以类集框架将其保存了下来，并且让其多实现了一个List接口，观察Vector定义结构:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>​	继承结构与ArrayList是相同的，所以来讲这个类继承结构如下:</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-5-8220.png" alt="5"></p>
<p><strong>范例:</strong> Vector类的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> Vector&lt;String&gt;() ; <span class="comment">//为List父接口进行实例化</span></span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"Hello"</span>); <span class="comment">//重复数据</span></span><br><span class="line">		all.add(<span class="string">"World"</span>); </span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		all.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	下面可以进一步的观察Vector类实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Vector类如果使用的是无参构造方法，则一定会默认开辟一个10个长度的数组，而后其余的实现操作与ArrayList是相同的，通过源代码的分析可以发现Vector类之中的操作方法采用的都是synchronized同步处理，而ArrayList并没有进行同步处理，所以Vector类之中的方法在多线程访问的时候属于线程安全的，但是性能不如ArrayList高。</p>
</blockquote>
<h3 id="三-set集合">三、Set集合</h3>
<h4 id="1-set接口简介">1. Set接口简介</h4>
<p>​	Set集合最大的特点就是不允许保存重复元素，其也是Collection子接口。</p>
<p>​	在JDK1.9以前Set集合与Collection集合的定义并无差别，Set继续使用了Collection接口中提供的方法进行操作，但是从JDK1.9之后，Set集合也像List集合一样扩充了一些static方法，Set集合的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	需要注意的是Set集合并不像List集合那样扩充了许多的新方法，所以无法使用List集合中提供的get()犯法，也就是说，它无法实现指定索引数据的获取，Set接口的继承关系如下。</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-6-8220.png" alt="6"></p>
<p>​	从JDK1.9之后，Set集合也提供像List集合之中类似的of()的静态方法。下面就使用此方法进行Set集合特点的验证。</p>
<p><strong>范例:</strong> 验证Set集合特征</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">		Set&lt;String&gt; all = Set.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>,<span class="string">"Hello"</span>,<span class="string">"World"</span>);</span><br><span class="line">		all.forEach(System.out::println);	<span class="comment">//直接输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果: <code>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: duplicate element: Hello</code></p>
<p>​	当使用of()这个新方法的时候如果发现集合之中存在有重复元素则会直接抛出异常。这与传统的Set集合不保存重复元素的特点相一致，只不过自己抛出了异常而已。</p>
<p>​	Set集合的常规使用形式一定是依靠子类进行实例化的，所以Set接口之中有两个常用子类: HashSet、TreeSet。</p>
<h4 id="2-hashset子类">2. HashSet子类</h4>
<p>​	HashSet是Set接口里面使用最多的一个子类，其最大的特点就是保存的数据是无序的，而HashSet子类的继承关系如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>​	这种继承的形式和之前的ArrayList是非常相似的，那么现在来观察一下类的继承结构。</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-7-8220.png" alt="7"></p>
<p><strong>范例:</strong> 观察HashSet子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">		Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;() ;</span><br><span class="line">		all.add(<span class="string">"DDDD"</span>);</span><br><span class="line">		all.add(<span class="string">"DDDD"</span>); <span class="comment">//重复元素</span></span><br><span class="line">		all.add(<span class="string">"CCC"</span>);</span><br><span class="line">		all.add(<span class="string">"BB"</span>);	</span><br><span class="line">		all.add(<span class="string">"A"</span>);</span><br><span class="line">		all.forEach(System.out::println);	<span class="comment">//直接输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过执行结果就可以发现HashSet子类的操作特点: 不允许保存重复元素(Set接口定义的)，另外一点HashSet之中保存的数据是无序的。</p>
<h4 id="3-treeset子类">3. TreeSet子类</h4>
<p>​	Set接口的另外一个子类就是TreeSet，与HashSet最大的区别在于TreeSet集合里面所保存的数据是有序的，首先来观察一下TressSet类的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>​	在这个子类里面依然继承了AbstractSet父抽象类，同时又实现了一个NavigableSet父接口。</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-8-8220.png" alt="8"></p>
<p><strong>范例:</strong> 使用TreeSet子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">		Set&lt;String&gt; all = <span class="keyword">new</span> TreeSet&lt;String&gt;() ;</span><br><span class="line">		all.add(<span class="string">"DDDD"</span>);</span><br><span class="line">		all.add(<span class="string">"DDDD"</span>); <span class="comment">//重复元素</span></span><br><span class="line">		all.add(<span class="string">"CCC"</span>);</span><br><span class="line">		all.add(<span class="string">"BB"</span>);	</span><br><span class="line">		all.add(<span class="string">"A"</span>);</span><br><span class="line">		all.forEach(System.out::println);	<span class="comment">//直接输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	当利用TreeSet保存的数据的时候所有的数据都将按照数据的升序进行自动排序处理。</p>
<h4 id="4-treeset子类排序操作">4. TreeSet子类排序操作</h4>
<p>​	经过分析之后TreeSet子类之中爆粗你的数据是允许排序的，但是这个类必须实现Comparable接口，因为只有实现了此接口才能够确认出对象的大小关系。</p>
<blockquote>
<p>提示: TreeSet本质上是利用TreeMap子类实现的集合数据的存储，而TreeMap(树) 就需要根据Comparable来确定大小关系。</p>
</blockquote>
<p>​	那么下面就使用一个自定义的类来实现排序的处理操作。</p>
<p><strong>范例:</strong> 实现自定义类排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;	<span class="comment">//比较器</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		return this.age - per.age ;		//因为只判断年龄，所以李四没存进去</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; per.age) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span> ;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; per.age) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(per.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">		Set&lt;Person&gt; all = <span class="keyword">new</span> TreeSet&lt;Person&gt;() ;</span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">19</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));	<span class="comment">//年龄相同，但是姓名不同</span></span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));	<span class="comment">//数据重复</span></span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));	<span class="comment">//数据重复</span></span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">78</span>));</span><br><span class="line">		all.forEach(System.out::println);	<span class="comment">//直接输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	在使用自定义类对象进行比较处理的时候一定要将该类之中的所有属性都依次进行大小关系的匹配，否则如果某一个或某几个属性相同的时候，它也会认为是重复数据，所以TreeSet是利用了Comparable接口来确认重复数据的。</p>
<p>​	由于TreeSet在操作过程之中需要将类中的所有属性进行比对，这样的实现难度太高了，那么在实际的开发之中应该首选HashSet子类进行存储。</p>
<h4 id="5-分析重复元素消除">5. 分析重复元素消除</h4>
<p>​	TreeSet子类是利用了Comparable接口来实现了重复元素的判断，但是Set集合的整体特征就是不允许保存重复元素。但是HashSet判断重复元素的方式并不是利用Comparable接口完成的，它利用的是Object类中提供的方法实现的:</p>
<ul>
<li><strong>对象编码:</strong> public int hashCode()</li>
<li><strong>对象比较:</strong> public boolean equals(Object obj)</li>
</ul>
<p>在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果改编码不存在则表示数据不存在，证明没有重复，如果该编码存在了，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。如果使用的是Eclipse开发工具，则可以帮助开发者自动创建hashCode()与equals()方法。</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-9-8220.png" alt="9"></p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-10-8220.png" alt="9"></p>
<p><strong>范例:</strong> 实现重复元素处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;	<span class="comment">//比较器</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"、年龄: "</span> + <span class="keyword">this</span>.age ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		result = prime * result + age;</span><br><span class="line">		result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Person other = (Person) obj;</span><br><span class="line">		<span class="keyword">if</span> (age != other.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//进行Set集合数据的保存，并且设置有重复的内容</span></span><br><span class="line">		Set&lt;Person&gt; all = <span class="keyword">new</span> HashSet&lt;Person&gt;() ;</span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">19</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));	<span class="comment">//年龄相同，但是姓名不同</span></span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));	<span class="comment">//数据重复</span></span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));	<span class="comment">//数据重复</span></span><br><span class="line">		all.add(<span class="keyword">new</span> Person(<span class="string">"小强"</span>,<span class="number">78</span>));</span><br><span class="line">		all.forEach(System.out::println);	<span class="comment">//直接输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	在Java程序之中真正的重复元素的判断处理利用的就是hashCode()与equals()两个方法共同作用完成的，而只有在排序要求的情况下(TreeSet)才会利用Comparable接口来实现。</p>
<h3 id="四-集合输出">四、集合输出</h3>
<p>​	集合输出实际上从JDK1.8开始就在Iterable接口之中提供有一个forEach()方法，但是这种方法的迭代输出并不是传统意义上的集合输出形式，并且也很难在实际的开发之中出现，对于集合操作而言，一共有四种输出形式: Iterator迭代输出(95%)、ListIterator双向迭代输出(0.1%)、Enumeration枚举输出(4.9%)、foreach输出(与Iterator相当)。</p>
<h4 id="1-iterator迭代输出">1. Iterator迭代输出</h4>
<p>​	通过Collection接口的继承关系可以发现，从JDK1.5开始其多继承了一个Iterable父接口，并且在这个接口里面定义有一个Iterator()操作方法，通过此方法可以获取Iterator接口对象(在JDK1.5之前，这一方法直接定义在Collection接口之中)。</p>
<ul>
<li>获取Iterator接口对象: public Iterator<t> iterator()</t></li>
</ul>
<p>在Iterator接口里面定义有如下的方法:</p>
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">boolean hasNext()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">判断是否有数据</td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">public E next()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">取出当前数据</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">public default void remove()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">删除</td>
</tr>
</tbody>
</table>
<p>​	在之前使用的java.util.Scanner类就是Iterator接口的子类，所以此时类的继承关系如下:</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-11-8220.png" alt="11"></p>
<p><strong>范例:</strong> 使用Iterator输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Set&lt;String&gt; all = Set.of(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">		Iterator&lt;String&gt; iter = all.iterator() ; 	<span class="comment">//实例化Iterator接口对象</span></span><br><span class="line">		<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">			String str = iter.next() ;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	但是对于Iterator接口中的remove()方法的使用需要特别注意一下(如果不是必须不要使用)。实际上在Collection接口里面定义有数据的删除操作方法，但是在进行迭代输出的过程里面如果你使用了Collection中的remove方法会导致迭代失败。</p>
<p><strong>范例:</strong> 采用Collection集合中的remove()方法删除</p>
<blockquote>
<p>?为什么我自己写代码的时候，只是有的会显示错误信息捏 =。=? 例如: 下面的代码改为删除World的话 =。=</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		Iterator&lt;String&gt; iter = all.iterator() ; 	<span class="comment">//实例化Iterator接口对象</span></span><br><span class="line">		<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">			String str = iter.next() ;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"World"</span>.equals(str)) &#123;</span><br><span class="line">				all.remove(<span class="string">"World"</span>);	<span class="comment">//删除当前的数据</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;				</span><br><span class="line">				System.out.println(str);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"*** "</span> + all);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">程序运行结果: Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<p>​	此时无法进行数据的删除处理操作，那么此时就只能够利用Iterator接口中的remove()方法删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Set&lt;String&gt; all = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		Iterator&lt;String&gt; iter = all.iterator() ; 	<span class="comment">//实例化Iterator接口对象</span></span><br><span class="line">		<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">			String str = iter.next() ;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"Hello"</span>.equals(str)) &#123;</span><br><span class="line">				iter.remove();	<span class="comment">//删除当前的数据</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;				</span><br><span class="line">				System.out.println(str);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"*** "</span> + all);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	此时程序执行之后没有出现任何的错误，并且可以成功的删除原始集合中的数据。</p>
<p><strong>面试题:</strong> 请解释Collection.remove() 与 Iterator.remove() 的区别?</p>
<ul>
<li>在进行迭代输出的时候如果使用了Collection.remove()则会造成并发更新的异常，导致程序删除出错，而此时只能利用Iterator.remove()方法实现正常的删除处理。</li>
</ul>
<h4 id="2-listiterator双向迭代输出">2. ListIterator双向迭代输出</h4>
<p>​	使用Iterator进行的迭代输出操作有一个特点: 只允许由前向后实现输出，而如果说你现在需要进行双向迭代处理，那么就必须依靠Iterator的子接口: ListIterator接口来实现了。需要注意的是如果要想获取ListIterator接口对象Collection并没有定义相关的处理方法，但是List子接口有，也就是说这个输出接口是专门为List集合准备的。</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-12-8220.png" alt="12">在ListIterator接口里面定义有如下的操作方法:</p>
<ul>
<li>
<p>判断是否有前一个元素: public boolean hasPrevious()</p>
</li>
<li>
<p>获取当前元素: public E previous()</p>
</li>
</ul>
<p><strong>范例:</strong> 实现双向迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		ListIterator&lt;String&gt; iter = all.listIterator();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"由前向后输出: "</span> );</span><br><span class="line">		<span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">			System.out.print(iter.next() + <span class="string">"、"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">"右后向前输出: "</span>);</span><br><span class="line">		<span class="keyword">while</span>(iter.hasPrevious()) &#123;</span><br><span class="line">			System.out.print(iter.previous() + <span class="string">"、"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	如果要想实现右后向前的遍历，那么首先要实现的是由前向后实现遍历处理。</p>
<blockquote>
<p>例如: 把上面代码的由前向后输出部分注释掉，右后向前则没有输出了。</p>
</blockquote>
<h4 id="3-enumeration枚举输出">3. Enumeration枚举输出</h4>
<p>​	Enumeration是在JDK1.0的时候就使用的输出接口，这个输出接口主要是为了Vector类提供输出服务的，一直到后续的JDK的发展，Enumeration依然只为Vector一个类服务，如果要想获取Enumeration接口对象，就必须依靠Vector类提供的方法:</p>
<ul>
<li>获取Enumeration: public Enumeration<e> elements()</e></li>
</ul>
<p>在Enumeration接口之中定义有两个操作方法:</p>
<ul>
<li>判断是否有下一个元素: public boolean hasMoreElements()</li>
<li>获取当前元素: public E nextElement()</li>
</ul>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-13-8220.png" alt="13"></p>
<p><strong>范例:</strong> 使用Enumeration实现输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Vector&lt;String&gt; all = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		Enumeration&lt;String&gt; enu = all.elements() ;</span><br><span class="line">		<span class="keyword">while</span> (enu.hasMoreElements()) &#123;</span><br><span class="line">			String str = enu.nextElement();</span><br><span class="line">			System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	由于该接口出现的时间比较长了，所以在一些比较早的开发过程之中，也有部分的方法只支持Enumeration的输出操作，但是随着类方法的不断完善，大部分的操作都直接利用Iterator实现了。</p>
<h4 id="4-foreach输出">4. foreach输出</h4>
<p>​	除了使用迭代接口实现输出之外，从JDK1.5开始加强型for循环也可以实现集合的输出了。这种输出的形式与数组的输出操作形式类似。</p>
<p><strong>范例:</strong> 使用foreach输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		all.add(<span class="string">"Hello"</span>);</span><br><span class="line">		all.add(<span class="string">"World"</span>);</span><br><span class="line">		all.add(<span class="string">"NGP"</span>);</span><br><span class="line">		<span class="keyword">for</span> (String str : all) &#123;</span><br><span class="line">			System.out.print(str + <span class="string">"、"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	这种输出最初出现的时候很多人并不建议使用，因为标准的集合操作还是应该以Iterator为主，但是毕竟JDK1.5都已经推出十多年了，很多的语法也开始被大部分人所习惯。</p>
<h3 id="五-map集合">五、Map集合</h3>
<p>​	在之前已经学习了Collection接口以及其对应的子接口，可以发现在Collection接口之中所保存的数据全部都只是单个对象，在数结构里面除了可以进行单个对象的保存之外，实际上也可以进行二元偶对象的保存(key=value)的形式来存储，而存储二元偶对象的核心意义在于，需要通过key获取对应的value。</p>
<p><strong><font color="red">在开发里面：Collection集合保存数据的目的是为了输出，Map集合保存数据的目的是为了进行key的查找。</font></strong></p>
<h4 id="1-map接口简介">1. Map接口简介</h4>
<p>​	Map接口是进行二元偶对象保存的最大父接口，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	该接口为一个独立的父接口，并且在进行接口对象实例化的时候需要设置Key与Value的类型，也就是说在整体操作的时候需要保存两个内容，在Map接口里面定义有许多的操作方法，但是需要记住以下的核心操作方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">public V put(K key,V value)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">向集合之中保存数据</td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">public V get(Object key)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">根据key查询数据</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">将Map集合转为Set集合</td>
</tr>
<tr>
<td style="text-align:center">04</td>
<td style="text-align:center">public boolean containsKey(Object key)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">查询指定的key是否存在</td>
</tr>
<tr>
<td style="text-align:center">05</td>
<td style="text-align:center">public Set<k> keySet()</k></td>
<td style="text-align:center">普通</td>
<td style="text-align:left">将Map集合中的key转为Set集合</td>
</tr>
<tr>
<td style="text-align:center">06</td>
<td style="text-align:center">public V remove(Object key)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">根据key删除掉指定的数据</td>
</tr>
</tbody>
</table>
<p>​	从JDK1.9之后Map接口里面也扩充了一些静态方法供用户使用。</p>
<p><strong>范例：</strong> 观察Map集合的特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String,Integer&gt; map = Map.of(<span class="string">"one"</span>,<span class="number">1</span>,<span class="string">"two"</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	在Map集合之中数据的保存就是按照 “key=value” 的形式存储的，并且使用of()方法操作的时候，里面的数据是不允许重复的，如果重复则会出现 “IllegalArgumentException” 异常，如果设置的内容为null，则会出现&quot;NullPointerException&quot;异常。</p>
<p>​	对于现在见到的of()方法严格意义上来讲并不是Map集合的标准用法，因为正常的开发之中需要通过Map接口的子类来进行接口对象的实例化，而常用的子类：HashMap、Hashtable、TreeMap、LinkedHashMap。</p>
<h4 id="2-hashmap子类">2. HashMap子类</h4>
<p>​	HashMap是Map接口之中最为常见的一个子类，该类的主要特点是 <font color="red">无序存储</font>，通过java文档首先来观察一下HashMap子类的定义形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>​	该类的定义继承形式符合之前的集合定形式，依然提供有抽象类，并且依然需要重复实现Map接口。</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-14-8220.png" alt="14"></p>
<p><strong>范例：</strong> 观察Map集合的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">		map.put(<span class="string">"two"</span>, <span class="number">2</span>);	</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">101</span>);	<span class="comment">//key重复</span></span><br><span class="line">		map.put(<span class="keyword">null</span>, <span class="number">111</span>);		<span class="comment">//key为null</span></span><br><span class="line">		map.put(<span class="string">"zero"</span>, <span class="keyword">null</span>);  <span class="comment">//value为null</span></span><br><span class="line">		System.out.println(map.get(<span class="string">"one"</span>));	<span class="comment">//key存在</span></span><br><span class="line">		System.out.println(map.get(<span class="keyword">null</span>));	<span class="comment">//key存在</span></span><br><span class="line">		System.out.println(map.get(<span class="string">"ten"</span>)); <span class="comment">//key不存在</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	以上的操作形式为Map集合使用的最标准的处理形式，通过代码可以发现，通过HashMap实例化的Map接口可以针对key或value保存null的数据，同时也可以发现及时保存数据的key重复，那么也不会出现错误，而是出现内容的替换。</p>
<p>​	但是对于Map接口中提供的put()方法本身是提供有返回值的，那么这个返回值指的是在重复key的情况下返回key的value</p>
<p><strong>范例：</strong> 观察put()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">		System.out.println(map.put(<span class="string">"one"</span>,<span class="number">1</span>)); <span class="comment">//key不重复,返回null</span></span><br><span class="line">		System.out.println(map.put(<span class="string">"one"</span>,<span class="number">101</span>)); <span class="comment">//key重复,返回旧数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	在设置了相同的key的内容的时候put()方法会返回原始的数据内容.</p>
<p>​	清楚了HashMap的基本功能之后, 下面就需要来研究一下HashMap之中给出的源代码. HashMap之中肯定要需要存储大量的数据, 那么对于数据的存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用无参构造的时候会出现有一个loadFactor属性, 并且该属性默认的内容为 “0.75” (<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用put()方法进行数据保存的时候会调用一个putVal()方法,同时会将key进行hash处理(生成一个hash码), 而对于putValue方法里面会发现依然会提供有一个Node节点类进行数据的保存, 而在使用putValue()方法操作的过程之中会调用有一个resize()的方法可以进行容量的扩充.</p>
</blockquote>
<p><strong>面试题:</strong> 在进行HashMap的put()操作的时候,如何实现容量扩充的?</p>
<ul>
<li>在HashMap类里面提供有一个 “DEFAULT_INITIAL_CAPACITY” 常量,作为初始化的容量配置,而后这个常量的默认大小为16个元素, 也就是说默认可以保存的最大内容是16;</li>
<li>当保存的内容的容量超过了一个阈值 (DEFAULT_LOAD_FACTOR = 0.75f), 相当于 “容量*阈值=12” 保存12个元素的时候就会进行容量的扩充;</li>
<li>在进行扩充的时候HashMap采用的是成倍的扩充模式, 即: 每一次都扩充2倍的容量</li>
</ul>
<p><strong>面试题:</strong> 请解释HashMap的工作原理(JDK1.8之后开始的)</p>
<ul>
<li>在HashMap之中进行数据存储的依然是利用了Node类完成的, 那么这种情况下就证明可以使用的数据结构只有两种: 链表(时间复杂度&quot;O(n)&quot;)、二叉树(时间复杂度&quot;O(logn)&quot;);</li>
<li>从JDK1.8开始, HashMap的实现出现了改变, 因为其要适应于大数据时代的海量数据问题,所以对于其存储发生了变化, 并且在HashMap类的内部提供有一个重要的常量: “static final int UNTREEIFY_THRESHOLD = 6;”, 在使用HashMap进行数据保存的时候,如果保存的数据个数没有超过阈值8(UNTREEIFY_THRESHOLD), 那么会按照链表的形式进行存储, 而如果超过了这个阈值, 则会将链表转为<strong>红黑树</strong>以实现树的平衡, 并且利用左旋与右旋保证数据的查询性能.</li>
</ul>
<h4 id="3-linkedhashmap子类">3. LinkedHashMap子类</h4>
<p>​	HashMap虽然是Map集合最为常用的一个子类, 但是其本身所保存的数据都是无序的(有序与否对Map没有影响), 如果现在希望Map集合之中保存的顺序为其增加顺序, 则就可以更换子类为LinkedHashMap(基于链表实现的), 观察LinkedHashMap类的定义形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	既然是链表保存, 所以一般在使用LinkedHashMap类的时候往往数据量都不要特别大, 因为会造成时间复杂度攀升. 通过继承结构可以发现LinkedHashMap是HashMap子类,继承关系如下:</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-15-8220.png" alt="15"></p>
<p><strong>范例:</strong> 使用LinkedHashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String,Integer&gt;();</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">		map.put(<span class="string">"two"</span>, <span class="number">2</span>);	</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">101</span>);	<span class="comment">//key重复</span></span><br><span class="line">		map.put(<span class="keyword">null</span>, <span class="number">111</span>);		<span class="comment">//key为null</span></span><br><span class="line">		map.put(<span class="string">"zero"</span>, <span class="keyword">null</span>);  <span class="comment">//value为null</span></span><br><span class="line">		System.out.println(map);	<span class="comment">//key存在</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过此事的程序执行可以发现当使用LinkedHashMap进行存储之后所有数据的保存顺序为我们的添加顺序.</p>
<h4 id="4-hashtable子类">4. Hashtable子类</h4>
<p>​	Hashtable类是从JDK1.0的时候提供的, 与Vector、Enumeration属于最早的一批动态数组的实现类,后来为了将其继续保存下来所以让其多现实现了一个Map接口, Hashtable类的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-16-8220.png" alt="16"></p>
<p><strong>范例:</strong> 观察Hashtable子类的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String,Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;String,Integer&gt;();</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">		map.put(<span class="string">"two"</span>, <span class="number">2</span>);	</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">101</span>);	<span class="comment">//key重复</span></span><br><span class="line">		System.out.println(map);	<span class="comment">//key存在</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过观察可以发现在Hashtable里面进行数据存储的时候设置的key或value都不允许为null, 否则会出现NullPointerException异常.</p>
<p><strong>面试题:</strong> 请解释HashMap与Hashtable的区别?</p>
<ul>
<li>HashMap中的方法都属于异步操作,(非线程安全), HashMap允许保存有null数据</li>
<li>Hashtable中的方法都属于同步方法(线程安全), Hashtable不允许保存null, 否则会出现NullPointerException.</li>
</ul>
<h4 id="5-map-entry接口">5. Map.Entry接口</h4>
<p>​	虽然已经清楚了整个的Map集合的基本操作形式, 但是依然需要有一个核心的问题要解决, Map集合里面是如何进行数据存储的? 对于List而言(LinkedList子类) 依靠的是链表的形式实现的数据存储, 那么在进行数据存储的时候一定要将数据保存在一个Node节点之中, 虽然在HashMap里面也可以见到Node类型定义, 通过源代码定义可以发现, HashMap类中的Node内部类本身实现了Map.Entry接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​	所以可以得出结论: 所有的key和value的诗句都被封装在Map.Entry接口之中, 而此接口定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并且在这个内部接口里面提供有两个重要的操作方法:</p>
<ul>
<li>获取key:   public K getKey()</li>
<li>获取value: public V getValue()</li>
</ul>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-17-8220.png" alt="17"></p>
<p>​	在JDK1.9以前的开发版本之中, 使用者基本上都不会去考虑创建Map.Entry的对象, 实际上在正常的开发过程之中使用者也不需要关心Map.Entry对象的创建, 可是从 JDK1.9之后, Map接口里面追加有一个新的方法</p>
<ul>
<li>创建Map.Entry对象: public static &lt;K,V&gt; Map.Entry&lt;K,V&gt; entry(K k, V v)</li>
</ul>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-18-8220.png" alt="18"></p>
<p><strong>范例:</strong> 创建Map.Entry对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map.Entry&lt;String, Integer&gt; entry = Map.entry(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"获取key: "</span> + entry.getKey());</span><br><span class="line">		System.out.println(<span class="string">"获取value: "</span> + entry.getValue());</span><br><span class="line">		System.out.println(entry.getClass().getName()); 	<span class="comment">//观察使用的子类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过分析可以发现在整个Map集合里面, Map.Entry的主要作用就是作为一个Key和Value的包装类型使用, 而大部分情况下在进行数据存储的时候都会将key和value包装为一个Map.Entry对象进行使用.</p>
<h4 id="6-利用iterator输出map集合">6. 利用Iterator输出Map集合</h4>
<p>​	对于集合的输出而言, 最标准的做法就是利用Iterator接口来完成, 但是需要明确一点的是在Map集合里面并没有一个方法可以直接返回Iterator接口对象, 所以这种情况下就必须分析不直接提供Iterator接口实例化的方法的原因, 下面对Collection与Map集合的存储结构进行一个比较处理.</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-19-8220.png" alt="19"></p>
<p>​	发现在Map集合里面保存的实际上是一组Map.Entry接口对象(里面包装的是Key与Value), 所以整个来讲Map依然实现的是单值的保存, 这样在Map集合里面提供有一个方法 “public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()”, 将全部的Map集合转为Set集合.</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-20-8220.png" alt="20"></p>
<p>经过分析可以发现如果要想使用Iterator实现Map集合的输出则必须按照如下步骤处理:</p>
<ul>
<li>利用Map接口中提供的entrySet()方法将Map集合转为Set集合</li>
<li>利用Set接口中的iterator()方法将Set集合转为Iterator接口实例;</li>
<li>利用Iterator进行迭代输出获取每一组的Map.Entry对象, 随后通过getKey()与getValue()获取数据</li>
</ul>
<p><strong>范例:</strong> 利用Iterator输出Map集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">1</span>) ;</span><br><span class="line">		map.put(<span class="string">"two"</span>, <span class="number">2</span>) ;</span><br><span class="line">		Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet() ;	<span class="comment">//将Map集合变为Set集合</span></span><br><span class="line">		Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = set.iterator() ;</span><br><span class="line">		<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">			Map.Entry&lt;String, Integer&gt; me = iter.next() ;</span><br><span class="line">			System.out.println(me.getKey() + <span class="string">" = "</span> + me.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	虽然Map集合本身支持有迭代输出的支持, 但是如果从实际的开发来讲, Map集合最主要的用法在于实现数据的Key查找操作, 另外需要提醒的是, 如果现在不使用Iterator而使用foreach语法输出则也需要将Map集合转为Set集合.</p>
<p><strong>范例:</strong> 使用foreach输出Map集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">		map.put(<span class="string">"one"</span>, <span class="number">1</span>) ;</span><br><span class="line">		map.put(<span class="string">"two"</span>, <span class="number">2</span>) ;</span><br><span class="line">		Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet() ;	<span class="comment">//将Map集合变为Set集合</span></span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : set) &#123;</span><br><span class="line">			System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于map迭代输出的情况相对较少, 所以对于此类的语法应该深入理解一下, 并且一定要灵活掌握.</p>
<blockquote>
<p>因为在实际开发之中, 这些集合互相倒来倒去的情况是非常常见的</p>
</blockquote>
<h4 id="7-自定义map的key类型">7. 自定义Map的key类型</h4>
<p>​	在使用Map集合的时候可以发现对于Key和Value的类型实际上都可以由使用者任意决定, 那么也就意味着现在依然可以使用自定义的类来进行key类型的设置. 对于自定义Key类型所在的类中一定要覆写hashCode()与equals()方法, 否则无法查找到.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在进行数据保存的时候发现会自动使用传入的key的数据生成一个hash码, 也就是说存储的时候是这个Hash数值.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在根据key获取数据的时候依然要将传入的key通过hash()方法爱获取其对应的hash码, 那么也就证明, 查询的过程之中首先要利用我们的hashCode()来进行数据查询, 当使用getNode()方法查询的时候还需要使用到euqals()方法.</p>
</blockquote>
<p><strong>范例:</strong> 使用自定义类作为Key类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name ;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		result = prime * result + age;</span><br><span class="line">		result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Person other = (Person) obj;</span><br><span class="line">		<span class="keyword">if</span> (age != other.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Map&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line">		map.put(<span class="keyword">new</span> Person(<span class="string">"周瑜"</span>,<span class="number">28</span>), <span class="string">"字公瑾"</span>);	<span class="comment">//使用自定义类作为Key</span></span><br><span class="line">		System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">"周瑜"</span>,<span class="number">28</span>)));	<span class="comment">//通过key找到Value</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	虽然允许你使用是定义的类作为key的类型, 但是也需要注意一点, 在实际的开发之中对于Map集合的Key常用的类型就是三种: String、Long、Integer, 尽量使用系统类.</p>
<p><strong>面试题:</strong> 如果在进行HashMap进行数据操作的时候出现了Hash冲突(Hash码相同), HashMap是如何解决的?</p>
<p>​	当出现了Hash冲突之后为了保证程序的正常执行, 会在冲突的位置上将所有Hash冲突的内容转为链表保存.</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-21-8220.png" alt="21"></p>
<h3 id="六-集合工具类">六、集合工具类</h3>
<h4 id="1-stack栈">1. Stack栈</h4>
<p>​	栈是一种先进后出的数据结构. 例如: 在文本编辑器上都有撤销功能, 那么每次使用的时候你会发现, 最后一次的编辑操作永远是最先撤销, 那么这个功能就是利用栈来实现的, 栈的及基本操作形式如下:</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-22-8220.png" alt="22"></p>
<p>​	在Java程序里面使用Stack来描述栈的操作, 这个类定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以发现Stack是Vector子类, 但是它使用的并不是Vector类之中所提供的方法, 而是采用如下的两个方法:</p>
<ul>
<li>入栈: public E push(E item)</li>
<li>出栈: public E pop()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Stack&lt;String&gt; all = <span class="keyword">new</span> Stack&lt;String&gt; ();</span><br><span class="line">		all.push(<span class="string">"A"</span>) ;</span><br><span class="line">		all.push(<span class="string">"B"</span>) ;</span><br><span class="line">		all.push(<span class="string">"C"</span>) ;</span><br><span class="line">		System.out.println(all.pop());</span><br><span class="line">		System.out.println(all.pop());</span><br><span class="line">		System.out.println(all.pop());</span><br><span class="line">		System.out.println(all.pop());	<span class="comment">//无数据、EmptyStackException</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过此时的数据可以发现, 所有的数据保存之后将按照倒序的形式进行弹出, 如果栈已经空了, 则会抛出空栈异常.</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-23-8220.png" alt="23"></p>
<h4 id="2-queue队列">2. Queue队列</h4>
<p>​	Queue描述的是一个队列, 而队列的主要特点是实现先进先出的操作形式. 其基本的操作形式如下:</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-24-8220.png" alt="24"></p>
<p>​	如果将队列引用在多线程的 “生产者与消费者” 的模型处理上, 那么对于生产者过快生产过快的情况下,就没有必要等待消费者获取数据了, 可以将所有的内容直接保存在队列之中, 队列的实现可以使用LinkedList子类来完.</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-25-8220.png" alt="25"></p>
<p>队列的使用主要依靠Queue接口之中提供的方法来处理. 提供有如下方法:</p>
<ul>
<li>向队列之中追加数据: public boolean offer(E e), 可以直接使用add()方法</li>
<li>通过队列获取数据: public E poll(), 弹出后删除数据</li>
</ul>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-26-8220.png" alt="26"></p>
<p><strong>范例:</strong> 实现队列操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt; () ;</span><br><span class="line">		queue.offer(<span class="string">"X"</span>);	<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">		queue.offer(<span class="string">"A"</span>);	<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">		queue.offer(<span class="string">"Z"</span>);	<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">		System.err.println(queue.poll());	<span class="comment">//弹出数据 、X</span></span><br><span class="line">		System.err.println(queue.poll());	<span class="comment">//弹出数据 、A</span></span><br><span class="line">		System.err.println(queue.poll());	<span class="comment">//弹出数据 、Z</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	除了LinkedList子类之外, 还有一个优先级的概念, 可以使用PriorityQueue实现优先级队列(比较功能),</p>
<p><strong>范例:</strong> 使用优先级队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Queue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;String&gt; () ;</span><br><span class="line">		queue.offer(<span class="string">"X"</span>);	<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">		queue.offer(<span class="string">"A"</span>);	<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">		queue.offer(<span class="string">"Z"</span>);	<span class="comment">// 追加队列数据, 通过队尾追加</span></span><br><span class="line">		System.err.println(queue.poll());	<span class="comment">//弹出数据 、X</span></span><br><span class="line">		System.err.println(queue.poll());	<span class="comment">//弹出数据 、A</span></span><br><span class="line">		System.err.println(queue.poll());	<span class="comment">//弹出数据 、Z</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	对于队列的选用原则也是需要根据实际的项目环境来决定的.</p>
<h4 id="3-properties属性操作">3. Properties属性操作</h4>
<p>​	在之前讲解国际化程序的时候讲解过资源文件(*.properties), 那么这类文件的存储结构是按照 “key=value” 的, 而这种结构的保存形式与Map集合很相似, 但是唯一的区别在于其所保存的内容只能够是字符串, 所以为了可以方便的描述属性的定义, java.util包里面提供有Properties类型, 此类是Hashtable的子类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​	可以发现在继承Hashtable的时候为Hashtable中定义的泛型为Object, Properties是不需要操作泛型的, 因为它可以操作类型只能是String类型. 在Properties之中如果要想实现属性的操作可以采用如下的方法来实现:</p>
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">public Object setProperty(String key, String value)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">设置属性</td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">public String getProperty(String key)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">取得属性, key不存在返回null</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">public String getProperty(String key, String defaultValue)</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">取得属性, key不存在返回默认值</td>
</tr>
<tr>
<td style="text-align:center">04</td>
<td style="text-align:center">public void store(OutputStream out, String comments) throws IOException</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">输出属性内容</td>
</tr>
<tr>
<td style="text-align:center">05</td>
<td style="text-align:center">public void load(InputStream inStream) throws IOException</td>
<td style="text-align:center">普通</td>
<td style="text-align:left">通过输入流读取属性内容</td>
</tr>
</tbody>
</table>
<p>范例: 观察属性的设置与取得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line">		<span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">		prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">		System.out.println(prop.getProperty(<span class="string">"ngp"</span>));</span><br><span class="line">		System.out.println(prop.getProperty(<span class="string">"sina"</span>,<span class="string">"Nofound"</span>));</span><br><span class="line">		System.out.println(prop.getProperty(<span class="string">"sina"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过代码可以发现Properties里面可以像Map结婚那样进行内容的设置与获取, 但是唯一的差别是它只能够操作String类型, 另外需要注意的是, 之所以会提供有Properties类还有一个最重要的功能是它可以通过输出流输出属性, 也可以使用输入流读取属性内容.</p>
<p>范例: 将属性内容保存在文件之中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line">		<span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">		prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"BeiJing"</span>,<span class="string">"北京"</span>);</span><br><span class="line">		prop.store(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"info.properties"</span>)), <span class="string">"中文的注释看不见-english"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	通过程序的执行可以发现, 的确可以实现资源文件的输入处理, 但是如果输出的是中文则自动帮助用户进行转码处理.</p>
<p><strong>范例:</strong> 读取资源文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties() ;</span><br><span class="line">		<span class="comment">//设置的内容只允许是字符串</span></span><br><span class="line">		prop.setProperty(<span class="string">"ngp"</span>,<span class="string">"www.ngp.cn"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"ngpjava"</span>,<span class="string">"www.ngpjava.cn"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"BeiJing"</span>,<span class="string">"北京"</span>);</span><br><span class="line">		prop.load(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"info.properties"</span>)));</span><br><span class="line">		System.out.println(prop.getProperty(<span class="string">"ngp"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	使用Properties类型的最大特点是可以进行资源内容的输入与输出的处理操作, 但是在实际的开发之中Properties往往用于读取配置资源的信息, 这一点主要是在标准设计之中做程序初始化准备的时候使用.</p>
<h4 id="4-collections工具类">4. Collections工具类</h4>
<p>​	Collection是java提供的一组集合数据的操作工具类, 也就是说利用它可以实现各个集合的操作.</p>
<p><img src="https://ngp8264-pic.oss-cn-hongkong.aliyuncs.com/images/2019-04-24-27-8220.png" alt="27"></p>
<p><strong>范例:</strong> 使用Collection操作List集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">		Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">		System.out.println(all);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>范例:</strong> 数据的反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">		Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">		Collections.reverse(all);</span><br><span class="line">		System.out.println(all);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>范例:</strong>  使用二分查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ngp.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">		Collections.addAll(all, <span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"NGP"</span>);</span><br><span class="line">		Collections.sort(all);	<span class="comment">// 先进行排序处理</span></span><br><span class="line">		System.out.println(all);</span><br><span class="line">		System.out.println(Collections.binarySearch(all,<span class="string">"NGP"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分情况下对于集合的使用可能没有这么多复杂要求, 更多的情况下就是利用集合保存数据, 要么进行输出要么进行查询.</p>
<p>面试题: 请解释Collection与Collections的区别?</p>
<ul>
<li>Collection是集合接口, 允许保存单值对象;</li>
<li>Collection是集合操作的工具类.</li>
</ul>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> Donate
            </a>
        </div>
        
        <div class="post-tags">Tags：
            
            <a href="/tags/java/">java</a>
            
        </div>
        
    </article>
    
    <p style="text-align: center">This article just represents my own viewpoint. If there is something wrong, please correct me.</p>
    
    

    
    
        
        
        
        
        
        <script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"> </script>
        <div id="gitalk-container"></div>
        <script type="text/javascript">
            var gitalk = new Gitalk({
                clientID: 'fa61ee47d3bb3963923d',
                clientSecret: '815c537bdd810b517fd3713374c49f49477d37b6',
                id: window.location.pathname,
                repo: 'gitalk-comment',
                owner: 'ngp320',
                admin: 'ngp320',
                distractionFreeMode: 'true'
            })
            gitalk.render('gitalk-container')
        </script>
    


</div>
<script src="/js/busuanzi.pure.mini.js"></script>


        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner" style="text-align: center">
        <p>
            <a href="/about" title="About">About</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="Help">Help</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="Links">Links</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/sitemap.xml" title="SiteMap">SiteMap</a>
        </p>
        <p>
            Has been established&nbsp<a href="/timeline" id="siteBuildingTime"></a>&nbspDays，<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="licence">Based on Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a><br>
            ©2017-<span id="cpYear"></span> Based on&nbsp<a href="http://hexo.io" target="_blank" rel="nofollow">Hexo</a>
            ，Theme by&nbsp&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank" rel="bookmark">JSimple</a>
            ，Author&nbsp<a href="https://tanghao.fun/" target="_blank" rel="friend">97年的顽石</a>
            ，Hosted by <a href="https://pages.github.com/" target="_blank" rel="nofollow">GitHub Pages</a>
        </p>
    </div>
</footer>
<script src="/js/SimpleCore.js"></script>
<script src="/js/clipboard.min.js"></script>
<script src="/js/clipboard-use.js"></script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f41d202b2d4f8f5e6ec6372d0e49a243";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</div>
<!-- search pop -->
<div class="popup search-popup local-search-popup">
    <div class="local-search-header clearfix">
        <span class="search-icon">
            <i class="fa fa-search"></i>
        </span>
        <span class="popup-btn-close">
            <i class="fa fa-times-circle"></i>
        </span>
        <div class="local-search-input-wrapper">
            <input id="local-search-input" spellcheck="false" type="text" autocomplete="off" placeholder="Input query keywords here...">
        </div>
    </div>
    <div id="local-search-result"></div>
</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        var jsi_config = {
            buildingTime: '03/26/2019',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
            localSearch: { dbPath: '' },
            readMode: 'day'
        };
        
            jsi_config.localSearch = {
                dbPath: '/search.xml',
                trigger: 'auto',
                topN: '1',
                unescape: 'false'
            }
        
        SimpleCore.init(jsi_config);
        
    });
    var host = "https://tanghao-fun-1.disqus.com/";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
</script>
</body>
</html>
